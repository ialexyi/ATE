/*****************************************************************************/
/*  hpesa.c                                                                  */
/*  Copyright (C) 1999-2000 Agilent Technologies                             */
/*---------------------------------------------------------------------------*/
/*  Driver for hpesa, Agilent Technologies ESA Series Spectrum Analyzer      */
/*  Driver Version: A.03.00                                                  */
/*---------------------------------------------------------------------------*/
/*  This driver is compatible with the following VXIplug&play standards:     */
/*    WIN32 System Framework revision 4.0                                    */
/*    VISA revision 1.2 (does not work with VTL)                             */
/*****************************************************************************/

#define hpesa_REV_CODE    "A.03.00"                /* Driver Revision */

/*****************************************************************************/
/* Exactly one of the following must be defined for the program to           */
/*   compile correctly.                                                      */
/*                                                                           */
/* #define __hpux          (for compilation for HP-UX)                       */
/* #define WIN32           (for compilation for 32-bit Windows)              */
/*                                                                           */
/* In addition, if WIN32 is defined, _CVI_ may also be defined to indicate   */
/*   that the program is being compiled under LabWindows CVI 4.0 or          */
/*   greater.                                                                */
/*****************************************************************************/

/*****************************************************************************/
/* The following defines are intended to provide OS compatibility among      */
/*   Windows 32-bit and HP-UX C compilers.                                   */
/*****************************************************************************/

#ifdef __hpux
#define _fcvt    fcvt
#endif

#define _huge

/*****************************************************************************/

#include <stdlib.h>           /* prototype for malloc()  */
#include <string.h>           /* prototype for strcpy()  */
#include <stdio.h>            /* prototype for sprintf() */
#include <math.h>             /* prototype for pow()     */
#include <errno.h>            /* definition of errno and ERANGE */
/*#include <varargs.h>           prototype for vararg stuff in the      */
                              /*   delayQueryf and delayRead functions  */
#include <time.h>

#ifdef __hpux
#define _INCLUDE_HPUX_SOURCE                    USUALLY NEEDED
#define _INCLUDE_XOPEN_SOURCE_EXTENDED          USUALLY NEEDED
#include <sys/time.h>
#else
#include <windows.h>
#endif

#include "visa.h"
#include "hpesa.h"

#define hpesa_ERR_MSG_LENGTH 160   /* size of error message buffer     */
#define ZERO_DELAY          0       /* Number of milliseconds to delay. */
                                    /*   See doDelay function.          */


/*****************************************************************************/
/*  The string below is used to do the instrument identification in the      */
/*    init routine.  The string matches the first part of the instrument's   */
/*    response to it's *IDN? command.                                        */
/*****************************************************************************/

#define hpesa_IDN_STRING_E4401B  "Hewlett-Packard, E4401B"
#define hpesa_IDN_STRING_E4402B  "Hewlett-Packard, E4402B"
#define hpesa_IDN_STRING_E4403B  "Hewlett-Packard, E4403B"
#define hpesa_IDN_STRING_E4404B  "Hewlett-Packard, E4404B"
#define hpesa_IDN_STRING_E4405B  "Hewlett-Packard, E4405B"
#define hpesa_IDN_STRING_E4407B  "Hewlett-Packard, E4407B"
#define hpesa_IDN_STRING_E4408B  "Hewlett-Packard, E4408B"
#define hpesa_IDN_STRING_E4411B  "Hewlett-Packard, E4411B"

/*****************************************************************************/
/*  VISA Globals data structure.                                             */
/*  It is desireable to store global variables in VISA rather than the       */
/*    driver.  This avoids having any state variables in the driver.  This   */
/*    structure defines the driver's global data.  Memory is allocated to    */
/*    this structure in the init function, which passes the pointer to VISA, */
/*    and every function which follows retrieves a pointer to it.            */
/*****************************************************************************/

struct hpesa_globals
{
    ViStatus     errNumber;
    char         errMessage[160];

    ViBoolean    errQueryDetect;

    ViInt32      dTime;

    ViUInt16     interfaceType;
        
        /**************************/
        /*  Instrument Specific   */
        /**************************/

    ViChar       instrumentIDString[256];

    ViReal64     drvRev;

    ViReal64     instRev;

    ViBoolean    verifyApp;
    
};


/*****************************************************************************/
/*  Driver Message Strings.                                                  */
/*****************************************************************************/

#define hpesa_MSG_VI_OPEN_ERR            "vi was zero.  Was the hpesa_init() successful?"
#define hpesa_MSG_CONDITION              "condition"
#define hpesa_MSG_EVENT                  "event"    
#define hpesa_MSG_EVENT_HDLR_INSTALLED   "event handler is already installed for event happening"
#define hpesa_MSG_EVENT_HDLR_INST2       "Only 1 handler can be installed at a time."    
#define hpesa_MSG_INVALID_HAPPENING      "is not a valid happening."
#define hpesa_MSG_NOT_QUERIABLE          "is not queriable."    
#define hpesa_MSG_INVALID_STATUS         "Parameter 2 is invalid in function hpesa_error_message()."
#define hpesa_MSG_INVALID_STATUS_VALUE   "is not a valid viStatus value."
#define hpesa_MSG_INVALID_VI             "Parameter 1 is invalid in function hpesa_error_message()."  \
                                        "  Using an inactive ViSession may cause this error."    \
                                        "  Was the instrument driver closed prematurely?"
#define hpesa_MSG_NO_ERRORS              "No Errors"
#define hpesa_MSG_SELF_TEST_FAILED       "Self test failed."     
#define hpesa_MSG_SELF_TEST_PASSED       "Self test passed."

#define hpesa_MSG_BOOLEAN                "Expected 0 or 1; Got %hd"
#define hpesa_MSG_REAL                   "Expected %lg to %lg; Got %lg"
#define hpesa_MSG_INT                    "Expected %hd to %hd; Got %hd"
#define hpesa_MSG_LONG                   "Expected %ld to %ld; Got %ld"
#define hpesa_MSG_LOOKUP                 "Error converting string response to integer"
#define hpesa_MSG_NO_MATCH               "Could not match string %s"
#define hpesa_MSG_INVALID_APP            "Expected to be in %s; currently in %s."

#define VI_ERROR_PARAMETER1_MSG           "Parameter 1 is invalid"
#define VI_ERROR_PARAMETER2_MSG           "Parameter 2 is invalid"
#define VI_ERROR_PARAMETER3_MSG           "Parameter 3 is invalid"
#define VI_ERROR_PARAMETER4_MSG           "Parameter 4 is invalid"
#define VI_ERROR_PARAMETER5_MSG           "Parameter 5 is invalid"
#define VI_ERROR_PARAMETER6_MSG           "Parameter 6 is invalid"
#define VI_ERROR_PARAMETER7_MSG           "Parameter 7 is invalid"
#define VI_ERROR_PARAMETER8_MSG           "Parameter 8 is invalid"
#define VI_ERROR_PARAMETER9_MSG           "Parameter 9 is invalid"
#define VI_ERROR_PARAMETER10_MSG          "Parameter 10 is invalid"
#define VI_ERROR_PARAMETER11_MSG          "Parameter 11 is invalid"
#define VI_ERROR_PARAMETER12_MSG          "Parameter 12 is invalid"
#define VI_ERROR_PARAMETER13_MSG          "Parameter 13 is invalid"
#define VI_ERROR_PARAMETER14_MSG          "Parameter 14 is invalid"
#define VI_ERROR_PARAMETER15_MSG          "Parameter 15 is invalid"
#define VI_ERROR_PARAMETER16_MSG          "Parameter 16 is invalid"
#define VI_ERROR_PARAMETER17_MSG          "Parameter 17 is invalid"
#define VI_ERROR_PARAMETER18_MSG          "Parameter 18 is invalid"
#define VI_ERROR_FAIL_ID_QUERY_MSG        "Instrument IDN does not match."

#define INSTR_ERROR_INV_SESSION_MSG       "ViSession (parameter 1) was not created by this driver"
#define INSTR_ERROR_NULL_PTR_MSG          "NULL pointer detected"
#define INSTR_ERROR_RESET_FAILED_MSG      "reset failed"
#define INSTR_ERROR_UNEXPECTED_MSG        "An unexpected error occurred"
#define INSTR_ERROR_DETECTED_MSG          "Instrument Error Detected, call hpesa_error_query()."
#define INSTR_ERROR_LOOKUP_MSG            "String not found in table"
#define INSTR_ERROR_NO_LAST_COMMA         "No last comma found in IDN string"
#define INSTR_ERROR_INV_ASCII_NUMBER      "Error converting ASCII to numeric."
#define INSTR_ERROR_INVALID_APP           "Current application not valid"
#define INSTR_ERROR_INVALID_RESULTS_TYPE  "Specified results type are not valid for this measurement."

/*****************************************************************************/
/*  Error table structure.                                                   */
/*    The first element of the table is the error number, the second is the  */
/*    error message.  Error numbers in the "VISA Generic" section of the     */
/*    table are defined in the VISA header files.  Error numbers in the      */
/*    "Instrument Specific" section are defined in the driver header file.   */
/*    All of the error messages are defined above.                           */
/*****************************************************************************/

struct instrErrStruct
{
    ViStatus errStatus;
    ViString errMessage;
};

const static struct instrErrStruct instrErrMsgTable[] =
{
        /**************************/
        /*  Template Messages     */
        /**************************/

    { VI_ERROR_FAIL_ID_QUERY,            VI_ERROR_FAIL_ID_QUERY_MSG },
    { VI_ERROR_PARAMETER1,               VI_ERROR_PARAMETER1_MSG },
    { VI_ERROR_PARAMETER2,               VI_ERROR_PARAMETER2_MSG },
    { VI_ERROR_PARAMETER3,               VI_ERROR_PARAMETER3_MSG },
    { VI_ERROR_PARAMETER4,               VI_ERROR_PARAMETER4_MSG },
    { VI_ERROR_PARAMETER5,               VI_ERROR_PARAMETER5_MSG },
    { VI_ERROR_PARAMETER6,               VI_ERROR_PARAMETER6_MSG },
    { VI_ERROR_PARAMETER7,               VI_ERROR_PARAMETER7_MSG },
    { VI_ERROR_PARAMETER8,               VI_ERROR_PARAMETER8_MSG },
    { hpesa_INSTR_ERROR_PARAMETER9,      VI_ERROR_PARAMETER9_MSG },
    { hpesa_INSTR_ERROR_PARAMETER10,     VI_ERROR_PARAMETER10_MSG },
    { hpesa_INSTR_ERROR_PARAMETER11,     VI_ERROR_PARAMETER11_MSG },
    { hpesa_INSTR_ERROR_PARAMETER12,     VI_ERROR_PARAMETER12_MSG },
    { hpesa_INSTR_ERROR_PARAMETER13,     VI_ERROR_PARAMETER13_MSG },
    { hpesa_INSTR_ERROR_PARAMETER14,     VI_ERROR_PARAMETER14_MSG },
    { hpesa_INSTR_ERROR_PARAMETER15,     VI_ERROR_PARAMETER15_MSG },
    { hpesa_INSTR_ERROR_PARAMETER16,     VI_ERROR_PARAMETER16_MSG },
    { hpesa_INSTR_ERROR_PARAMETER17,     VI_ERROR_PARAMETER17_MSG },
    { hpesa_INSTR_ERROR_PARAMETER18,     VI_ERROR_PARAMETER18_MSG },
    { hpesa_INSTR_ERROR_INV_SESSION,     INSTR_ERROR_INV_SESSION_MSG },
    { hpesa_INSTR_ERROR_NULL_PTR,        INSTR_ERROR_NULL_PTR_MSG },
    { hpesa_INSTR_ERROR_RESET_FAILED,    INSTR_ERROR_RESET_FAILED_MSG },
    { hpesa_INSTR_ERROR_UNEXPECTED,      INSTR_ERROR_UNEXPECTED_MSG },
    { hpesa_INSTR_ERROR_DETECTED,        INSTR_ERROR_DETECTED_MSG },
    { hpesa_INSTR_ERROR_LOOKUP,          INSTR_ERROR_LOOKUP_MSG },
    { hpesa_INSTR_NO_LAST_COMMA,         INSTR_ERROR_NO_LAST_COMMA }, 
    { hpesa_INSTR_INV_ASCII_NUMBER,      INSTR_ERROR_INV_ASCII_NUMBER },

        /**************************/
        /*  Instrument Specific   */
        /**************************/

    {hpesa_INSTR_ERROR_INVALID_APP,      INSTR_ERROR_INVALID_APP},
    {hpesa_INSTR_ERROR_INVALID_RESULTS_TYPE, INSTR_ERROR_INVALID_RESULTS_TYPE}
};


/*****************************************************************************/
/*****************************************************************************/
/********************                                     ********************/
/**********                                                         **********/
/****                   SUPPORTING MACROS AND FUNCTIONS                   ****/
/**                                                                         **/
/**-------------------------------------------------------------------------**/
/**     These macros and functions are not exposed to the user, but         **/
/**     are used by other functions in the driver.                          **/
/****                                                                     ****/
/**********                                                         **********/
/********************                                     ********************/
/*****************************************************************************/
/*****************************************************************************/

static ViStatus _VI_FUNC VerifyApp(ViSession instrumentHandle,
                                   ViInt16 AppNumber);




/*****************************************************************************/
/*  SWAP MACROS                                                              */
/*****************************************************************************/
/*  Reorders bytes where instrument byte ordering of integers and reals      */
/*    differs from the computing framework.                                  */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    dest                                                                   */
/*      The number to be reordered.  The reordered result is also stored in  */
/*      this variable on completion.                                         */
/*****************************************************************************/


#define SWAP_FLOAT64(dest)                                         \
 { unsigned char    src[8];                                        \
      *((double *)src) = *((double *)dest);                        \
      ((unsigned char *)(dest))[0] =  ((unsigned char*)(src))[7];  \
      ((unsigned char *)(dest))[1] =  ((unsigned char*)(src))[6];  \
      ((unsigned char *)(dest))[2] =  ((unsigned char*)(src))[5];  \
      ((unsigned char *)(dest))[3] =  ((unsigned char*)(src))[4];  \
      ((unsigned char *)(dest))[4] =  ((unsigned char*)(src))[3];  \
      ((unsigned char *)(dest))[5] =  ((unsigned char*)(src))[2];  \
      ((unsigned char *)(dest))[6] =  ((unsigned char*)(src))[1];  \
      ((unsigned char *)(dest))[7] =  ((unsigned char*)(src))[0];  \
 }

#define SWAP_32(dest)                                              \
 { unsigned char    src[4];                                        \
      *((long *)src) = *((long *)dest);                            \
      ((unsigned char *)(dest))[0] =  ((unsigned char*)(src))[3];  \
      ((unsigned char *)(dest))[1] =  ((unsigned char*)(src))[2];  \
      ((unsigned char *)(dest))[2] =  ((unsigned char*)(src))[1];  \
      ((unsigned char *)(dest))[3] =  ((unsigned char*)(src))[0];  \
 }

#define SWAP_16(dest)                                              \
 { unsigned char    src[2];                                        \
      *((int *)src) = *((int *)dest);                              \
      ((unsigned char *)(dest))[0] =  ((unsigned char*)(src))[1];  \
      ((unsigned char *)(dest))[1] =  ((unsigned char*)(src))[0];  \
 }


/*****************************************************************************/
/*  MACRO GET_GLOBALS                                                        */
/*****************************************************************************/
/*  Returns a pointer to the VISA globals storage.  This storage was         */
/*    allocated in init, but it is turned over to VISA to avoid holding      */
/*    state variables in the driver.                                         */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession            instrumentHandle                                  */
/*      The instrument's VISA address.                                       */
/*    struct hpesa_globals  *thisPtr                                         */
/*      A pointer to the VISA globals storage                                */
/*    funcname                                                               */
/*      The name of the function to be stored with the context dependent     */
/*      error information.                                                   */
/*****************************************************************************/

#define GET_GLOBALS(instrumentHandle,thisPtr)                                \
{                                                                            \
    errStatus = viGetAttribute(instrumentHandle, VI_ATTR_USER_DATA,          \
                                                      (ViAddr) &thisPtr);    \
    if (errStatus < VI_SUCCESS)                                              \
        return errStatus;                                                    \
}

     /*----------------------------------------------------------------*
      |  MACRO CHK_NULL_POINTER                                        |
      |    Incorporates null pointer checking and error checking.      |
      |    Refer to chk_null_pointer function for more info.           |
      *----------------------------------------------------------------*/

#define CHK_NULL_POINTER(chk_val, err)                      \
if (chk_null_pointer(thisPtr, chk_val))                     \
    {                                                       \
        thisPtr->errNumber = err;                           \
        return err;                                         \
}                                                           \


     /*----------------------------------------------------------------*
      |  MACRO CHK_BOOLEAN                                             |
      |    Incorporates boolean checking and error checking.           |
      |    Refer to chk_boolean function for more info.                |
      *----------------------------------------------------------------*/

#define CHK_BOOLEAN(chk_val, err)                          \
if (chk_boolean(thisPtr, chk_val))                         \
   {                                                       \
    thisPtr->errNumber = err;                              \
    return err;                                            \
   }


     /*----------------------------------------------------------------*
      |  MACRO CHK_REAL_RANGE                                          |
      |    Incorporates real number range checking and error checking. |
      |    Refer to chk_real_range function for more info.             |
      *----------------------------------------------------------------*/


#define CHK_REAL_RANGE(chk_val, min, max, err)             \
if (chk_real_range(thisPtr, chk_val, min, max))            \
   {                                                       \
    thisPtr->errNumber = err;                              \
    return err;                                            \
   }


     /*----------------------------------------------------------------*
      |  MACRO CHK_INT_RANGE                                           |
      |    Incorporates integer range checking and error checking.     |
      |    Refer to chk_int_range function for more info.              |
      *----------------------------------------------------------------*/


#define CHK_INT_RANGE(chk_val, min, max, err)              \
if (chk_int_range(thisPtr, chk_val, min, max) )            \
   {                                                       \
    thisPtr->errNumber = err;                              \
    return err;                                            \
   }


     /*----------------------------------------------------------------*
      |  MACRO CHK_LONG_RANGE                                          |
      |    Incorporates long checking and error checking.  Refer to    |
      |    chk_long_range function for more info.                      |
      *----------------------------------------------------------------*/


#define CHK_LONG_RANGE(chk_val, min, max, err)             \
if (chk_long_range(thisPtr, chk_val, min, max))            \
   {                                                       \
    thisPtr->errNumber = err;                              \
    return err;                                            \
   }


     /*----------------------------------------------------------------*
      |  MACRO CHK_ENUM                                                |
      |    Incorporates enumeration checking and error checking.       |
      |    Refer to chk_enum function for more info.                   |
      *----------------------------------------------------------------*/


#define CHK_ENUM( chk_val, lowerlimit, upperlimit, err )    \
if (chk_enum(thisPtr, chk_val, lowerlimit, upperlimit) )    \
   {                                                        \
    thisPtr->errNumber = err;                               \
    return err;                                             \
   }

#define VERIFY_APP(app_num) \
errStatus = VerifyApp(instrumentHandle, app_num); \
if (errStatus < VI_SUCCESS) return errStatus;


    

/*****************************************************************************/
/*  DELAY Functions                                                          */
/*  setDelay (located prior to init function) sets the delay time for the    */
/*    instrument.                                                            */
/*  doDelay uses delay time to slow down the driver after a read request.    */
/*---------------------------------------------------------------------------*/
/*  In some SCPI instruments, the instrument cannot change its state to      */
/*    'processing a read request' fast enough to keep another request        */
/*    from getting through to the instrument.  By setting a short delay      */
/*    (less than 100 microseconds should be sufficient) after each read,     */
/*    the driver will wait a sufficient amount of time before attempting     */
/*    to send the next string to the instrument.                             */
/*  DO NOT document these function in the fp file or the help file.  They    */
/*    are intended to address problems in specific instruments, problems     */
/*    that may only appear on faster CPU's.  They are designed so that the   */
/*    problem can be addressed quickly in the field once it is identified.   */
/*  If the problem is identified by driver developers, a 100 ms delay        */
/*    should be set in the hpesa_init function.  The template version of     */
/*    init currently sets the delay to 0.                                    */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  doDelay -                                                                */
/*                                                                           */
/*  Delays execution for a specified number of microseconds.                 */
/*  Platform   Code    Tick Resolution  Tick Increment  Call Overhead        */
/*   WIN32     32-bit  CPU dependent    CPU dependent   0-20 us              */
/*   HP-UX     32-bit  1 us             CPU dependent   0-20 us              */
/*  PARAMETERS                                                               */
/*    long           delayTime (in)                                          */
/*      The number of micro-seconds to delay before proceeding.              */
/*---------------------------------------------------------------------------*/

static void doDelay(ViInt32 delayTime)
{
    long   ticksToCount;

        /*-----------------------------------------------------------*
         |  WIN32 Version                                            |
         |  WIN32 increments depend on the hardware.  If high-       |
         |    frequency counting isn't supported, revert to common   |
         |    standard functions (same as WIN16).                    |
         |  The call overhead to execute doDelay if high-frequency   |
         |    is supported is about 25-30 micro-seconds.             |
         |  The call overhead to execute doDelay if high-frequency   |
         |    is -NOT- supported is ~10 milli-seconds on             |
         |    Windows 95 & NT.                                       |
         *-----------------------------------------------------------*/

#ifdef WIN32

#ifdef _CVI_
#else
    __int64  ticksPerSecond;
    __int64  startTicks;
    __int64  nowTicks;
#endif /* _CVI_ */

    DWORD    msTicks;

    if (delayTime == 0)
        return;

#ifndef _CVI_
    if (QueryPerformanceFrequency((LARGE_INTEGER *)&ticksPerSecond))
    {
        ticksToCount = (long)((ticksPerSecond/1E6)*delayTime) + 1;
        QueryPerformanceCounter((LARGE_INTEGER *)&nowTicks);
        startTicks = nowTicks;
        while (nowTicks - startTicks < (DWORD)ticksToCount)
            QueryPerformanceCounter((LARGE_INTEGER *)&nowTicks);
    }
#endif /* _CVI_ */

    {
        ticksToCount = (long)((1E3/1E6)*delayTime) + 1;
        msTicks = GetTickCount();
        while (GetTickCount() - msTicks < (DWORD)ticksToCount) ;
    }

#endif /* WIN32 */

        /*-----------------------------------------------------------*
         |  HP-UX Version                                            |
         |  HP-UX counts in 1 micro-second increments.               |
         |  The call overhead to execute doDelay on HP-UX is about   |
         |    15-20 micro-seconds.                                   |
         *-----------------------------------------------------------*/

#ifdef __hpux

    struct timeval t0, t1;

    if (delayTime == 0)
        return;

    /* printf("doDelay delaying %ld\n", ticks);  */ 
    gettimeofday(&t0, NULL);
    t0.tv_usec += delayTime;
    t0.tv_sec += t0.tv_usec / 1000000;
    t0.tv_usec = t0.tv_usec % 1000000;

    gettimeofday(&t1, NULL);
    while (t1.tv_sec < t0.tv_sec)
        gettimeofday(&t1, NULL);

    if (t1.tv_sec > t0.tv_sec) return; /* get out quick if past delay time */

    while (t1.tv_usec < t0.tv_usec)
        gettimeofday(&t1, NULL);

#endif /* __hpux */

    return;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end doDelay                                  */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*    delayVScanf -                                                          */
/*     Same as viVScanf, but with a delay added if necessary.                */
/*                                                                           */
/*  PARAMETERS (same as viVScanf)                                            */
/*    ViSession   instrumentHandle (in)                                      */
/*    ViString    scanFmt (in)                                               */
/*    ...                                                                    */
/*---------------------------------------------------------------------------*/

static ViStatus delayVScanf(ViSession instrumentHandle, ViString scanFmt, ... )

{
    ViStatus  errStatus;
    va_list   va;
    struct hpesa_globals *thisPtr;

    errStatus = viGetAttribute(instrumentHandle, 
                                    VI_ATTR_USER_DATA, (ViAddr) &thisPtr);
    
    if (errStatus < VI_SUCCESS)
        return errStatus;

    va_start(va, scanFmt);
    errStatus = viVScanf(instrumentHandle, scanFmt, va);
    va_end(va);

    if (thisPtr->dTime > 0)
        doDelay(thisPtr->dTime);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end delayVScanf                              */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  delayVPrintf -                                                           */
/*    Same as viVPrintf, but with a delay added if necessary.                */
/*                                                                           */
/*  PARAMETERS (same as viVPrintf)                                           */
/*    ViSession   instrumentHandle (in)                                      */
/*    ViString    printFmt (in)                                              */
/*    ...                                                                    */
/*---------------------------------------------------------------------------*/

static ViStatus delayVPrintf(ViSession instrumentHandle, ViString printFmt,...)

{
    ViStatus  errStatus;
    va_list   va;
    struct hpesa_globals *thisPtr;

    errStatus = viGetAttribute(instrumentHandle, 
                                        VI_ATTR_USER_DATA, (ViAddr) &thisPtr);
    
    if (errStatus < VI_SUCCESS)
        return errStatus;

    va_start(va, printFmt);
    errStatus = viVPrintf(instrumentHandle, printFmt, va);
    va_end(va);

    if (thisPtr->dTime > 0)
        doDelay(thisPtr->dTime);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end delayVPrintf                             */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  delayVQueryf -                                                           */
/*    Same as viVQueryf, but with a delay added if necessary.                */
/*                                                                           */
/*  PARAMETERS (same as viVQueryf)                                           */
/*    ViSession   instrumentHandle (in)                                      */
/*    ViString    printFmt (in)                                              */
/*    ViString    scanFmt (in)                                               */
/*    ...                                                                    */
/*---------------------------------------------------------------------------*/

static ViStatus delayVQueryf(ViSession instrumentHandle, 
                             ViString printFmt, 
                             ViString scanFmt, 
                             ...) 

{
    ViStatus  errStatus;
    va_list   va;
    struct hpesa_globals *thisPtr;

    errStatus = viGetAttribute(instrumentHandle, 
                                        VI_ATTR_USER_DATA,(ViAddr) &thisPtr);

    if (errStatus < VI_SUCCESS)
        return errStatus;

    va_start(va, scanFmt);
    errStatus = viVQueryf(instrumentHandle, printFmt, scanFmt, va);
    va_end(va);

    if (thisPtr->dTime > 0)
        doDelay(thisPtr->dTime);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end delayVQueryf                             */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  delayRead                                                                */
/*  Same as viRead, but with a delay added if necessary.                     */
/*                                                                           */
/*  PARAMETERS (same as viRead)                                              */
/*    ViSession   instrumentHandle (in)                                      */
/*    ViPBuf      buf (in/out)                                               */
/*    ViUInt32    cnt (in)                                                   */
/*    ViPUInt32   retCnt (in)                                                */
/*---------------------------------------------------------------------------*/

static ViStatus delayRead(ViSession  instrumentHandle,
                          ViPBuf     buf,
                          ViUInt32   cnt,
                          ViPUInt32  retCnt) 

{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
   
    errStatus = viGetAttribute(instrumentHandle, 
                                        VI_ATTR_USER_DATA,(ViAddr) &thisPtr);
    if (errStatus < VI_SUCCESS)
    return errStatus;

    errStatus = viRead(instrumentHandle, buf, cnt, retCnt);

    if (thisPtr->dTime > 0)
        doDelay(thisPtr->dTime);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end delayRead                                */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  statusUpdate -                                                           */
/*    Updates the global variable and queries the instrument's status byte   */
/*    for errors.                                                            */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession              instrumentHandle (in)                           */
/*    struct hpesa_globals *thisPtr (in)                                     */
/*      A pointer to the VISA globals for this VISA session                  */
/*    ViStatus               s (in)                                          */
/*      A driver error return code.                                          */
/*---------------------------------------------------------------------------*/

static ViStatus statusUpdate(ViSession  instrumentHandle,
                             struct     hpesa_globals *thisPtr,
                             ViStatus   s ) 

{   
    ViStatus  errStatus;
    ViInt16   eventQ;

    if (thisPtr)
        thisPtr->errNumber = s;

         /*---------------------------------------------------------*
          | If error query detect is set on and the instrument      |
          |   has not timed out, then ...                           |
          | Read the status byte into eventQ and check the error    |
          |   bytes.                                                |
          | Potential status byte errors are 0x04 (Query Error),    |
          |   0x08 (Device Dependent Error), 0x10 (Execution Error),|
          |   and 0x20 (Command Error).                             |
          *---------------------------------------------------------*/

    if ((thisPtr) && (thisPtr->errQueryDetect) && (s != VI_ERROR_TMO))
    {   
        
        errStatus = delayVQueryf(instrumentHandle, "*ESR?\n", "%hd%*t",&eventQ);
        
        if (errStatus < VI_SUCCESS)
            return VI_ERROR_SYSTEM_ERROR;

        if( (0x04  | 0x08  | 0x10  | 0x20) & eventQ )
            return hpesa_INSTR_ERROR_DETECTED;
    }

    return s;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end statusUpdate                             */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  chk_null_pointer -                                                       */
/*    Checks for valid pointer values.  Instead of calling this function     */
/*    directly, use the CHK_NULL_POINTER macro, which incorporates error     */
/*    checking                                                               */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    struct hpesa_globals *thisPtr (in)                                     */
/*      A pointer to the VISA globals for this VISA session                  */
/*    void                 *ptr (in)                                         */
/*      Check this value to make sure it is not NULL.                        */
/*---------------------------------------------------------------------------*/

static ViBoolean chk_null_pointer(struct hpesa_globals *thisPtr, void *ptr)
{

    if (!ptr)
    {
        strcpy(thisPtr->errMessage, INSTR_ERROR_NULL_PTR_MSG);
        return VI_TRUE;
    }

    return VI_FALSE;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                            end chk_null_pointer                           */
/*                                                                           */
/*****************************************************************************/




/*****************************************************************************/
/*  chk_boolean -                                                            */
/*    Checks for valid boolean values.  Instead of calling this function     */
/*    directly, use the CHK_BOOLEAN macro, which incorporates error checking */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    struct hpesa_globals *thisPtr (in)                                     */
/*      A pointer to the VISA globals for this VISA session                  */
/*    ViBoolean              chk_val (in)                                    */
/*      Check this value to make sure it is a legal Boolean.                 */
/*---------------------------------------------------------------------------*/

static ViBoolean chk_boolean(struct hpesa_globals *thisPtr, ViBoolean chk_val)
{
    ViChar message[hpesa_ERR_MSG_LENGTH];

    if ( (chk_val != VI_TRUE) && (chk_val != VI_FALSE) )
    {
        sprintf(message, hpesa_MSG_BOOLEAN, chk_val);    
        strcpy(thisPtr->errMessage, message);                
        return VI_TRUE;
    }

    return VI_FALSE;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end chk_boolean                              */
/*                                                                           */
/*****************************************************************************/




/*****************************************************************************/
/*  chk_real_range -                                                         */
/*    Tests to see if a ViReal64 is in range.  Instead of calling this       */
/*    function directly, use the CHK_REAL_RANGE macro, which incorporates    */
/*    error checking.                                                        */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    struct hpesa_globals *thisPtr (in)                                     */
/*      A pointer to the VISA globals for this VISA session                  */
/*    ViReal64             chk_val (in)                                      */
/*      The value to be checked.                                             */
/*    ViReal64             min (in)                                          */
/*      The bottom of the range.                                             */
/*    ViReal64             max (in)                                          */
/*      The top of the range.                                                */
/*---------------------------------------------------------------------------*/

static ViBoolean chk_real_range(struct    hpesa_globals *thisPtr,
                                ViReal64  chk_val,
                                ViReal64  min,
                                ViReal64  max)

{
    ViChar message[hpesa_ERR_MSG_LENGTH];

    if ( (chk_val < min) || (chk_val > max) )              
    {                                
        sprintf(message, hpesa_MSG_REAL, min, max, chk_val);    
        strcpy(thisPtr->errMessage, message);
        return VI_TRUE;
    }

    return VI_FALSE;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end chk_real_range                           */
/*                                                                           */
/*****************************************************************************/

  

/*****************************************************************************/
/*  chk_int_range -                                                          */
/*    Tests to see if a ViInt16 is in range.  Instead of refering to this    */
/*    function directly, use the CHK_INT_RANGE macro, which incorporates     */
/*    error checking.                                                        */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    struct hpesa_globals *thisPtr (in)                                     */
/*      A pointer to the VISA globals for this VISA session                  */
/*    ViInt16              chk_val (in)                                      */
/*      The value to be checked.                                             */
/*    ViInt16              min (in)                                          */
/*      The bottom of the range.                                             */
/*    ViInt16              max (in)                                          */
/*      The top of the range.                                                */
/*---------------------------------------------------------------------------*/

static ViBoolean chk_int_range(struct hpesa_globals *thisPtr,
                               ViInt16  chk_val,
                               ViInt16  min,
                               ViInt16  max)

{
    ViChar message[hpesa_ERR_MSG_LENGTH];

    if ( (chk_val < min) || (chk_val > max) )              
    {                                
        sprintf(message, hpesa_MSG_INT, min, max, chk_val);    
        strcpy(thisPtr->errMessage, message);
        return VI_TRUE;
    }

    return VI_FALSE;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end chk_int_range                            */
/*                                                                           */
/*****************************************************************************/
  
   

/*****************************************************************************/
/*  chk_long_range -                                                         */
/*    Tests to see if a ViInt32 is in range.  Instead of calling this        */
/*    directly, use the CHK_LONG_RANGE macro, which incorporates error       */
/*    checking.                                                              */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    struct hpesa_globals *thisPtr (in)                                     */
/*      A pointer to the VISA globals for this VISA session                  */
/*    ViInt32              chk_val (in)                                      */
/*      The value to be checked.                                             */
/*    ViInt32              min (in)                                          */
/*      The bottom of the range.                                             */
/*    ViInt32              max (in)                                          */
/*      The top of the range.                                                */
/*---------------------------------------------------------------------------*/


static ViBoolean chk_long_range(struct  hpesa_globals *thisPtr,
                                ViInt32 chk_val,
                                ViInt32 min,
                                ViInt32 max)

{
    ViChar message[hpesa_ERR_MSG_LENGTH];

    if ( (chk_val < min) || (chk_val > max) )              
    {                                
        sprintf(message, hpesa_MSG_LONG, min, max, chk_val);    
        strcpy(thisPtr->errMessage, message);
        return VI_TRUE;
    }

    return VI_FALSE;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end chk_long_range                           */
/*                                                                           */
/*****************************************************************************/
  
   

/*****************************************************************************/
/*  chk_enum -                                                               */
/*    Searches for a string in an array of strings.  Instead of calling this */
/*    function directly, use the CHK_ENUM macro, which incorporates error    */
/*    checking.                                                              */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    struct hpesa_globals *thisPtr (in)                                     */
/*      A pointer to the VISA globals for this VISA session                  */
/*    ViInt16              chk_val (in)                                      */
/*      The value to be checked.                                             */
/*    ViInt16              lowerlimit (in)                                   */
/*      The lower limit of the enumeration values.                           */
/*      In most cases this will be 0; however, currently marker              */
/*      and tracers enumerations start with one.                             */
/*    ViInt16              upperlimit (in)                                   */
/*      The upper limit of the enumeration values.                           */
/*      Except in certain exceptions, this value should always               */
/*      be referenced by the "LASTENUM" value of the enumurations.           */
/*---------------------------------------------------------------------------*/

static ViBoolean chk_enum (struct hpesa_globals *thisPtr, 
                           ViInt16 chk_val, 
                           ViInt16 lowerlimit, 
                           ViInt16 upperlimit)

{
    ViChar message[hpesa_ERR_MSG_LENGTH];

    if ( ( chk_val < lowerlimit ) || (chk_val >= upperlimit ) )
    {                                
        sprintf(message, hpesa_MSG_INT, lowerlimit, (upperlimit-1), chk_val);    
        strcpy(thisPtr->errMessage, message);
        return VI_TRUE;
    }

    return VI_FALSE;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end chk_enum                                 */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  setDelay -                                                               */
/*    Sets the delay time in microseconds, after checking for valid values.  */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession  instrumentHandle (in)                                       */
/*      Instrument Handle returned from hpesa_init()                         */
/*    ViInt32    delayTime (in)                                              */
/*      The delayTime in microseconds.  Must be between 0 and 1,000.  In     */
/*      practice, should never be set higher than 100.                       */
/*---------------------------------------------------------------------------*/

static ViStatus _VI_FUNC setDelay (ViSession instrumentHandle, 
                                   ViInt32 delayTime)

{
    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_LONG_RANGE(delayTime, 0L, 1000L, VI_ERROR_PARAMETER2);

    thisPtr->dTime = delayTime;

    thisPtr->errNumber = VI_SUCCESS;
    return VI_SUCCESS;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end setDelay                                 */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  initError -                                                              */
/*    This function is only called from hpesa_init and closes the session    */
/*    should there be an error upon initialization.                          */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession      vi (in)                                                 */
/*      Instrument Handle returned by viOpen.                                */
/*    ViSession      defRM (in)                                              */
/*      Resource Manager handle from viOpen.                                 */
/*    ViStatus       errStatus (in)                                          */
/*      A driver error return code.                                          */
/*---------------------------------------------------------------------------*/

static ViStatus _VI_FUNC initError(ViPSession vi, 
                                   ViSession defRM, 
                                   ViStatus errStatus)

{
    viClose(*vi);
    viClose(defRM);
    *vi=VI_NULL;
    return errStatus;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end initError                                */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  InvalidInstrumentID-                                                     */
/*    This function is only called from hpesa_init and checks the returned   */
/*    instrument identification string against valid #defined values.        */
/*    Note that since this function is testing for an INVALID value,         */
/*    cases where the ID matches will return false.                          */
/*                                                                           */
/*  PARAMETERS                                                               */
/*     ViChar idn_buf[] - (in)                                               */
/*        The results of the IDN? query, stored in the global structure.     */
/*---------------------------------------------------------------------------*/

static ViBoolean InvalidInstrumentID(ViChar idn_buf[])
{
    if ((strncmp(idn_buf, hpesa_IDN_STRING_E4401B, 
                 strlen(hpesa_IDN_STRING_E4401B)) == 0))
    {
        return VI_FALSE;
    }
    else if ((strncmp(idn_buf, hpesa_IDN_STRING_E4402B, 
              strlen(hpesa_IDN_STRING_E4402B)) == 0))
    {
        return VI_FALSE;
    }
    else if ((strncmp(idn_buf, hpesa_IDN_STRING_E4403B, 
              strlen(hpesa_IDN_STRING_E4403B)) == 0))
    {
        return VI_FALSE;
    }
    else if ((strncmp(idn_buf, hpesa_IDN_STRING_E4404B, 
              strlen(hpesa_IDN_STRING_E4404B)) == 0))
    {
        return VI_FALSE;
    }
    else if ((strncmp(idn_buf, hpesa_IDN_STRING_E4405B, 
              strlen(hpesa_IDN_STRING_E4405B)) == 0))
    {
        return VI_FALSE;
    }
    else if ((strncmp(idn_buf, hpesa_IDN_STRING_E4407B, 
              strlen(hpesa_IDN_STRING_E4407B)) == 0))
    {
        return VI_FALSE;
    }
    else if ((strncmp(idn_buf, hpesa_IDN_STRING_E4408B, 
              strlen(hpesa_IDN_STRING_E4408B)) == 0))
    {
        return VI_FALSE;
    }
    else if ((strncmp(idn_buf, hpesa_IDN_STRING_E4411B, 
              strlen(hpesa_IDN_STRING_E4411B)) == 0))
    {
        return VI_FALSE;
    }
    else
        return VI_TRUE;  /* not a valid model IDN */
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                         end InvalidInstrumentID                           */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  GetCommaArray -                                                          */
/*    NOTE:  THIS FUNCITON HAS BEEN REPLACED BY THE                          */
/*           hpesa_cmdRealCommaArray_Q FUNCTION.  USE IT INSTEAD.            */
/*                                                                           */
/*    This function retrieves an array of comma separated values from the    */
/*    instrument.  It assumes that the proper SCPI command has already       */
/*    been sent and that the data is waiting to be retrieved from the        */
/*    instrument.                                                            */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession      instrumentHandle                                        */
/*      Instrument Handle returned from hpesa_init()                         */
/*    ViReal64       *Array                                                  */
/*      The array of values returned by this function.                       */
/*    ViInt32        ArraySize                                               */
/*      The size of the allocated array passed in.                           */
/*    ViInt32        *ValuesRead                                             */
/*      The actual number of values retrieved from the instrument.           */
/*---------------------------------------------------------------------------*/

static ViStatus GetCommaArray(ViSession instrumentHandle,
                              ViReal64 *Array,
                              ViInt32 ArraySize,
                              ViInt32 *ValuesRead)
{
    ViChar TestChar, Number[17], *tmptr;
    ViInt32 dummy;
    ViStatus errStatus = VI_SUCCESS;

    *ValuesRead = 0;

        /*-----------------------------------------------------------*
         | The main loop.  This loop reads the next character from   |
         | the instrument and based on what that character is, take  |
         | the appropriate action.                                   |
         *-----------------------------------------------------------*/


    while(1)
    {
        errStatus = viRead(instrumentHandle, &TestChar, 1, &dummy);
        if(errStatus < VI_SUCCESS)
            return errStatus;

        /*-----------------------------------------------------------*
         | If it's a '\n' and the error status is zero, then no more |
         | data is waiting on the instrument.                        |
         |                                                           |
         | If the error status is not zero and the character is a    |
         | '\n', then the \n is extraneous and is ignored.           |
         *-----------------------------------------------------------*/

        if(TestChar == '\n' && errStatus == 0) break;
        else if (TestChar == '\n') continue;
        else
        {

        /*-----------------------------------------------------------*
         | If it's a comma, then the next 16 characters represent    |
         | the next number.                                          |
         *-----------------------------------------------------------*/
           
            if(TestChar == ',')
            {
                errStatus = viRead(instrumentHandle, Number, 16, &dummy);
                if(errStatus < VI_SUCCESS)
                    return errStatus;
            }

        /*-----------------------------------------------------------*
         | Otherwise, it's the first value in the array.  The sign   |
         | is placed, along with the following numbers into the      |
         | array.                                                    |
         *-----------------------------------------------------------*/

            else
            {
                Number[0] = TestChar;
                errStatus = viRead(instrumentHandle, &Number[1], 15, &dummy);
                if(errStatus < VI_SUCCESS)
                    return errStatus;
            }

            Number[16] = '\0';

        /*-----------------------------------------------------------*
         |  If the there is still room in the array passed in,       |
         |  translate the character array into a number.  Increment  |
         |  the count by one.                                        |
         *-----------------------------------------------------------*/

            if(*ValuesRead < ArraySize)
            {
                Array[*ValuesRead] = strtod(Number, &tmptr);
                if(errno == ERANGE)
                    return hpesa_INSTR_INV_ASCII_NUMBER;
            }

            *ValuesRead += 1;

        }

    }

    return VI_SUCCESS;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                         end GetCommaArray                                 */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  GenMeasureTrace -                                                        */
/*    This function is a generic measurement function, measuring the         */
/*    specified trace and type.                                              */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession instrumentHandle                                             */
/*      Instrument Handle returned by viOpen.                                */
/*                                                                           */
/*    ViInt16 MeasModeType                                                   */
/*      The type of measurement to make.                                     */
/*          hpesa_APPLICATION_MODE_CHP - Channel power measurement           */
/*          hpesa_APPLICATION_MODE_RHO - Modulation accuracy measurement     */
/*          hpesa_APPLICATION_MODE_CDP - Code domain power measurement       */
/*          hpesa_APPLICATION_MODE_CSP - Close spurs power measurement       */
/*          hpesa_APPLICATION_MODE_SHP - Spurs at harmonic power measurement */
/*                                                                           */
/*    ViReal64 TraceTimeout                                                  */
/*      Temporarily sets the VISA timeout to a value to measure the trace.   */
/*                                                                           */
/*    ViInt16 TraceType                                                      */
/*      Determines the trace type.                                           */
/*        hpesa_MEASURE                                                      */
/*        hpesa_READ                                                         */
/*        hpesa_FETCH                                                        */
/*                                                                           */
/*    ViInt16 ResultsType                                                    */
/*      Determines the values returned in Data Results                       */
/*                                                                           */
/*    ViAReal64 DataResults                                                  */
/*      An array returning the trace values as determined ResultsType.       */
/*                                                                           */
/*    ViInt32 ResultsMaxSize                                                 */
/*      The allocated size of the DataResults array.                         */
/*                                                                           */
/*    ViPInt32 ResultsReturnedSize                                           */
/*      The actual number of values returned in the DataResults array.       */
/*                                                                           */
/*---------------------------------------------------------------------------*/

static ViStatus _VI_FUNC GenMeasureTrace
                        (ViSession instrumentHandle,
                         ViInt16 MeasModeType,
                         ViReal64 TraceTimeout,
                         ViInt16 TraceType,
                         ViInt16 ResultsType,
                         ViAReal64 DataResults,
                         ViInt32 ResultsMaxSize,
                         ViPInt32 ResultsReturnedSize)
{
    ViStatus errStatus = VI_SUCCESS;
    char cmdString[128] = "\0";
    long previousTimeout = 0, timeout = (long)(TraceTimeout * 1000);
    struct hpesa_globals *thisPtr;
    ViChar OldFormat[32] = "\0";
    ViChar buffer[64] = "\0";
    ViInt32 tempCount = 0;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // Save the current timeout value.
    viGetAttribute(instrumentHandle,VI_ATTR_TMO_VALUE,&previousTimeout);

    // Set the user specified timeout value.
    viSetAttribute(instrumentHandle,VI_ATTR_TMO_VALUE,timeout);

    // First, set the application mode string and results type
    switch(MeasModeType)
    {
        case hpesa_APPLICATION_MODE_CHP:
            sprintf(buffer,"CHP%d?", ResultsType);
            break;
        case hpesa_APPLICATION_MODE_RHO:
            sprintf(buffer,"RHO%d?", ResultsType);
            break;
        case hpesa_APPLICATION_MODE_CDP:
            sprintf(buffer,"CDP%d?", ResultsType);
            break;
        case hpesa_APPLICATION_MODE_CSP:
            sprintf(buffer,"CSP%d?", ResultsType);
            break;
        case hpesa_APPLICATION_MODE_SHP:
            sprintf(buffer,"HARM%d?", ResultsType);
            break;
		case hpesa_APPLICATION_MODE_TXP:
            sprintf(buffer,"TXP%d?", ResultsType);
            break;
		case hpesa_APPLICATION_MODE_PVT:
            sprintf(buffer,"PVT%d?", ResultsType);
            break;
		case hpesa_APPLICATION_MODE_PFER:
            sprintf(buffer,"PFER%d?", ResultsType);
            break;
		case hpesa_APPLICATION_MODE_ORFS:
            sprintf(buffer,"ORFS%d?", ResultsType);
            break;
		case hpesa_APPLICATION_MODE_TSP:
            sprintf(buffer,"TSP%d?", ResultsType);
            break;
		default:
            fprintf(stderr,"Logic error in GenMeasureTrace.");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    // next, combine it with the measurement trace type
    switch(TraceType)
    {
        case hpesa_MEASURE:
            sprintf(cmdString, "MEAS:%s", buffer);
            break;
        case hpesa_READ:
            sprintf(cmdString, "READ:%s", buffer);
            break;
        case hpesa_FETCH:
            sprintf(cmdString, "FETCH:%s", buffer);
            break;
        default:
            fprintf(stderr, "Logic error in GenMeasureTrace.");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmdRealCommaArray_Q(instrumentHandle,
                                          cmdString,
                                          ResultsMaxSize,
                                          DataResults,
                                          ResultsReturnedSize);
    if(errStatus < VI_SUCCESS) return errStatus;

    // Restore the previous timeout value.
    viSetAttribute(instrumentHandle,VI_ATTR_TMO_VALUE,previousTimeout);

    return errStatus;
}


/*---------------------------------------------------------------------------*/
/*                          end GenMeasureTrace                              */
/*****************************************************************************/


/*****************************************************************************/
/*  GenSetAveraging -                                                        */
/*    This function is a generic function to set measurement averaging       */
/*    parameters, depending on the measurement type.                         */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession instrumentHandle                                             */
/*      Instrument Handle returned by viOpen.                                */
/*                                                                           */
/*    ViInt16 MeasModeType                                                   */
/*      The type of measurement to make.                                     */
/*          hpesa_APPLICATION_MODE_CHP - Channel power measurement           */
/*          hpesa_APPLICATION_MODE_RHO - Modulation accuracy measurement     */
/*          hpesa_APPLICATION_MODE_CDP - Code domain power measurement       */
/*          hpesa_APPLICATION_MODE_CSP - Close spurs power measurement       */
/*          hpesa_APPLICATION_MODE_SHP - Spurs at harmonic power measurement */
/*                                                                           */
/*    ViInt32 AverageCount                                                   */
/*      Sets the number of data aquisitions that will be averaged.           */
/*                                                                           */
/*    ViBoolean AverageState                                                 */
/*      Sets the state of averaging, either on or off.                       */
/*          VI_TRUE = Averaging on.                                          */
/*          VI_FALSE = Averaging off.                                        */
/*                                                                           */
/*    ViInt16 AverageMode                                                    */
/*      Selects the type of terminal control for averaging.                  */
/*          hpesa_AVERAGE_EXPONENTIAL - Sets exponential averaging           */
/*          hpesa_AVERAGE_REPEAT - Sets repeat averaging                     */                                       
/*                                                                           */
/*---------------------------------------------------------------------------*/

static ViStatus _VI_FUNC GenSetAveraging
                        (ViSession instrumentHandle, 
                         ViInt16 MeasModeType,
                         ViInt32 AverageCount,
                         ViBoolean AverageState,
                         ViInt16 AverageMode)
{
    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    ViChar buffer[64] = "\0";
    ViChar cmdString[128] = "\0";

    GET_GLOBALS(instrumentHandle, thisPtr)

    // First, set the application mode string
    switch(MeasModeType)
    {
        case hpesa_APPLICATION_MODE_CHP:
            sprintf(buffer,"CHP:AVER");
            break;
        case hpesa_APPLICATION_MODE_RHO:
            sprintf(buffer,"RHO:AVER");
            break;
        case hpesa_APPLICATION_MODE_CDP:
            sprintf(buffer,"CDP:AVER");
            break;
        case hpesa_APPLICATION_MODE_CSP:
            sprintf(buffer,"CSP:AVER");
            break;
        case hpesa_APPLICATION_MODE_SHP:
            sprintf(buffer,"HARM:AVER");
            break;
		case hpesa_APPLICATION_MODE_TXP:
            sprintf(buffer,":TXP:AVER");
            break;
		case hpesa_APPLICATION_MODE_PVT:
            sprintf(buffer,":PVT:AVER");
            break;
		case hpesa_APPLICATION_MODE_PFER:
            sprintf(buffer,":PFER:AVER");
            break;
		case hpesa_APPLICATION_MODE_ORFS:
            sprintf(buffer,":ORFS:AVER");
            break;
		case hpesa_APPLICATION_MODE_TSP:
            sprintf(buffer,":TSP:AVER");
            break;
		default:
            fprintf(stderr,"Logic error in GenSetAveraging.");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    // Execute the averaging count
    sprintf(cmdString, "%s:COUN", buffer);
    errStatus = hpesa_cmdInt(instrumentHandle, cmdString, AverageCount);
    if (errStatus < VI_SUCCESS) return errStatus;

    // Execute the averaging state
    switch(AverageState)
    {
        case VI_TRUE:
            sprintf(cmdString, "%s 1", buffer);
            break;
        case VI_FALSE:
            sprintf(cmdString, "%s 0", buffer);
            break;
        default:
            fprintf(stderr,"Logic error in GenSetAveraging.");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, cmdString);
    if (errStatus < VI_SUCCESS) return errStatus;

    // Execute the averaging mode
    switch(AverageMode)
    {
        case hpesa_AVERAGE_EXPONENTIAL:
            sprintf(cmdString, "%s:TCON EXP", buffer);
            break;
        case hpesa_AVERAGE_REPEAT:
            sprintf(cmdString, "%s:TCON REP", buffer);
            break;
        default:
            fprintf(stderr,"Logic error in GenSetAveraging.");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, cmdString);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                            end GenSetAveraging                            */
/*****************************************************************************/



/*****************************************************************************/
/*  GenGetAveraging -                                                        */
/*    This function is a generic function to retrieve measurement averaging  */
/*    parameters, depending on the measurement type.                         */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession instrumentHandle                                             */
/*      Instrument Handle returned by viOpen.                                */
/*                                                                           */
/*    ViInt16 MeasModeType                                                   */
/*      The type of measurement to make.                                     */
/*          hpesa_APPLICATION_MODE_CHP - Channel power measurement           */
/*          hpesa_APPLICATION_MODE_RHO - Modulation accuracy measurement     */
/*          hpesa_APPLICATION_MODE_CDP - Code domain power measurement       */
/*          hpesa_APPLICATION_MODE_CSP - Close spurs power measurement       */
/*          hpesa_APPLICATION_MODE_SHP - Spurs at harmonic power measurement */
/*                                                                           */
/*---------------------------------------------------------------------------*/

static ViStatus _VI_FUNC GenGetAveraging
                        (ViSession instrumentHandle, 
                         ViInt16 MeasModeType,
                         ViPInt32 AverageCountQuery,
                         ViPBoolean AverageStateQuery,
                         ViPInt16 AverageModeQuery)
                         

{
    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    ViChar buffer[64] = "\0";
    ViChar cmdString[128] = "\0";

    GET_GLOBALS(instrumentHandle, thisPtr)

    // First, set the application mode string
    switch(MeasModeType)
    {
        case hpesa_APPLICATION_MODE_CHP:
            sprintf(buffer,"CHP:AVER");
            break;
        case hpesa_APPLICATION_MODE_RHO:
            sprintf(buffer,"RHO:AVER");
            break;
        case hpesa_APPLICATION_MODE_CDP:
            sprintf(buffer,"CDP:AVER");
            break;
        case hpesa_APPLICATION_MODE_CSP:
            sprintf(buffer,"CSP:AVER");
            break;
        case hpesa_APPLICATION_MODE_SHP:
            sprintf(buffer,"HARM:AVER");
            break;
		case hpesa_APPLICATION_MODE_TXP:
            sprintf(buffer,":TXP:AVER");
            break;
		case hpesa_APPLICATION_MODE_PVT:
            sprintf(buffer,":PVT:AVER");
            break;
		case hpesa_APPLICATION_MODE_PFER:
            sprintf(buffer,":PFER:AVER");
            break;
		case hpesa_APPLICATION_MODE_ORFS:
            sprintf(buffer,":ORFS:AVER");
            break;
		case hpesa_APPLICATION_MODE_TSP:
            sprintf(buffer,":TSP:AVER");
            break;
		default:
            fprintf(stderr,"Logic error in GenSetAveraging.");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    // Retrieve the averaging count
    sprintf(cmdString, "%s:COUN?", buffer);
    errStatus = hpesa_cmdInt32_Q(instrumentHandle, cmdString, AverageCountQuery);
    if (errStatus < VI_SUCCESS) return errStatus;

    // Retrieve the averaging state
    sprintf(cmdString, "%s?", buffer);
    errStatus = hpesa_cmdInt16_Q(instrumentHandle, cmdString, AverageStateQuery);
    if (errStatus < VI_SUCCESS) return errStatus;

    // Retrieve the averaging mode
    sprintf(cmdString, "%s:TCON?", buffer);
    errStatus = hpesa_cmdString_Q(instrumentHandle, cmdString, 64, buffer);
    if (errStatus < VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0'; // remove the \n

    if(!strcmp(buffer, "EXP"))
        *AverageModeQuery = hpesa_AVERAGE_EXPONENTIAL;
    else if(!strcmp(buffer, "REP"))
        *AverageModeQuery = hpesa_AVERAGE_REPEAT;
    else
        return hpesa_INSTR_ERROR_UNEXPECTED;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                            end GenGetAveraging                            */
/*****************************************************************************/



/*****************************************************************************/
/*  VerifyApp-                                                               */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession instrumentHandle                                             */
/*      Instrument Handle returned by viOpen.                                */
/*                                                                           */
/*    ViInt16 AppNumber                                                      */
/*      The application enumeration that the instrument needs to be in in    */
/*      order to run the funciton.                                           */
/*         hpesa_APPLICATION_SA - Spectrum analyzer                          */
/*         hpesa_APPLICATION_CDMA - CDMA One                                 */
/*         hpesa_APPLICATION_GSM - GSM                                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/

static ViStatus _VI_FUNC VerifyApp(ViSession instrumentHandle,
                                   ViInt16 AppNumber)

{
    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    char buffer[32] = "\0";
    char *AppStrings[3] = {"\"SA\"", "\"CDMA\"", "\"GSM\""};

    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application mode only if instructed
    if(thisPtr->verifyApp)
    {
        // Retrieve the current application mode
        errStatus = hpesa_cmdString_Q(instrumentHandle, "INST:SEL?", 32, buffer);
        if(errStatus < VI_SUCCESS) return errStatus;

        buffer[strlen(buffer)-1] = '\0';  // remove the trailing \n

        // Check to see if it's incorrect
        if(strcmp(buffer, AppStrings[AppNumber]))
        {
            // if it is, return an error
            thisPtr->errNumber = hpesa_INSTR_ERROR_INVALID_APP;
            sprintf(thisPtr->errMessage, hpesa_MSG_INVALID_APP, AppStrings[AppNumber], buffer);
            errStatus = hpesa_INSTR_ERROR_INVALID_APP;
        }
    }

    return errStatus;
}

/*---------------------------------------------------------------------------*/
/*                              end VerifyApp                                */
/*****************************************************************************/



/*****************************************************************************/
/*  TempTimeoutChange-                                                       */
/*                                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/

static ViStatus _VI_FUNC TempTimeoutChange(ViSession instrumentHandle,
                                   ViInt32 NewTimeout,
                                   ViPInt32 OldTimeout)

{
    ViStatus errStatus = VI_SUCCESS;


    // Save the current timeout value.
    errStatus = viGetAttribute(instrumentHandle, VI_ATTR_TMO_VALUE,
                                                            OldTimeout);
    if(errStatus < VI_SUCCESS) return errStatus;


    // Check to see if the old timeout is longer than the desired timeout
    if(*OldTimeout > NewTimeout)
        return VI_SUCCESS;

    // Set the necessary specified timeout value.
    errStatus = viSetAttribute(instrumentHandle,VI_ATTR_TMO_VALUE, NewTimeout);
    if(errStatus < VI_SUCCESS) return errStatus;
        
    return errStatus;
}

/*---------------------------------------------------------------------------*/
/*                              end VerifyApp                                */
/*****************************************************************************/



/*****************************************************************************/
/*****************************************************************************/
/********************                                     ********************/
/**********                                                         **********/
/****                          DRIVER FUNCTIONS                           ****/
/**                                                                         **/
/**-------------------------------------------------------------------------**/
/**     The functions which are exposed to the driver user start here.      **/
/**     They are in the following order:                                    **/
/**        VPP required functions.                                          **/
/**        Agilent required utility functions                               **/
/**        Agilent passthrough functions                                    **/
/**        Instrument specific functions                                    **/
/****                                                                     ****/
/**********                                                         **********/
/********************                                     ********************/
/*****************************************************************************/
/*****************************************************************************/



/*****************************************************************************/
/*  hpesa_init -                                                             */
/*    Initializes the instrument session and returns a valid instrument      */
/*    handle.  This will always be the first function executed to control    */
/*    an instrument.  The instrument handle is used to call all other driver */
/*    functions.                                                             */
/*                                                                           */
/*    The instrument is identified using the response to the "*IDN?" query   */
/*    and it is suggested that the response up to the Model Number be used   */
/*    for comparison.  The firmware revision should not be considered.       */
/*    A model version number may or may not be included.                     */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession      resourceName (in)                                       */
/*      The instrument's VISA address.                                       */
/*      GPIB Example: "GPIB0::18::INSTR"                                     */
/*    ViBoolean      IDQuery (in)                                            */
/*      If VI_TRUE, validate instrument identity                             */
/*    ViBoolean      resetDevice (in)                                        */
/*      If VI_TRUE, perform an instrument reset                              */
/*    ViPSession     instrumentHandle (out)                                  */
/*      Pointer to Instrument Handle.  Returns VI_NULL if the init fails.    */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_init
                        (ViRsrc     resourceName,
                         ViBoolean  IDQuery,
                         ViBoolean  resetDevice,
                         ViPSession instrumentHandle)

{
    struct     hpesa_globals *thisPtr;
    ViStatus   errStatus;
    ViSession  defRM;
    ViChar tmpDrvRev[256], tmpFrmRev[256], *temp;

    if (instrumentHandle == NULL)
        return VI_ERROR_PARAMETER4;

    *instrumentHandle = VI_NULL;

        /*-----------------------------------------------------------*
         | Find the Default Resource Manager.  Potential errors are  |
         |   VI_ERROR_SYSTEM_ERROR, VI_ERROR_ALLOC                   |
         *-----------------------------------------------------------*/

    errStatus = viOpenDefaultRM(&defRM);
    
    if (errStatus < VI_SUCCESS)
        return errStatus;

        /*-----------------------------------------------------------*
         | Open a session to the instrument.  Potential errors are   |
         |   VI_ERROR_NSUP_OPER, VI_ERROR_INV_RSRC_NAME,             |
         |   VI_ERROR_INV_ACC_MODE, VI_ERROR_RSRC_NFOUND,            |
         |   VI_ERROR_ALLOC                                          |
         | The warning, VI_SUCCESS_DEV_NPRESENT, is trapped since it |
         |   indicates that instrument is not connection or not      |
         |   turned on.  It is desireable to report this at this     |
         |   point even though it will be trapped later on.          |
         *-----------------------------------------------------------*/

    errStatus = viOpen(defRM, resourceName, VI_NULL, VI_NULL,instrumentHandle);

    if ((errStatus < VI_SUCCESS) || (errStatus == VI_SUCCESS_DEV_NPRESENT))
    {
        viClose(defRM);
        *instrumentHandle=VI_NULL;

        return errStatus;
    }

        /*-----------------------------------------------------------*
         | Allocate global memory for the session.  Inititalize the  |
         |   memory.  Note that viSetAttribute should never fail,    |
         |   as all of it's input conditions are satisfied.          |
         *-----------------------------------------------------------*/


    thisPtr = (struct hpesa_globals *)malloc(sizeof(struct hpesa_globals));

    if (thisPtr == 0)
    {
        viClose(*instrumentHandle);
        viClose(defRM);
        *instrumentHandle=VI_NULL;
        return VI_ERROR_ALLOC;
    }

    errStatus = viSetAttribute(*instrumentHandle, 
                                     VI_ATTR_USER_DATA,(ViAttrState)thisPtr);

    if (errStatus < VI_SUCCESS)
    {
        viClose(*instrumentHandle);
        viClose(defRM);
        *instrumentHandle=VI_NULL;
        free(thisPtr);
        return errStatus;
    }

        /*-----------------------------------------------------------*
         | Set initial values of variables in global memory.         |
        /*-----------------------------------------------------------*/

    thisPtr->errNumber = VI_SUCCESS;
    thisPtr->errMessage[0] = 0;
    thisPtr->errQueryDetect = VI_FALSE;
    thisPtr->dTime = 0;
    thisPtr->instrumentIDString[0] = 0;
    thisPtr->verifyApp = VI_FALSE;


    errStatus = viGetAttribute(*instrumentHandle, 
                                   VI_ATTR_INTF_TYPE,&thisPtr->interfaceType);
    if (errStatus < VI_SUCCESS)
    {
        viClose(*instrumentHandle);
        viClose(defRM);
        *instrumentHandle = VI_NULL;
        free(thisPtr);
        return errStatus;
    }


        /*-----------------------------------------------------------*
         | Reset the instrument if so instructed.                    |
         |   Clear the device before resetting.                      |
         *-----------------------------------------------------------*/

    if (thisPtr->interfaceType == VI_INTF_GPIB)
    {
        errStatus = viClear(*instrumentHandle);

        if(errStatus < VI_SUCCESS)
        {
            viClose(*instrumentHandle);
            viClose(defRM);
            *instrumentHandle = VI_NULL;
            free(thisPtr);
            return errStatus;
        }
    }
        
//        if (viClear(*instrumentHandle) <  VI_SUCCESS)
//            return initError(instrumentHandle, defRM, VI_ERROR_FAIL_ID_QUERY);


    if( resetDevice == VI_TRUE) 
        if (hpesa_reset(*instrumentHandle) <  VI_SUCCESS)
        {
            viClose(*instrumentHandle);
            viClose(defRM);
            *instrumentHandle = VI_NULL;
            free(thisPtr);
            return hpesa_INSTR_ERROR_RESET_FAILED;
        }


        /*-----------------------------------------------------------*
         | Optionally validate the instrument's identity.  The IDN?  |
         | will be retrieved and stored in global memory; however,   |
         | it will only be validated against known instruments if    |
         | IDQuery is turned on.                                     |
         *-----------------------------------------------------------*/

     
    
    errStatus = delayVQueryf(*instrumentHandle, 
                                "*IDN?\n", "%t", thisPtr->instrumentIDString);
    if (errStatus < VI_SUCCESS)   
    {
        viClose(*instrumentHandle);
        viClose(defRM);
        *instrumentHandle = VI_NULL;
        free(thisPtr);
        return errStatus;
    }
    
    
    if (IDQuery == VI_TRUE)
        if(InvalidInstrumentID(thisPtr->instrumentIDString))
        {
            viClose(*instrumentHandle);
            viClose(defRM);
            *instrumentHandle = VI_NULL;
            free(thisPtr);
            return VI_ERROR_FAIL_ID_QUERY;
        }

    errStatus = hpesa_revision_query(*instrumentHandle,
                                     tmpDrvRev,
                                     tmpFrmRev);
    if (errStatus < VI_SUCCESS)
    {
        viClose(*instrumentHandle);
        viClose(defRM);
        *instrumentHandle = VI_NULL;
        free(thisPtr);
        return errStatus;
    }

    thisPtr->drvRev = strtod(&tmpDrvRev[3], &temp);
    thisPtr->instRev = strtod(&tmpFrmRev[3], &temp);

    return statusUpdate(*instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end hpesa_init                               */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_close -                                                            */
/*    Closes the VISA session associated with the instrument handle and      */
/*    frees all resources associated with that session.  This is typically   */
/*    the last call to the driver from the test program.                     */
/*                                                                           */  
/*  PARAMETERS                                                               */
/*    ViSession      instrumentHandle (in)                                   */
/*      Instrument Handle returned from hpesa_init()                         */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_close
                        (ViSession    instrumentHandle)

{
    struct hpesa_globals *thisPtr;
    ViStatus errStatus = VI_SUCCESS;
    ViSession defRM;

    GET_GLOBALS(instrumentHandle, thisPtr)

        /*-----------------------------------------------------------*
         | Retrieve Resource Management session, free global memory  |
         |   for the session (if it exists), and close the vi and    |
         |   RM sessions.                                            |
         *-----------------------------------------------------------*/

    errStatus = viGetAttribute(instrumentHandle, VI_ATTR_RM_SESSION, &defRM);
    if (errStatus  < VI_SUCCESS)
    {
        thisPtr->errNumber = errStatus;
        return errStatus;
    }

    if (thisPtr)        
        free(thisPtr);

    return viClose(defRM);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end hpesa_close                              */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_reset -                                                            */
/*    Returns the instrument to a known state.  If the instrument does not   */
/*    provide a reset capability, the driver must set the instrument to a    */
/*    known state explicitly in this routine.                                */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession      instrumentHandle (in)                                   */
/*      Instrument Handle returned from hpesa_init()                         */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_reset
                        (ViSession instrumentHandle)

{
    struct hpesa_globals *thisPtr;
    ViStatus errStatus = VI_SUCCESS;
    ViInt32 previousTimeout = 0;
    ViInt16 temp = 0;

    GET_GLOBALS(instrumentHandle, thisPtr)

    // Temporarily set the timeout value to 30 seconds for the swtich
    errStatus = TempTimeoutChange(instrumentHandle, 30000, &previousTimeout);
    if (errStatus < VI_SUCCESS) return errStatus;

/*    errStatus = delayVPrintf(instrumentHandle, "*RST\n");
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    errStatus = hpesa_opc_Q(instrumentHandle, &temp);
    if (errStatus < VI_SUCCESS) return errStatus;
*/
    
    errStatus = hpesa_cmdInt16_Q(instrumentHandle, "*RST;*OPC?", &temp);
    if (errStatus < VI_SUCCESS) return errStatus;
    
    errStatus = hpesa_sweepDoSweep(instrumentHandle, 30, &temp);

    // Set the necessary specified timeout value.
    viSetAttribute(instrumentHandle,VI_ATTR_TMO_VALUE, previousTimeout);

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end hpesa_reset                              */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_self_test -                                                        */
/*    Performs a self-test of the instrument and returns the self-test       */
/*    and returns the self-test result and a text error message.             */
/*    Possible errors and timeout should be specified in instrument          */
/*    documentation.                                                         */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*      Instrument Handle returned from hpesa_init()                         */
/*    ViPInt16    selfTestResult (out)                                       */
/*      Self-test result                                                     */
/*    ViPString   selfTestMessage[] (out)                                    */
/*      Self-test status message string, limited to 256 characters.          */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_self_test
                        (ViSession    instrumentHandle,
                         ViPInt16    selfTestResult,
                         ViPString    selfTestMessage)

{
    struct hpesa_globals *thisPtr;
    ViStatus errStatus = VI_SUCCESS;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(selfTestResult, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(selfTestMessage, VI_ERROR_PARAMETER3)

    *selfTestResult = -1; 
    selfTestMessage[0] = 0; 



    errStatus = delayVQueryf(instrumentHandle, "*TST?\n", 
                                                 "%hd%*t",selfTestResult);

    if (errStatus < VI_SUCCESS)
    {
        *selfTestResult = -1; 
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
    }

    switch( *selfTestResult)
    {
        case 0:
            sprintf(selfTestMessage, hpesa_MSG_SELF_TEST_PASSED);
            break;

        default:
            sprintf(selfTestMessage, hpesa_MSG_SELF_TEST_FAILED);
            break;
    }

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end hpesa_self_test                          */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_error_query -                                                      */
/*    Queries the instrument for errors and reports the top error in the     */
/*    instrument's error message queue.  This function will get the error    */
/*    number and the detailed error message from the instrument.             */
/*    Documentation should specify whether the instrument returns text error */
/*    messages or only error numbers.                                        */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession    instrumentHandle (in)                                     */
/*      Instrument Handle returned from hpesa_init()                         */
/*    ViPInt32     errorCode (out)                                           */
/*      An instrument error code                                             */
/*    ViPString    errorMessage[] (out)                                      */
/*      Instrument error message string, limited to 256 characters.          */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_error_query
                        (ViSession    instrumentHandle,
                         ViPInt32    errorCode,
                         ViPString    errorMessage)

{
    struct hpesa_globals *thisPtr;
    ViStatus errStatus = VI_SUCCESS;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(errorCode, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(errorMessage, VI_ERROR_PARAMETER3)

    *errorCode = -1; 
    errorMessage[0] = 0; 

    errStatus = delayVQueryf( instrumentHandle, "SYST:ERR?\n", "%ld,%t",
                                                    errorCode, errorMessage);

    if (errStatus < VI_SUCCESS)
    {
        *errorCode = -1; 
        errorMessage[0] = 0; 
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
    }

    /* get rid of extra LF at the end of the error_message */
    errorMessage[strlen(errorMessage)-1] = 0;

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                       end hpesa_error_query                               */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_error_message -                                                    */
/*    Returns a text string for an error number.  Developer is responsible   */
/*    for providing a text string in this routing for any and all errors     */
/*    that are not returned by VISA (i.e. driver-generated).  This function  */
/*    does not communicate with the instrument.                              */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*      Instrument Handle returned from hpesa_init()                         */
/*      May be VI_NULL for this function                                     */
/*    ViStatus    statusCode (in)                                            */
/*      The error return value from an instrument driver function            */
/*    ViPString   message[] (out)                                            */
/*      Error message string.  This is limited to 256 characters.            */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_error_message
                        (ViSession    instrumentHandle,
                         ViStatus     statusCode,
                         ViPString    message)

{
    struct    hpesa_globals *thisPtr = NULL;
    ViStatus  errStatus;  
    ViInt32   idx;

    if (instrumentHandle != VI_NULL)
        GET_GLOBALS(instrumentHandle, thisPtr)

    /*  Parameter checks */

    if (thisPtr)
    {
        CHK_NULL_POINTER(message, VI_ERROR_PARAMETER3)
    }
    else if (message == NULL)
    {
        return VI_ERROR_PARAMETER3;
    }

    message[0] = 0;

    if (statusCode == VI_SUCCESS)
    {
        sprintf(message, hpesa_MSG_NO_ERRORS);
        if (thisPtr)
        {
            thisPtr->errNumber = VI_SUCCESS;
        }
        return VI_SUCCESS;
    }

        /*-----------------------------------------------------------*
         | Search the error message table to see if the error is in  |
         |   that table.  If it is, copy the corresponding error     |
         |   message to the output error message.  If context        |
         |   dependent error messages are being used, append the     |
         |   context dependent information to the message.           |
         | If the error is found in the table, exit the routine      |
         |   successfully.                                           |
         *-----------------------------------------------------------*/

    for (idx=0; 
         idx < (sizeof instrErrMsgTable / sizeof(struct instrErrStruct));
         idx++)
    {
        if (instrErrMsgTable[idx].errStatus == statusCode)
        {
            strcpy(message, instrErrMsgTable[idx].errMessage);

            if (thisPtr)
            {
                if (thisPtr->errNumber == statusCode)
                {
                    /* use the context dependent info. */
                    strcat(message, ";  ");
                    strcat(message, thisPtr->errMessage);
                }
                /* clear the context dependent info. */
                thisPtr->errMessage[0] = '\0';
                thisPtr->errNumber = VI_SUCCESS;
            }
            return VI_SUCCESS;
        }
    }



/*        if (instrErrMsgTable[idx].errStatus == statusCode)
        {
            if ((thisPtr) && (thisPtr->errNumber == statusCode))
            {
                sprintf(message, "%s;  %s",
                    instrErrMsgTable[idx].errMessage,thisPtr->errMessage);
                thisPtr->errNumber = VI_SUCCESS;
            }
            else
                strcpy(message, instrErrMsgTable[idx].errMessage);
        
            return VI_SUCCESS;
        }
    }
*/
        /*-----------------------------------------------------------*
         | Check to see if the error is a VTL/VISA error number      |
         |   using viStatusDesc, which will also return the error    |
         |   message.  If context dependent error messages are       |
         |   used, append the context dependent information to the   |
         |   message.                                                |
         | If the error is found in the table, exit the routine      |
         |   successfully.                                           |
         *-----------------------------------------------------------*/


    errStatus = viStatusDesc(instrumentHandle, statusCode, message);
    if (errStatus == VI_SUCCESS)
    {
        if (thisPtr)
        {
            if (thisPtr->errNumber == statusCode)
            {
                /* use the context dependent info. */
                strcat(message, ";  ");
                strcat(message, thisPtr->errMessage);
            }
            /* clear the context dependent info. */
            thisPtr->errMessage[0] = '\0';
            thisPtr->errNumber = VI_SUCCESS;
        }
        return VI_SUCCESS;
    }


/*    errStatus = viStatusDesc(instrumentHandle, statusCode, message);
    if (errStatus == VI_SUCCESS)
    {
        if( (thisPtr) && (thisPtr->errNumber == statusCode))
        {
            strcat(message, ";  ");
            strcat(message, thisPtr->errMessage);
        }

    thisPtr->errNumber = VI_SUCCESS;
    return VI_SUCCESS;
    }
*/
        /*-----------------------------------------------------------*
         |   At this point vi is either INVALID or VI_NULL           |
         *-----------------------------------------------------------*/

    if (instrumentHandle == VI_NULL)
    {
        strcpy(message, hpesa_MSG_VI_OPEN_ERR);
        //thisPtr->errNumber = VI_SUCCESS;
        return VI_SUCCESS;
    } 

    sprintf(message, hpesa_MSG_INVALID_STATUS "  %ld"
    hpesa_MSG_INVALID_STATUS_VALUE, (long)statusCode);
    
    thisPtr->errNumber = VI_ERROR_PARAMETER2;
    return VI_ERROR_PARAMETER2;

}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                       end hpesa_error_message                             */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_revision_query -                                                   */
/*    Queries the instrument and driver for the current revision number.     */
/*    The instrument's firmware revision is obtained from the response to    */
/*    the "*IDN?" command.  The driver revision is hardcoded in driver.      */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession    instrumentHandle (in)                                     */
/*      Instrument Handle returned from hpesa_init()                         */
/*    ViPString    instrumentDriverRevision[] (out)                          */
/*      Instrument driver revision.  This is limited to 256 characters.      */
/*    ViPString    firmwareRevision[] (out)                                  */
/*      Instrument firmware revision.  This is limited to 256 characters.    */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_revision_query
                        (ViSession    instrumentHandle,
                         ViPString    instrumentDriverRevision,
                         ViPString    firmwareRevision)

{
    struct    hpesa_globals *thisPtr;
    ViStatus  errStatus;
    ViChar    temp_str1[256];         /* temp hold for instr rev string */
    ViChar   *last_comma;             /* last comma in *IDN string */
    
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(instrumentDriverRevision, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(firmwareRevision, VI_ERROR_PARAMETER3)


    instrumentDriverRevision[0] = 0; 
    firmwareRevision[0] = 0; 

    sprintf(instrumentDriverRevision, "%s", hpesa_REV_CODE);

        /*-----------------------------------------------------------*
         | In the standard c template, the scan format string is     |
         |   "%t%*t".  This removes white space from the end of the  |
         |   returned string, but doesn't work if there are          |
         |   embedded spaces in the returned string.  I used this    |
         |   format string and resorted to stripping off spaces and  |
         |   spaces and trailing non-printing characters below.      |
         *-----------------------------------------------------------*/

    errStatus = delayVQueryf( instrumentHandle, "*IDN?\n", "%t", temp_str1);
    if (errStatus < VI_SUCCESS)
    {
        instrumentDriverRevision[0] = 0; 
        firmwareRevision[0]  = 0; 
        return statusUpdate(instrumentHandle, thisPtr, errStatus); 
    }
    
        /*-----------------------------------------------------------*
         | error and exit if last comma not found                    |
         *-----------------------------------------------------------*/

    last_comma = strrchr(temp_str1,',');

    if (!last_comma) 
    {
        firmwareRevision[0] = 0;
        strcpy(thisPtr->errMessage, INSTR_ERROR_NO_LAST_COMMA);
        thisPtr->errNumber = hpesa_INSTR_NO_LAST_COMMA;
        return hpesa_INSTR_NO_LAST_COMMA; 
    }

        /*-----------------------------------------------------------*
         | The next statement assumes that the firmware revision of  |
         |   the instrument follows the last comma/space pair.  The  |
         |   strncat() statement removes the trailing newline.       |
         |***********************************************************|
         | JMH Note: eliminate the comma at the end of the line.     |
         *-----------------------------------------------------------*/

    strcpy(temp_str1, last_comma+2);
    strncat(firmwareRevision, temp_str1, (strlen(temp_str1)-1));

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS); 
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end hpesa_revision_query                     */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_timeOut -                                                          */
/*    Sets the amount of time a driver should wait on I/O in milliseconds,   */
/*    before returning a timeout error.  Default timeout is driver dependent */
/*    but should not be set to a value that would cause a timeout during     */
/*    normal operation.  The driver is allowed to override the default and   */
/*    and set timeout in certain long routines (e.g. self-test, long         */
/*    measurements).  It may be helpful to provide a separate timeout call   */
/*    for these functions.  A function overriding the default timeout must   */
/*    restore it before completing.                                          */
/*                                                                           */
/*    The default timeout for HP VISA is 2 seconds.  This routine is driver  */
/*    internal.                                                              */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession  instrumentHandle (in)                                       */
/*      Instrument Handle returned from hpesa_init()                         */
/*    ViInt32    setTimeOut (in)                                             */
/*      The period of time which VISA will allow an instrument command to    */
/*      wait before stopping it's execution.                                 */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_timeOut
                        (ViSession    instrumentHandle, 
                         ViInt32    setTimeOut)

{
    ViStatus errStatus = 0;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_LONG_RANGE(setTimeOut, hpesa_TIMEOUT_MIN, hpesa_TIMEOUT_MAX, 
                                                          VI_ERROR_PARAMETER2);

    errStatus = viSetAttribute(instrumentHandle, VI_ATTR_TMO_VALUE,setTimeOut);

    if (errStatus < VI_SUCCESS)
    {
        thisPtr->errNumber = errStatus;
        return errStatus;
    }

    thisPtr->errNumber = VI_SUCCESS;
    return VI_SUCCESS;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end hpesa_timeOut                            */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_timeOut_Q -                                                        */
/*    Returns the current setting of the timeout value of the instrument in  */
/*    milliseconds.                                                          */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession  instrumentHandle (in)                                       */
/*      Instrument Handle returned from hpesa_init()                         */
/*    ViPInt32   timeOut (out)                                               */
/*      The period of time which VISA will allow an instrument command to    */
/*      wait before stopping it's execution.                                 */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_timeOut_Q
                        (ViSession  instrumentHandle,
                         ViPInt32    timeOut)

{
    ViStatus errStatus = 0;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(timeOut, VI_ERROR_PARAMETER2)

    errStatus = viGetAttribute(instrumentHandle, VI_ATTR_TMO_VALUE,timeOut);

    if (errStatus < VI_SUCCESS)
    {
        thisPtr->errNumber = errStatus;
        return errStatus;
    }

    thisPtr->errNumber = VI_SUCCESS;
    return VI_SUCCESS;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end hpesa_timeOut_Q                          */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_errorQueryDetect -                                                 */
/*    This function sets a flag, detectError, which, if true, instructs a    */
/*    centralized error handling routine in the driver to a non-destructive  */
/*    query the instrument for the presence of errors.  The method of        */
/*    querying the instrument is somewhat instrument dependent.  In          */
/*    IEEE 488.2 compliant instruments, this is accomplished by querying     */
/*    the instrument's event status register and examining the four bytes    */
/*    relating to instrument errors.                                         */
/*                                                                           */
/*    This function is driver internal and only sets the flag.  No commands  */
/*    are sent to the instrument.                                            */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession  instrumentHandle (in)                                       */
/*      Instrument Handle returned from hpesa_init()                         */
/*    ViBoolean  setErrorQueryDetect (in)                                    */
/*      Enables (VI_TRUE) or disables (VI_FALSE) automatic instrument error  */
/*      querying                                                             */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_errorQueryDetect
                        (ViSession    instrumentHandle,
                         ViBoolean    setErrorQueryDetect)

{
    ViStatus errStatus = 0;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_BOOLEAN(setErrorQueryDetect, VI_ERROR_PARAMETER2);

    thisPtr->errQueryDetect = setErrorQueryDetect;

    thisPtr->errNumber = VI_SUCCESS;
    return VI_SUCCESS;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_errorQueryDetect                         */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_errorQueryDetect_Q -                                               */
/*    Queries the error detection flag.  Again, this command is driver       */
/*    and does not interact with the instrument. See hpesa_errorQueryDetect  */
/*    function for more information.                                         */
/*                                                                           */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*      Instrument Handle returned from hpesa_init()                         */
/*    ViPBoolean  errorQueryDetect (out)                                     */
/*      Equals VI_TRUE if automatic instrument error querying is being       */
/*      being performed.                                                     */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_errorQueryDetect_Q
                        (ViSession    instrumentHandle,
                         ViPBoolean errorQueryDetect)

{
    ViStatus errStatus = 0;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(errorQueryDetect, VI_ERROR_PARAMETER2)

    *errorQueryDetect = thisPtr->errQueryDetect;

    thisPtr->errNumber = VI_SUCCESS;
    return VI_SUCCESS;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                       end hpesa_errorQueryDetect_Q                        */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_dcl -                                                              */
/*    Sends a device clear message to the instrument which, in turn, clears  */
/*    all input and output buffers, clears any pending operations, and       */
/*    the instrument parser into a state where it is ready to accept input.  */
/*    This routine does not generate any unique error conditions beyond      */
/*    those returned by VISA.                                                */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession instrumentHandle (in)                                        */
/*      Instrument Handle returned from hpesa_init()                         */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_dcl
                        (ViSession    instrumentHandle)

{
    ViStatus errStatus = 0;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    if (thisPtr->interfaceType == VI_INTF_GPIB)
    {
        errStatus = viClear(instrumentHandle);
        if (errStatus < VI_SUCCESS)
            return statusUpdate( instrumentHandle, thisPtr, errStatus);    
    }

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end hpesa_dcl                                */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_opc_Q -                                                            */
/*    Sends an *OPC? command to the instrument and returns VI_TRUE when all  */
/*    pending operations are complete.                                       */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*      Instrument handle returned from hpesa_init()                         */
/*    ViPBoolean  instrumentReady (out)                                      */
/*      Returns VI_TRUE when pending operations are complete.                */
/*---------------------------------------------------------------------------*/
 
ViStatus _VI_FUNC hpesa_opc_Q
                        (ViSession    instrumentHandle,
                         ViPBoolean    instrumentReady)

{
    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
   
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(instrumentReady, VI_ERROR_PARAMETER2)


    thisPtr->dTime = 200;

    errStatus  =delayVQueryf(instrumentHandle, "*OPC?\n", 
                                    "%hd%*t",instrumentReady);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}

/*****************************************************************************/
/*  hpesa_opc_Q -                                                            */
/*    Sends an *OPC? command to the instrument and returns VI_TRUE when all  */
/*    pending operations are complete.                                       */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*      Instrument handle returned from hpesa_init()                         */
/*    ViPBoolean  instrumentReady (out)                                      */
/*      Returns VI_TRUE when pending operations are complete.                */
/*---------------------------------------------------------------------------*/
 
ViStatus _VI_FUNC hpesa_wait_opc_timeout
                        (ViSession    instrumentHandle,
							int	iTimeout )

{
    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    ViPBoolean    instrumentReady = 0;
	
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(instrumentReady, VI_ERROR_PARAMETER2)


    thisPtr->dTime = iTimeout;

    errStatus  =delayVQueryf(instrumentHandle, "*OPC\n", 
                                    "%hd%*t",instrumentReady);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end hpesa_opc_Q                              */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_readStatusByte_Q -                                                 */
/*    Returns the instrument's primary status byte.                          */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession instrumentHandle (in)                                        */
/*      Instrument Handle returned from hpesa_init()                         */
/*    ViPInt16  statusByte (out)                                             */
/*      Returns the contents of the status byte                              */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_readStatusByte_Q
                        (ViSession    instrumentHandle, 
                         ViPInt16    statusByte)

{
    ViStatus  errStatus = 0;
    struct    hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(statusByte, VI_ERROR_PARAMETER2)

    if ((errStatus = hpesa_cmdInt16_Q(instrumentHandle, "*STB?", statusByte))
            < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus );

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);


}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                       end hpesa_readStatusByte_Q                          */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_operEvent_Q                                                        */
/*    Returns the contents of the instrument's operation event status        */
/*    register.  This routine is only required for IEEE 488.2 instruments.   */
/*    Note that if the user makes this call, automatic error detection may   */
/*    miss an instrument error or other event that is automatically handled  */
/*    in the driver.  Some instruments use non-standard forms of the SCPI    */
/*    command which look similar to the standard form.                       */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession vi (in)                                                      */
/*      Instrument Handle returned from hpesa_init()                         */
/*    ViPInt32  operationEventRegister (out)                                 */
/*      Returns the contents of the operation event register                 */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_operEvent_Q
                        (ViSession instrumentHandle, 
                         ViPInt32  operationEventRegister)

{
    ViStatus  errStatus;
    struct    hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(operationEventRegister, VI_ERROR_PARAMETER2)

    errStatus = delayVQueryf(instrumentHandle,"STAT:OPER:EVEN?\n", 
                                "%ld%*t", operationEventRegister);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                          end hpesa_operEvent_Q                            */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_operCond_Q                                                         */
/*    Returns the contents of the instrument's operation condition register. */
/*    This function is only required for IEEE 488.2 instruments.  Some       */
/*    instruments use non-standard forms of the SCPI command which look      */
/*    similar to the standard form.                                          */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession instrumentHandle (in)                                        */
/*      Instrument Handle returned from hpesa_init()                         */
/*    ViPInt32  operationConditionRegister (out)                             */
/*      Returns the contents of the operation condition register             */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_operCond_Q
                        (ViSession instrumentHandle, 
                         ViPInt32  operationConditionRegister)

{
    ViStatus   errStatus;
    struct     hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(operationConditionRegister, VI_ERROR_PARAMETER2)

    errStatus =delayVQueryf(instrumentHandle, "STAT:OPER:COND?\n", 
                                "%ld%*t",operationConditionRegister);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                           end hpesa_operCond_Q                            */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_quesEvent_Q -                                                      */
/*    Returns the contents of instrument's data questionable status register.*/
/*    This function is only required for IEEE 488.2 instruments.  Some       */
/*    instruments use non-standard forms of the SCPI command which look      */
/*    similar to the standard form.                                          */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession instrumentHandle (in)                                        */
/*      Instrument Handle returned from hpesa_init()                         */
/*    ViPInt32  questionableEventRegister (out)                              */
/*      Returns the contents of the questionable event register              */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_quesEvent_Q
                        (ViSession instrumentHandle,
                         ViPInt32  questionableEventRegister)

{
    ViStatus  errStatus;
    struct    hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(questionableEventRegister, VI_ERROR_PARAMETER2)

    errStatus = delayVQueryf(instrumentHandle, "STAT:QUES:EVEN?\n",
                                    "%ld%*t", questionableEventRegister);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS );
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                         end hpesa_quesEvent_Q                             */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_quesCond_Q -                                                       */
/*    Returns the contents of the instrument's data questionable condition   */
/*    register.  This routine is only required for IEEE 488.2 instruments.   */
/*    Some instruments use non-standard forms of the SCPI command which look */
/*    similar to the standard form.                                          */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession instrumentHandle (in)                                        */
/*      Instrument Handle returned from hpesa_init()                         */
/*    ViPInt32  questionableConditionRegister (out)                          */
/*      Returns the contents of the questionable condition register          */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_quesCond_Q
                        (ViSession instrumentHandle, 
                         ViPInt32  questionableConditionRegister)
 
{
    ViStatus  errStatus;
    struct    hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)
 
    CHK_NULL_POINTER(questionableConditionRegister, VI_ERROR_PARAMETER2)

    errStatus = delayVQueryf(instrumentHandle, "STAT:QUES:COND?\n", 
                                   "%ld%*t",questionableConditionRegister);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                          end hpesa_quesCond_Q                             */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_cmd -                                                              */
/*    Send a arbitrary command string to the instrument, but does not look   */
/*    for a response.                                                        */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession     instrumentHandle (in)                                    */
/*      Instrument handle returned from hpesa_init()                         */
/*    ViString      sendStringCommand (in)                                   */
/*      The SCPI command string to be sent to the instrument                 */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_cmd
                        (ViSession instrumentHandle, 
                         ViString  sendStringCommand)

{
    ViStatus errStatus = VI_SUCCESS;
    struct   hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(sendStringCommand, VI_ERROR_PARAMETER2)

    errStatus = delayVPrintf(instrumentHandle,"%s\n", sendStringCommand);
   
    return statusUpdate(instrumentHandle, thisPtr, errStatus);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              end hpesa_cmd                                */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_cmdString_Q -                                                      */
/*    Sends an arbitrary command string to the instrument and returns a      */
/*    single string parameter.  The returned string will be null terminated  */
/*    and return only 256 characters.                                        */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession       instrumentHandle (in)                                  */
/*      Instrument handle returned from hpesa_init()                         */
/*    ViString        queryStringCommand (in)                                */
/*      The SCPI command string to be sent to the instrument                 */
/*    ViInt32         stringSize (in)                                        */
/*      The size of the char array (result) passed to the function to hold   */
/*      the string returned by the instrument                                */
/*    ViChar _VI_FAR  stringResult[] (out)                                   */
/*      The string returned by the instrument                                */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_cmdString_Q
                        (ViSession       instrumentHandle,
                         ViString        queryStringCommand,
                         ViInt32         stringSize,
                         ViChar _VI_FAR  stringResult[] )

{
    ViStatus  errStatus;
    struct    hpesa_globals *thisPtr;
    int       sz;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(queryStringCommand, VI_ERROR_PARAMETER2)
    CHK_LONG_RANGE(stringSize, hpesa_CMDSTRINGARR_Q_MIN, 
                               hpesa_CMDSTRINGARR_Q_MAX, VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(stringResult, VI_ERROR_PARAMETER4)

    sz = (int)stringSize;
    
    errStatus = delayVQueryf(instrumentHandle, "%s\n", "%#t", 
                                      queryStringCommand, &sz, stringResult);
    
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
    
    stringResult[sz]='\0';
      
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                            end hpesa_cmdString_Q                          */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_cmdInt -                                                           */
/*    Sends an arbitrary command string followed by a single integer         */
/*    parameter to the instrument.  A white space character is sent between  */
/*    the string and the integer.                                            */ 
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession  instrumentHandle (in)                                       */
/*      Instrument handle returned from hpesa_init()                         */
/*    ViString   sendIntegerCommand (in)                                     */
/*      The instrument command string to be sent to the instrument.          */
/*    ViInt32   sendInteger (in)                                             */
/*      The integer sent to the instrument at the end of the instrument      */
/*      command.  Can be ViInt16 or ViInt32.                                 */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_cmdInt
                        (ViSession  instrumentHandle,
                         ViString   sendIntegerCommand,
                         ViInt32    sendInteger )

{  
    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
   
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(sendIntegerCommand, VI_ERROR_PARAMETER2)

    errStatus = delayVPrintf(instrumentHandle, "%s %ld\n", 
                                         sendIntegerCommand,sendInteger);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                             end hpesa_cmdInt                              */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_cmdInt16_Q -                                                       */
/*    Sends SCPI command and waits for a response that must be representable */
/*    as an int16.  A non-numeric instrument response returns zero instead.  */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession  instrumentHandle (in)                                       */
/*      Instrument handle returned from hpesa_init()                         */
/*    ViString   queryI16Command (in)                                        */
/*      The SCPI command string to be sent to the instrument.                */
/*    ViPInt16   i16Result (out)                                             */
/*      The integer returned from the instrument.                            */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_cmdInt16_Q
                        (ViSession  instrumentHandle, 
                         ViString   queryI16Command,
                         ViPInt16   i16Result)

{
    ViStatus errStatus = VI_SUCCESS;
    struct   hpesa_globals *thisPtr;
   
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(queryI16Command, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(i16Result, VI_ERROR_PARAMETER3)

    errStatus = delayVQueryf(instrumentHandle, "%s\n", "%hd%*t", 
                                    queryI16Command, i16Result);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                           end hpesa_cmdInt16_Q                            */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_cmdInt32_Q -                                                       */
/*    Sends SCPI command and waits for a response that must be representable */
/*    as an int32.  A non numeric instrument response returns zero instead.  */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession  instrumentHandle (in)                                       */
/*      Instrument handle returned from hpesa_init()                         */
/*    ViString   queryI32Command (in)                                        */
/*      The SCPI command string to be sent to the instrument.                */
/*    ViPInt32   i32Result (out)                                             */
/*      The integer returned from the instrument.                            */
/*---------------------------------------------------------------------------*/


ViStatus _VI_FUNC hpesa_cmdInt32_Q
                        (ViSession instrumentHandle,
                         ViString  queryI32Command, 
                         ViPInt32  i32Result)
{  
    ViStatus  errStatus;
    struct    hpesa_globals *thisPtr;
   
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(queryI32Command, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(i32Result, VI_ERROR_PARAMETER3)

    errStatus= delayVQueryf(instrumentHandle, "%s\n", "%ld%*t",
                                    queryI32Command, i32Result);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
        
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                           end hpesa_cmdInt32_Q                            */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_cmdInt16Arr_Q -                                                    */
/*    This function is part of the standard Utility package, but has not     */
/*    been verified for the basic driver. They may be restored when          */
/*    additional tests are available to verify their operation.              */
/*---------------------------------------------------------------------------*/
    
/* ViStatus _VI_FUNC hpesa_cmdInt16Arr_Q(ViSession instrumentHandle,
                                       ViString  queryI16ArrayCommand,
                                       ViInt32   i16ArraySize,
                                       ViInt16   _VI_FAR i16ArrayResult[],
                                       ViPInt32  i16ArrayCount)


{
    ViStatus  errStatus ;
    ViUInt32  cnt;
    struct    hpesa_globals * thisPtr;
    char      lc[100];
    ViInt32   i;
    ViInt32   ArrSize;
    ViInt32   nbytes;
    char      _huge *Array;
    
    GET_GLOBALS(instrumentHandle , thisPtr)

    CHK_LONG_RANGE(i16ArraySize, hpesa_CMDINT16ARR_Q_MIN, 
                                  hpesa_CMDINT16ARR_Q_MAX, VI_ERROR_PARAMETER3)

    errStatus= delayVPrintf(instrumentHandle , "%s\n",queryI16ArrayCommand);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
    
    errStatus = delayRead(instrumentHandle,(ViPBuf)lc, 1, &cnt);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
    
    if (lc[0] != '#')
    {
        thisPtr->errNumber = VI_ERROR_INV_EXPR;
        return VI_ERROR_INV_EXPR;
    }
    
    errStatus = delayRead(instrumentHandle,(ViPBuf)lc, 1, &cnt);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
    
    nbytes = lc[0]-'0';
        
    if (nbytes)
    {
        errStatus = delayRead(instrumentHandle,(ViPBuf)lc, nbytes, &cnt);
        
        if (errStatus < VI_SUCCESS)
            return statusUpdate(instrumentHandle, thisPtr, errStatus);
    lc[cnt] = '\0';
    ArrSize = atol(lc);
    }
    else
        ArrSize = i16ArraySize*sizeof(ViInt16);
            
    Array = (char *)malloc(ArrSize ); 
    
    if (!Array )
    {
        thisPtr->errNumber = VI_ERROR_ALLOC;
        return VI_ERROR_ALLOC;
    }
    
    errStatus = delayRead(instrumentHandle,(ViPBuf)Array, ArrSize, &cnt);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
    if (thisPtr->interfaceType == VI_INTF_GPIB)
        if (errStatus == VI_SUCCESS_MAX_CNT)
            viClear(instrumentHandle );
    
    ArrSize = cnt/sizeof(ViInt16);
    ArrSize = (ArrSize > i16ArraySize) ? i16ArraySize : ArrSize;
    
    //copy only as many as the user allows
    memcpy(i16ArrayResult, Array, (size_t)ArrSize*sizeof(ViInt16)); 

    free(Array); 

    *i16ArrayCount=ArrSize;

    for (i = 0; i < *i16ArrayCount; i++)
        SWAP_16(&i16ArrayResult[i]);

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);                
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                          end hpesa_cmdInt16Arr_Q                          */
/*                                                                           */
/*****************************************************************************/
                                                                        

/*****************************************************************************/
/*  hpesa_cmdInt32Arr_Q -                                                    */
/*    This function is part of the standard Utility package, but has not     */
/*    been verified for the basic driver. They may be restored when          */
/*    additional tests are available to verify their operation.              */
/*---------------------------------------------------------------------------*/

/*ViStatus _VI_FUNC hpesa_cmdInt32Arr_Q(ViSession instrumentHandle,
                                       ViString  queryI32ArrayCommand,
                                       ViInt32   i32ArraySize,
                                       ViInt32   _VI_FAR i32ArrayResult[],
                                       ViPInt32  i32ArrayCount)

{
    ViStatus  errStatus ;
    ViUInt32  cnt;
    struct    hpesa_globals * thisPtr;
    char      lc[100];
    ViInt32   i;
    ViInt32   ArrSize;
    ViInt32   nbytes;
    char      _huge *Array;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_LONG_RANGE(i32ArraySize, hpesa_CMDINT32ARR_Q_MIN, 
                                  hpesa_CMDINT32ARR_Q_MAX, VI_ERROR_PARAMETER3)

    errStatus = delayVPrintf(instrumentHandle, "%s\n",queryI32ArrayCommand);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
            
    errStatus = delayRead(instrumentHandle,(ViPBuf)lc, 1, &cnt);
    
    if (errStatus  < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
    
    if (lc[0] != '#')
    {
        thisPtr->errNumber = VI_ERROR_INV_EXPR;
        return VI_ERROR_INV_EXPR;
    }

    errStatus= delayRead(instrumentHandle,(ViPBuf)lc, 1, &cnt);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
    
    nbytes = lc[0]-'0';

    if (nbytes)
    {
        errStatus = delayRead(instrumentHandle,(ViPBuf)lc, nbytes, &cnt);
        
        if (errStatus < VI_SUCCESS)
            return statusUpdate(instrumentHandle, thisPtr, errStatus);
        lc[cnt] = '\0';
        ArrSize = atol(lc);
    }
    else
        ArrSize = i32ArraySize*sizeof(ViInt32);
            
    Array = (char *)malloc(ArrSize ); 
    
    if (!Array)
    {
        thisPtr->errNumber = VI_ERROR_ALLOC;
        return VI_ERROR_ALLOC;
    }

    errStatus = delayRead(instrumentHandle,(ViPBuf)Array, ArrSize, &cnt);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
    
    if (thisPtr->interfaceType == VI_INTF_GPIB)
        if (errStatus == VI_SUCCESS_MAX_CNT)
            viClear(instrumentHandle);
    
    ArrSize = cnt/sizeof(ViInt32);
    ArrSize = (ArrSize > i32ArraySize ) ? i32ArraySize : ArrSize;

    // copy only as many as the user allows
    memcpy(i32ArrayResult, Array, (size_t)ArrSize*sizeof(ViInt32));

    free(Array);

    *i32ArrayCount = ArrSize;

    for (i = 0; i < *i32ArrayCount; i++)
        SWAP_32 (&i32ArrayResult[i]);

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);                
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                         end hpesa_cmdInt32Arr_Q                           */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_cmdReal -                                                          */
/*    Sends an instrument command followed by a single floating point        */
/*    parameter.  A white space character is sent between the string and the */
/*    parameter.                                                             */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession  instrumentHandle (in)                                       */
/*      Instrument handle returned from hpesa_init()                         */
/*    ViString   sendRealCommand (in)                                        */
/*      The instrument command string to be sent to the instrument.          */
/*    ViReal64   sendReal (in)                                               */
/*      The real number sent to the instrument at the end of the instrument  */
/*      command.  Can be ViReal32 or ViReal64.                               */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_cmdReal
                        (ViSession  instrumentHandle,
                         ViString   sendRealCommand,
                         ViReal64   sendReal )

{
    ViStatus errStatus = VI_SUCCESS;
    struct   hpesa_globals *thisPtr;
   
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(sendRealCommand, VI_ERROR_PARAMETER2)

    errStatus = delayVPrintf(instrumentHandle, "%s %lg\n", 
                                        sendRealCommand,  sendReal);
        
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                             end hpesa_cmdReal                             */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_cmdReal64_Q -                                                      */
/*    Sends SCPI command and waits for a response that must be representable */
/*    as an real64.  A non-numeric instrument response returns zero instead, */
/*    in case of underflow undefined.                                        */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession  instrumentHandle (in)                                       */
/*      Instrument handle returned from hpesa_init()                         */
/*    ViString   queryRealCommand (in)                                       */
/*      The SCPI command string to be sent to the instrument.                */
/*    ViPReal64  realResult (out)                                            */
/*      The real returned from the instrument.                               */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_cmdReal64_Q
                        (ViSession  instrumentHandle,
                         ViString   queryRealCommand, 
                         ViPReal64  realResult)

{   
    ViStatus  errStatus;
    struct    hpesa_globals *thisPtr;
   
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(queryRealCommand, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(realResult, VI_ERROR_PARAMETER3)

    errStatus = delayVQueryf(instrumentHandle, "%s\n", "%lg%*t",
                                        queryRealCommand, realResult);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                          end hpesa_cmdReal64_Q                            */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_cmdReal64Arr_Q -                                                   */
/*    This entry point assumes that the return result is a arbitrary block.  */
/*    Do not use this entry point for ASCII values.  For that just get the   */
/*    data from _cmd_string_Q routine.                                       */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession  instrumentHandle (in)                                       */
/*      Instrument handle returned from hpesa_init()                         */
/*    ViString   realArrayCommand (in)                                       */
/*      The instrument command string to be sent to the instrument.          */
/*    ViInt32    realArraySize (in)                                          */
/*      The number of elements allocated to the results array.               */
/*    ViReal64   _VI_FAR realArrayResult[] (out)                             */
/*      Array of 64-bit reals - result from instrument.                      */
/*    ViPInt32   realArrayCount (out)                                        */
/*      The actual number of elements returned by the instrument             */
/*                                                                           */
/*  The function assumes that the data returned by the instrument has        */
/*    four components.                                                       */
/*    1 - An initial "#" taking one byte                                     */
/*    2 - A single ASCII digit indicating the size in bytes of a number      */
/*        which follows immediately.                                         */
/*    3 - A string number indicating the number of array elements to be      */
/*        returned by the instrument.                                        */
/*    4 - The arbitrary block being returned by the instrument.  In this     */
/*        case it is an array of 64-bit real numbers.                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_cmdReal64Arr_Q
                        (ViSession  instrumentHandle,
                         ViString   realArrayCommand, 
                         ViInt32    realArraySize,
                         ViReal64   _VI_FAR realArrayResult[],
                         ViPInt32   realArrayCount)


{
    ViStatus  errStatus ;
    ViUInt32  cnt;
    struct    hpesa_globals * thisPtr;
    char      lc[100];
    ViInt32   i;
    ViInt32   ArrSize;
    ViInt32   nbytes;
    char      _huge *Array;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_LONG_RANGE(realArraySize, hpesa_CMDREAL64ARR_Q_MIN, 
                                 hpesa_CMDREAL64ARR_Q_MAX, VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(realArrayCommand, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(realArrayResult, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(realArrayCount, VI_ERROR_PARAMETER5)

    errStatus = delayVPrintf(instrumentHandle, "%s\n", realArrayCommand);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
            
    errStatus = delayRead(instrumentHandle,(ViPBuf)lc, 1, &cnt);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    if (lc[0] != '#')
    {
        thisPtr->errNumber = VI_ERROR_INV_EXPR;
        return VI_ERROR_INV_EXPR;
    }
        

    errStatus = delayRead(instrumentHandle,(ViPBuf)lc, 1, &cnt);
    
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    nbytes = lc[0]-'0';

    if (nbytes)
    {
        errStatus = delayRead(instrumentHandle,(ViPBuf)lc, nbytes, &cnt);
        
        if (errStatus < VI_SUCCESS)
            return statusUpdate(instrumentHandle, thisPtr, errStatus);
    
        lc[cnt]='\0';
        ArrSize = atol(lc);
    }

    else /* indefinate */
        ArrSize = realArraySize*sizeof(ViReal64);

    Array = (char *)malloc(ArrSize ); 
    
    if (!Array)
    {
        thisPtr->errNumber = VI_ERROR_ALLOC;
        return VI_ERROR_ALLOC;
    }
    
    errStatus = delayRead(instrumentHandle,(ViPBuf)Array, ArrSize, &cnt);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    if (thisPtr->interfaceType == VI_INTF_GPIB)
        if (errStatus == VI_SUCCESS_MAX_CNT)
            viClear(instrumentHandle);
    
    ArrSize = cnt/sizeof(ViReal64);
    ArrSize = (ArrSize > realArraySize ) ? realArraySize : ArrSize;

    /*copy only as many as the user allows*/
    memcpy(realArrayResult, Array, (size_t)ArrSize*sizeof(ViReal64));

    free(Array);

    *realArrayCount=ArrSize;

    for (i = 0; i < *realArrayCount; i++)
        SWAP_FLOAT64(&realArrayResult[i]);

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                         end hpesa_cmdReal64Arr_Q                          */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*  hpesa_cmdRealCommaArray_Q -                                              */
/*    This function retrieves an array of comma-separated values from the    */
/*    instrument.  The user may need to place the instrument in ASCII format */
/*    via the "FORM ASC" command.                                            */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession  instrumentHandle                                            */
/*      Instrument handle returned from hpesa_init()                         */
/*    ViString   realCommaCommand                                            */
/*      The command string to be sent to the instrument.                     */
/*    ViInt32    realCommaArraySize                                          */
/*      The number of elements allocated for realCommaArrayResults           */
/*    ViReal64   _VI_FAR realCommaArrayResult[]                              */
/*      Returns an array of 64-bit real numbers received from the instrument.*/
/*    ViPInt32   realCommaValuesRead                                         */
/*      The actual number of values returned in realCommaArrayResults.       */
/*                                                                           */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_cmdRealCommaArray_Q
                        (ViSession instrumentHandle,
                         ViString realCommaCommand,
                         ViInt32 realCommaArraySize,
                         ViReal64 _VI_FAR realCommaArrayResult[],
                         ViPInt32 realCommaValuesRead)



{
    ViStatus  errStatus = VI_SUCCESS;
    struct    hpesa_globals * thisPtr;
    ViChar *buffer, *BegPoint, *EndPoint;
    ViInt32 BytesRead = 0;
    unsigned int BufferCount = 0;  // number of times the buffer's been allocated
    ViInt32 NumbersConverted = 0;
    const int BufSize = 1024;  // determines the number of bytes read from
                               // the instrument at a time
    GET_GLOBALS(instrumentHandle, thisPtr)

    // Error Checking
    CHK_LONG_RANGE(realCommaArraySize, hpesa_CMDREAL64ARR_Q_MIN, 
                                 hpesa_CMDREAL64ARR_Q_MAX, VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(realCommaCommand, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(realCommaArrayResult, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(realCommaValuesRead, VI_ERROR_PARAMETER5)

    errStatus = delayVPrintf(instrumentHandle, "%s\n", realCommaCommand);
    if (errStatus < VI_SUCCESS) return errStatus;

    buffer = (char *)malloc(BufSize);
    
    if(buffer == NULL)
        return VI_ERROR_ALLOC;

    BufferCount = 1;

    /*  Data retrieval loop */

    do
    {
        errStatus = viRead(instrumentHandle, 
                           &buffer[(BufferCount - 1) * BufSize], 
                           BufSize, 
                           &BytesRead);

        if (errStatus < VI_SUCCESS)   //error check
        {
            free(buffer);
            return errStatus;
        }

        else if (errStatus == VI_SUCCESS)  // all data read
        {
            // Should replace the \n in the buffer
            buffer[((BufferCount - 1) * BufSize) + BytesRead - 1] = '\0';
            break;
        }

        else   // more data remaining
        {
            buffer = (char *)realloc((char *)buffer, (++BufferCount * BufSize));
            if(buffer == NULL)
                return VI_ERROR_ALLOC;

        }

    }while(errStatus > VI_SUCCESS);

    BegPoint = buffer;

    // convert the characters to real numbers
    while(NumbersConverted < realCommaArraySize)
    {
        realCommaArrayResult[NumbersConverted++] = strtod(BegPoint, &EndPoint);

        if(errno == ERANGE)
        {
            free(buffer);
            return hpesa_INSTR_INV_ASCII_NUMBER;
        }

        if (*EndPoint == '\0')
            break;

        BegPoint = EndPoint + 1; /* update scan pointer, bumping past comma */
    }

    *realCommaValuesRead = NumbersConverted;

    free(buffer);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_cmdRealCommaArray_Q                        */
/*                                                                           */
/*****************************************************************************/
                         


/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                      FREQUENCY CONTROL FUNCTIONS                          |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_frequencySetStart -                                                */
/*    This function sets the spectrum analyzers start frequency.             */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64      startFrequency (in)                                      */
/*        - New start frequency in Hz                                        */
/*        - Range is checked by machine                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_frequencySetStart
                        (ViSession instrumentHandle, 
                         ViReal64  startFrequency)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    /*  Send the SCPI command with appropriately formated frequency */

    errStatus = delayVPrintf(instrumentHandle, "FREQ:STAR %.15gHZ\n", startFrequency);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_frequencySetStart()                        */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_frequencyGetStart -                                                */
/*    Retrieves the spectrum analyzers start frequency.                      */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViPReal64     startFrequency_Q (out)                                   */
/*        - Returned start frequency in Hz                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_frequencyGetStart
                        (ViSession instrumentHandle, 
                         ViPReal64 startFrequency_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(startFrequency_Q, VI_ERROR_PARAMETER2)

    /*  Send the SCPI command and retrieve the formatted frequency */

    errStatus = delayVQueryf(instrumentHandle, "FREQ:STAR?\n", 
                                        "%lg%*t", startFrequency_Q);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_frequencyGetStart()                        */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_frequencySetStop -                                                 */
/*    This function sets the spectrum analyzers stop frequency.              */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64      stopFrequency (in)                                       */
/*        - New stop frequency in Hz                                         */
/*        - Range is checked by machine                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_frequencySetStop
                        (ViSession instrumentHandle, 
                         ViReal64 stopFrequency)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    /*  Send the SCPI command with appropriately formated frequency */

    errStatus = delayVPrintf(instrumentHandle, 
                                        "FREQ:STOP %.15gHZ\n", stopFrequency);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_frequencySetStop()                         */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_frequencyGetStop -                                                 */
/*    Retrieves the spectrum analyzers stop frequency.                       */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViPReal64     stopFrequency_Q (out)                                    */
/*        - Returned stop frequency in Hz                                    */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_frequencyGetStop
                        (ViSession instrumentHandle, 
                         ViPReal64 stopFrequency_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(stopFrequency_Q, VI_ERROR_PARAMETER2)


    /*  Send the SCPI command and retrieve the formatted frequency */

    errStatus = delayVQueryf(instrumentHandle, "FREQ:STOP?\n",
                                        "%lg%*t", stopFrequency_Q);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_frequencyGetStop()                         */
/*                                                                           */
/*****************************************************************************/

/*****************************************************************************/
/*                                                                           */
/*  hpesa_frequencySetCenter -                                               */
/*    This function sets the spectrum analyzers center frequency.            */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64      centerFrequency (in)                                     */
/*        - New center frequency in Hz                                       */
/*        - Range is checked by machine                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_frequencySetCenter
                        (ViSession instrumentHandle, 
                         ViReal64 centerFrequency)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    /*  Send the SCPI command with appropriately formated frequency */

    errStatus = delayVPrintf(instrumentHandle, 
                                    "FREQ:CENT %.15gHZ\n", centerFrequency);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_frequencySetCenter()                       */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_frequencyGetCenter -                                               */
/*    Retrieves the spectrum analyzers center frequency.                     */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViPReal64     centerFrequency_Q (out)                                  */
/*        - Returned center frequency in Hz                                  */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_frequencyGetCenter
                        (ViSession instrumentHandle, 
                         ViPReal64 centerFrequency_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)
       CHK_NULL_POINTER(centerFrequency_Q, VI_ERROR_PARAMETER2)


    /*  Send the SCPI command and retrieve the formatted frequency */

    errStatus = delayVQueryf(instrumentHandle, "FREQ:CENT?\n", 
                                        "%lg%*t", centerFrequency_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_frequencyGetCenter()                       */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_frequencySetSpan -                                                 */
/*    This function sets the spectrum analyzers span frequency.              */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64      spanFrequency (in)                                       */
/*        - New span frequency in Hz                                         */
/*        - Range is checked by machine                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_frequencySetSpan
                        (ViSession instrumentHandle, 
                         ViReal64 spanFrequency)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    /*  Send the SCPI command with appropriately formated frequency */

    errStatus = delayVPrintf(instrumentHandle, 
                                    "FREQ:SPAN %.15gHZ\n", spanFrequency);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_frequencySetSpan()                         */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_frequencyGetSpan -                                                 */
/*    Retrieves the spectrum analyzers span frequency.                       */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViPReal64     spanFrequency_Q (out)                                    */
/*        - Returned span frequency in Hz                                    */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_frequencyGetSpan
                        (ViSession instrumentHandle, 
                         ViPReal64 spanFrequency_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(spanFrequency_Q, VI_ERROR_PARAMETER2)

    /*  Send the SCPI command and retrieve the formatted frequency */

    errStatus = delayVQueryf(instrumentHandle, 
                                "FREQ:SPAN?\n", "%lg%*t", spanFrequency_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_frequencyGetSpan()                         */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_frequencySetCenterStepSize-                                        */
/*    This function sets the spectrum analyzers center frequency step size.  */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64      centerFrequencyStepSize (in)                             */
/*        - New center frequency step size in Hz                             */
/*        - Range is checked by machine                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_frequencySetCenterStepSize
                        (ViSession instrumentHandle,
                         ViReal64 centerFrequencyStepSize)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    /*  Send the SCPI command with appropriately formated frequency */

    errStatus = delayVPrintf(instrumentHandle, 
                        "FREQ:CENT:STEP %.15gHZ\n", centerFrequencyStepSize);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                 end hpesa_frequencySetCenterStepSize()                    */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_frequencyStepCenter -                                              */
/*    Steps the spectrum analyzer's center frequency.                        */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16     centerFreqStepDir                                          */
/*        - Direction to step the center frequency.                          */
/*        - Range:  hpesa_STEP_UP through hpesa_STEP_LASTENUM                */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_frequencyStepCenter
                        (ViSession instrumentHandle,
                         ViInt16 centerFreqStepDir)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(centerFreqStepDir, hpesa_STEP_UP, hpesa_STEP_LASTENUM, 
                                                         VI_ERROR_PARAMETER2)

    /*  Send the SCPI command and retrieve the formatted frequency */

    switch(centerFreqStepDir)
    {
        case hpesa_STEP_UP:
            errStatus = delayVPrintf(instrumentHandle, "FREQ:CENT UP\n");
            break;
        case hpesa_STEP_DOWN:
            errStatus = delayVPrintf(instrumentHandle, "FREQ:CENT DOWN\n");
            break;
        default:
            return(statusUpdate(instrumentHandle, thisPtr, 
                                                       VI_ERROR_PARAMETER2));
    }
            
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_frequencyStepCenter()                      */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_frequencySetSpanZoom -                                             */
/*    Steps the spectrum analyzer's center frequency.                        */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16     spanZoomType                                               */
/*        - Executes one of three possible span changes                      */
/*        - Range:  hpesa_SPANFULL - sets frequency span to full             */
/*                  hpesa_SPANLAST - sets frequency span to previous span    */
/*                  hpesa_SPANZERO - sets frequency span to 0 Hz             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_frequencySetSpanZoom
                        (ViSession instrumentHandle,
                         ViInt16 spanZoomType)
{
    ViStatus  errStatus;
    ViChar SCPItemp[15];
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(spanZoomType, hpesa_SPANFULL, hpesa_SPAN_LASTENUM, 
                                                         VI_ERROR_PARAMETER2)

    /*  Send the SCPI command and retrieve the formatted frequency */

    switch(spanZoomType)
    {
        case hpesa_SPANFULL:
            strcpy(SCPItemp, "SPAN:FULL\n");
            break;
        case hpesa_SPANLAST:
            strcpy(SCPItemp, "SPAN:PREV\n");
            break;
        case hpesa_SPANZERO:
            strcpy(SCPItemp, "SPAN 0\n");
            break;
        default:
            return(statusUpdate(instrumentHandle, thisPtr, 
                                                      VI_ERROR_PARAMETER2));
    }

    errStatus = delayVPrintf(instrumentHandle, "FREQ:%s", SCPItemp);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_frequencyStepSpanZooom()                   */
/*                                                                           */
/*****************************************************************************/


/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                      AMPLITUDE CONTROL FUNCTIONS                          |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_amplitudeSetAttenuation() -                                        */
/*    This method sets the spectrum analyzer's RF Input Attenuator value     */
/*    Setting the amplitude attenuation with this function un-couples the    */
/*    attenuator from the amplitude reference level.  To couple the          */
/*    attenuation to the reference level, call the function                  */
/*    "hpesa_amplitudeSetAttenuationAuto".                                   */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64    amplitudeAttenuation (in)                                  */
/*        - Instrument new amplitude attenuation in dB                       */
/*        - Range is checked by machine.                                     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_amplitudeSetAttenuation
                        (ViSession instrumentHandle, 
                         ViReal64 amplitudeAttenuation)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    /*  Send the SCPI command to set the attenuation amplitude. */

    errStatus = delayVPrintf(instrumentHandle, 
                                    "POW:ATT %.15g\n", amplitudeAttenuation);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                    end hpesa_amplitudeSetAttenuation                      */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_amplitudeGetAttenuation() -                                        */
/*    This method gets the spectrum analyzer's RF Input Attenuator value.    */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViPReal64    amplitudeAttenuation_Q (out)                              */
/*        - Instrument's current amplitude attenuation in dB                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_amplitudeGetAttenuation
                        (ViSession instrumentHandle, 
                         ViPReal64 amplitudeAttenuation_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(amplitudeAttenuation_Q, VI_ERROR_PARAMETER2)

    /*  Send the SCPI command to retrieve the attenuation amplitude. */

    errStatus = delayVQueryf(instrumentHandle, "POW:ATT?\n", 
                                    "%lg%*t", amplitudeAttenuation_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                    end hpesa_amplitudeGetAttenuation                      */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_amplitudeSetAttenuationAuto() -                                    */
/*    This method sets the spectrum analyzer's RF Input Attenuator value to  */
/*    be set automatically by the instrument as determined by the amplitude  */
/*    reference level.                                                       */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_amplitudeSetAttenuationAuto
                        (ViSession instrumentHandle)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    /*  Send the SCPI command to set the attenuation amplitude. */

    errStatus = delayVPrintf(instrumentHandle, "POW:ATT:AUTO ON\n");
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                  end hpesa_amplitudeSetAttenuationAuto                    */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_amplitudeSetFormat() -                                             */
/*     This method sets the spectrum analyzer's display vertical scale       */
/*     format, as either logarithmic or linear.                              */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16     amplitudeFormat (in)                                       */
/*        - Instrument's new display vertical scale format.                  */
/*        - Range is enumerate, either hpesa_FORMAT_LOGARITHMIC or           */
/*          hpesa_FORMAT_LINEAR                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_amplitudeSetFormat
                        (ViSession instrumentHandle, 
                         ViInt16 amplitudeFormat)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(amplitudeFormat, hpesa_FORMAT_LOGARITHMIC, hpesa_FORMAT_LASTENUM,
                                                           VI_ERROR_PARAMETER2)

    /*  Send the SCPI command to set the attenuation amplitude. */

    switch (amplitudeFormat)
    {
        case hpesa_FORMAT_LOGARITHMIC:
            errStatus = delayVPrintf(instrumentHandle, 
                            "DISP:WIND:TRAC:Y:SPAC LOG\n", amplitudeFormat);
            break;
        case hpesa_FORMAT_LINEAR:
            errStatus = delayVPrintf(instrumentHandle, 
                            "DISP:WIND:TRAC:Y:SPAC LIN\n", amplitudeFormat);
            break;
        default:
            return(statusUpdate(instrumentHandle, thisPtr, 
                                                       VI_ERROR_PARAMETER2));
    }

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                    end hpesa_amplitudeSetFormat                           */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_amplitudeGetFormat() -                                             */
/*     This method gets the spectrum analyzer's amplitude format.            */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViPInt16     amplitudeFormat_Q (out)                                   */
/*        - Instrument's current amplitude format, either logarithmic or     */
/*          linear.  It should only return two possible values,              */
/*          hpesa_FORMAT_LOGARITHMIC or hpesa_FORMAT_LINEAR.                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_amplitudeGetFormat
                        (ViSession instrumentHandle, 
                         ViPInt16 amplitudeFormat_Q)
{
    ViStatus  errStatus;
    ViChar tempAmpFormat[80];
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(amplitudeFormat_Q, VI_ERROR_PARAMETER2)

    /*  Send the SCPI command to retrieve the amplitude format. */
    errStatus = hpesa_cmdString_Q(instrumentHandle, 
                                "DISP:WIND:TRAC:Y:SPAC?", 80, tempAmpFormat);

    /*-----------------------------------------------------------------------*
     |  Compare the results against known values.  Note:  Since strncmp()    |
     |  returns 0 if the two strings are equal, the ! is required in order   |
     |  to achieve the correct result.  Also note that the third possibility |
     |  should never occur; the machine should always return either LOG or   |
     |  LIN.                                                                 |
     *-----------------------------------------------------------------------*/

    if(errStatus >= VI_SUCCESS)
        if(!strncmp(tempAmpFormat,"LOG",3))
            *amplitudeFormat_Q = hpesa_FORMAT_LOGARITHMIC;
        else if (!strncmp(tempAmpFormat,"LIN",3))
            *amplitudeFormat_Q = hpesa_FORMAT_LINEAR;
        else
            return statusUpdate(instrumentHandle, thisPtr, 
                                            VI_ERROR_SYSTEM_ERROR);
    
    /*  Return, statusUpdate already having been handled in cmdString_Q */

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                    end hpesa_amplitudeGetFormat                           */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_amplitudeSetReferenceLevel() -                                     */
/*     This method sets the spectrum analyzer's amplitude reference level.   */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64     amplitudeRefLevel (in)                                    */
/*        - Instrument's new amplitude reference level in current amplitude  */
/*          display units.                                                   */
/*        - Range is checked by the machine.                                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_amplitudeSetReferenceLevel
                        (ViSession instrumentHandle, 
                         ViReal64 amplitudeRefLevel)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    /*  Send the SCPI command to set the reference level. */

    errStatus = delayVPrintf(instrumentHandle,
                 "DISP:WIND:TRAC:Y:RLEV %.15g\n", amplitudeRefLevel);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                    end hpesa_amplitudeSetReferenceLevel                   */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_amplitudeGetReferenceLevel() -                                     */
/*     This method retrieves the spectrum analyzer's amplitude reference     */
/*     level.                                                                */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViPReal64     amplitudeRefLevel_Q (out)                                */
/*        - Instrument's amplitude reference level in current amplitude      */
/*          display units.                                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_amplitudeGetReferenceLevel
                        (ViSession instrumentHandle, 
                         ViPReal64 amplitudeRefLevel_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(amplitudeRefLevel_Q, VI_ERROR_PARAMETER2)

    /*  Send the SCPI command to get the reference level. */

    errStatus = delayVQueryf(instrumentHandle, "DISP:WIND:TRAC:Y:RLEV?\n",
                                     "%lg%*t", amplitudeRefLevel_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                    end hpesa_amplitudeGetReferenceLevel                   */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_amplitudeSetRefLevelOffset() -                                     */
/*     This method sets the spectrum analyzer's amplitude reference level    */
/*     offset.                                                               */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64     amplitudeRefLevelOffset (in)                              */
/*        - Instrument's new amplitude reference level offset in dB.         */
/*        - Range is checked by the machine.                                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_amplitudeSetRefLevelOffset
                        (ViSession instrumentHandle,
                         ViReal64 amplitudeRefLevelOffset)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    /*  Send the SCPI command to set the reference level. */

    errStatus = delayVPrintf(instrumentHandle, 
               "DISP:WIND:TRAC:Y:RLEV:OFFS %.15g\n", amplitudeRefLevelOffset);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                    end hpesa_amplitudeSetRefLevelOffset()                 */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_amplitudeGetRefLevelOffset() -                                     */
/*     This method retrieves the spectrum analyzer's amplitude offset.       */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViPReal64     amplitudeRefLevelOffset_Q (out)                          */
/*        - Instrument's amplitude reference level in current amplitude      */
/*          display units.                                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_amplitudeGetRefLevelOffset
                        (ViSession instrumentHandle, 
                         ViPReal64 amplitudeRefLevelOffset_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(amplitudeRefLevelOffset_Q, VI_ERROR_PARAMETER2)

    /*  Send the SCPI command to get the reference level. */

    errStatus = delayVQueryf(instrumentHandle, "DISP:WIND:TRAC:Y:RLEV:OFFS?\n",
                             "%lg%*t", amplitudeRefLevelOffset_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                    end hpesa_amplitudeGetRefLevelOffset                   */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_amplitudeSetScale() -                                              */
/*     This method sets the spectrum analyzer's per division display scaling */
/*     for the y-axis (amplitude) logarithmic scale format (type).           */
/*     This setting doesn't affect the y-axis linear scale format, where the */
/*     per division display scaling is always the reference level divided    */
/*     10.                                                                   */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64     amplitudeScale (in)                                       */
/*        - Instrument's new per division display scaling for y-axis         */
/*          logarithmic scale.  Units are in dB.                             */
/*          Log amplitude per division range is:                             */
/*          0.1 dB for steps 0.1 to 0.9                                      */
/*          1.0 dB for steps 1.0 to 20.0                                     */
/*        - Range is checked by the machine.                                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_amplitudeSetScale
                        (ViSession instrumentHandle,
                         ViReal64 amplitudeScale)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    /*  Send the SCPI command to set the reference level. */

    errStatus = delayVPrintf(instrumentHandle, 
                             "DISP:WIND:TRAC:Y:PDIV %.15g\n", amplitudeScale);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                    end hpesa_amplitudeSetScale()                          */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_amplitudeGetScale() -                                              */
/*     This method retrieves the spectrum analyzer's per division display    */
/*     scaling for the y-axis (amplitude.  This setting is only applicable   */
/*     to y-axis (amplitude) logarithmic scale format.  This setting has no  */
/*     meaning for the linear scale format.                                  */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViPReal64     amplitudeScale_Q (out)                                   */
/*        Instruments current per division display scaling for y-axis in dB  */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_amplitudeGetScale
                        (ViSession instrumentHandle,
                         ViPReal64 amplitudeScale_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(amplitudeScale_Q, VI_ERROR_PARAMETER2)

    /*  Send the SCPI command to get the reference level. */

    errStatus = delayVQueryf(instrumentHandle, "DISP:WIND:TRAC:Y:PDIV?\n", 
                             "%lg%*t", amplitudeScale_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                    end hpesa_amplitudeGetScale                            */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_amplitudeSetUnits() -                                              */
/*     This method sets the spectrum analyzer's units for the input, output  */
/*     and display for the active window.                                    */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16      amplitudeUnits (in)                                       */
/*        - Instrument's new amplitude units.                                */
/*        - Enumerated:     dBm  -  hpesa_UNITS_DBM                          */
/*                          dBmV -  hpesa_UNITS_DBMV                         */
/*                          dBuV -  hpesa_UNITS_DBUV                         */
/*                          Volts - hpesa_UNITS_VOLTS                        */
/*                          Watts - hpesa_UNITS_WATTS                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_amplitudeSetUnits
                        (ViSession instrumentHandle,
                         ViInt16 amplitudeUnits)
{
    ViStatus  errStatus;
    ViChar amp_Units[5];
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(amplitudeUnits, hpesa_UNITS_DBM, hpesa_UNITS_LASTENUM, 
                                                         VI_ERROR_PARAMETER2)

    /*  Set up the string to send to the instrument based on amplitudeUnits. */

    switch(amplitudeUnits)
    {
        case hpesa_UNITS_DBM:
            strcpy(amp_Units,"DBM");
            break;
        case hpesa_UNITS_DBMV:
            strcpy(amp_Units,"DBMV");
            break;
        case hpesa_UNITS_DBUV:
            strcpy(amp_Units,"DBUV");
            break;
        case hpesa_UNITS_VOLTS:
            strcpy(amp_Units,"V");
            break;
        case hpesa_UNITS_WATTS:
            strcpy(amp_Units,"W");
            break;
        default:
            return(statusUpdate(instrumentHandle, thisPtr, 
                                                       VI_ERROR_PARAMETER2));
    }
            
    /*  Send the SCPI command along with the correct unit string. */

    errStatus = delayVPrintf(instrumentHandle, "UNIT:POW %s\n", amp_Units);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling statusUpdate */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                    end hpesa_amplitudeSetUnits()                          */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_amplitudeGetUnits() -                                              */
/*     This method gets the spectrum analyzer's amplitude units.             */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViPInt16     amplitudeUnits_Q (out)                                    */
/*        - Instrument's current amplitude units.                            */
/*                          dBm = 0                                          */
/*                         dBmV = 1                                          */
/*                         dBuV = 2                                          */
/*                        Volts = 3                                          */
/*                        Watts = 4                                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_amplitudeGetUnits
                        (ViSession instrumentHandle, 
                         ViPInt16 amplitudeUnits_Q)
{
    ViStatus  errStatus;
    ViChar tempAmpUnit[80];
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(amplitudeUnits_Q, VI_ERROR_PARAMETER2)

    /*  Send the SCPI command to retrieve the amplitude format. */
    errStatus = hpesa_cmdString_Q(instrumentHandle, "UNIT:POW?", 
                                                            80, tempAmpUnit);

    /*----------------------------------------------------------*
     |  Compare the results against known values.  Note:  Since |
     |  strncmp() returns 0 if the two strings are equal, the ! |
     |  is required in order to achieve the correct result.     |
     |  Also note that the longer strings are compared first to |
     |  ensure accurancy.                                       |
     *----------------------------------------------------------*/

    if(errStatus >= VI_SUCCESS)
        if (!strncmp(tempAmpUnit,"DBMV",4))
            *amplitudeUnits_Q = hpesa_UNITS_DBMV;
        else if (!strncmp(tempAmpUnit,"DBUV",4))
            *amplitudeUnits_Q = hpesa_UNITS_DBUV;
        else if(!strncmp(tempAmpUnit,"DBM",3))
            *amplitudeUnits_Q = hpesa_UNITS_DBM;
        else if (!strncmp(tempAmpUnit,"V",1))
            *amplitudeUnits_Q = hpesa_UNITS_VOLTS;
        else if (!strncmp(tempAmpUnit,"W",1))
            *amplitudeUnits_Q = hpesa_UNITS_WATTS;
        else
            return statusUpdate(instrumentHandle, thisPtr, 
                                                    VI_ERROR_SYSTEM_ERROR);
    
    /*  Return, statusUpdate already having been handled in cmdString_Q */

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                    end hpesa_amplitudeGetUnits                            */
/*                                                                           */
/*****************************************************************************/


/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                      BANDWIDTH CONTROL FUNCTIONS                          |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_BWSetResolution -                                                  */
/*    This method sets the spectrum analyzer's resolution bandwidth.         */
/*    Setting the resolution bandwidth un-couples the setting from the       */
/*    frequency span.                                                        */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64      BWResolution                                             */
/*        - Instrument's new resolution bandwidth in Hz                      */
/*        - Range checked by instrument                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_BWSetResolution
                        (ViSession instrumentHandle, 
                         ViReal64 BWResolution)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    errStatus = delayVPrintf(instrumentHandle, "BAND %.15gHZ\n", BWResolution);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_BWSetResolution                          */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_BWSetResolutionAuto() -                                            */
/*    This method sets the spectrum analyzer's resolution bandwidth mode     */
/*    to AUTO, where resolution bandwidth is coupled to the frequency span.  */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_BWSetResolutionAuto
                        (ViSession instrumentHandle)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    errStatus = delayVPrintf(instrumentHandle, "BAND:AUTO ON\n");
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_BWSetResolutionAuto                        */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_BWSetVideo -                                                       */
/*    This method sets the spectrum analyzer's video bandwidth.              */
/*    Setting the video bandwidth un-couples the setting from the            */
/*    resolution bandwidth.                                                  */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64      BWVideo                                                  */
/*        - Instrument's new video bandwidth in Hz                           */
/*        - Range checked by instrument                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_BWSetVideo
                        (ViSession instrumentHandle,
                         ViReal64 BWVideo)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    errStatus = delayVPrintf(instrumentHandle, "BAND:VID %.15gHZ\n", BWVideo);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                           end hpesa_BWSetVideo                            */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_BWSetVideoAuto -                                                   */
/*    This method sets the spectrum analyzer's video bandwidth mode to AUTO, */
/*    where video bandwidth is coupled to the resolution bandwidth.          */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64      BWVideo                                                  */
/*        - Instrument's new video bandwidth in Hz                           */
/*        - Range checked by instrument                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_BWSetVideoAuto
                        (ViSession instrumentHandle)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    errStatus = delayVPrintf(instrumentHandle, "BAND:VID:AUTO ON\n");
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                         end hpesa_BWSetVideoAuto                          */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_BWSetAverage -                                                     */
/*    This method sets the spectrum analyzer's average type and count.       */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16     BWAverageType (in)                                         */
/*        - Specifies the type of averaging to use.                          */
/*        - Enums:                                                           */
/*              hpesa_AVERAGE_LPOWER - logarithmically averages the power    */
/*                                     of the video data.                    */
/*              hpesa_AVERAGE_POWER  - averages the linear power of the      */
/*                                     successive measurements.              */
/*    ViInt32      BWAverageCount (in)                                       */
/*        - Specifies the number of measurements that are combined.          */
/*        - Range checked by instrument                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_BWSetAverage
                        (ViSession instrumentHandle,
                         ViInt16 BWAverageType,
                         ViInt32 BWAverageCount)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViChar SCPIBWAverageType[5];

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(BWAverageType, 0, hpesa_AVERAGE_LASTENUM, VI_ERROR_PARAMETER2)

    if (BWAverageType == hpesa_AVERAGE_LPOWER)
        strcpy(SCPIBWAverageType, "LPOW");
    else
        strcpy(SCPIBWAverageType, "POW");

    errStatus = delayVPrintf(instrumentHandle, 
                                    "AVER:TYPE %s\n", SCPIBWAverageType);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    errStatus = delayVPrintf(instrumentHandle, 
                                        "AVER:COUN %d\n", BWAverageCount);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                           end hpesa_BWSetAverage()                        */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_BWSetAverageOn -                                                   */
/*    This method sets the spectrum analyzer's averaging on or off.          */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViBoolean   BWAverageOn (in)                                           */
/*        - Instrument's new average state                                   */
/*        - Values: VI_TRUE (on) or VI_FALSE (off)                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_BWSetAverageOn
                        (ViSession instrumentHandle,
                         ViBoolean BWAverageOn)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_BOOLEAN(BWAverageOn, VI_ERROR_PARAMETER2)

    errStatus = delayVPrintf(instrumentHandle, "AVER %d\n", BWAverageOn);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                         end hpesa_BWSetAverageOn                          */
/*                                                                           */
/*****************************************************************************/


/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                        TRACE CONTROL FUNCTIONS                            |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_traceSetMode -                                                     */
/*    This method selects the spectrum analyzer's trace mode for the         */
/*    trace.                                                                 */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16 traceNumber (in)                                               */
/*        - Instrument trace number to modify                                */
/*        - Range:  hpesa_TRACE_1, hpesa_TRACE_2, hpesa_TRACE_3              */
/*    ViInt16 traceMode (in)                                                 */
/*        - Instrument's new trace mode:                                     */
/*              hpesa_TRACE_WRITE - Write puts the trace in the normal mode  */
/*                upholding the data.                                        */
/*              hpesa_TRACE_MAXHOLD - Maximum hold displays the highest      */
/*                measured trace value for all the data that has been        */
/*                measured since the function was turned on.                 */
/*              hpesa_TRACE_MINHOLD - Minimum hold displays the lowest       */
/*                measured trace value for all the data that has been        */
/*                measured since the function was turned on.                 */
/*              hpesa_TRACE_VIEW - View turns on the trace data so that it   */
/*                can be viued on the display.                               */
/*              hpesa_TRACE_BLANK - Blank turns off the trace data so that   */
/*                it is not viewed on the display.                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_traceSetMode
                        (ViSession instrumentHandle,
                         ViInt16 traceNumber,
                         ViInt16 traceMode)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViChar SCPItracemode[5];

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(traceNumber, 0, hpesa_TRACE_LASTENUM, VI_ERROR_PARAMETER2)
    CHK_ENUM(traceMode, 0, hpesa_TRACE_MODELASTENUM, VI_ERROR_PARAMETER3)

    // Adjust the enumeration to a valid value.
    traceNumber += 1;

    switch(traceMode)
    {
        case hpesa_TRACE_WRITE:    strcpy(SCPItracemode, "WRIT"); break;
        case hpesa_TRACE_MAXHOLD:  strcpy(SCPItracemode, "MAXH"); break;
        case hpesa_TRACE_MINHOLD:  strcpy(SCPItracemode, "MINH"); break;
        case hpesa_TRACE_VIEW:     strcpy(SCPItracemode, "VIEW"); break;
        case hpesa_TRACE_BLANK:    strcpy(SCPItracemode, "BLAN"); break;
        default:
            return(statusUpdate(instrumentHandle, thisPtr, 
                                                      VI_ERROR_PARAMETER3));
    }

    errStatus = delayVPrintf(instrumentHandle, "TRAC%d:MODE %s\n", 
                                            traceNumber, SCPItracemode);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                          end hpesa_traceSetMode                           */
/*                                                                           */
/*****************************************************************************/


/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                       TRIGGER CONTROL FUNCTIONS                           |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/

/*****************************************************************************/
/*                                                                           */
/*  hpesa_triggerSetSource -                                                 */
/*    This method selects the spectrum analyzer's source (or type) for       */
/*    triggering used to start a measurement.                                */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16     triggerSource                                              */
/*        - Instrument's new trigger source (or type)                        */
/*        - Values:                                                          */
/*                hpesa_TRIGGER_IMMEDIATE - free-run triggering              */
/*                hpesa_TRIGGER_VIDEO - triggers on the video signal         */
/*                hpesa_TRIGGER_EXTERNAL - triggers on the power line source */
/*                                         signal                            */
/*                hpesa_TRIGGER_LINE - connect an external trigger source    */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_triggerSetSource
                        (ViSession instrumentHandle,
                         ViInt16 triggerSource)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViChar SCPItriggerSource[5];

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(triggerSource, 0, hpesa_TRIGGER_LASTENUM, VI_ERROR_PARAMETER2)

    switch (triggerSource)
    {
        case hpesa_TRIGGER_IMMEDIATE:  strcpy(SCPItriggerSource, "IMM");
                                       break;
        case hpesa_TRIGGER_VIDEO:      strcpy(SCPItriggerSource, "VID");
                                       break;
        case hpesa_TRIGGER_EXTERNAL:   strcpy(SCPItriggerSource, "EXT");
                                       break;
        case hpesa_TRIGGER_LINE:       strcpy(SCPItriggerSource, "LINE");
                                       break;
        default:
            return(statusUpdate(instrumentHandle, thisPtr, 
                                                    VI_ERROR_PARAMETER2));
    }


    errStatus = delayVPrintf(instrumentHandle, "TRIG:SOUR %s\n", 
                                                        SCPItriggerSource);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_triggerSetSource                         */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_triggerSetVideoLevel -                                             */
/*    This method selects the spectrum analyzer's video trigger level for    */
/*    trigger source is set to video.                                        */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64    videoTriggerLevel                                          */
/*        - Instrument's new trigger level in current amplitude display      */
/*          units.                                                           */
/*        - Video bandwidth range checked by instrument                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_triggerSetVideoLevel
                        (ViSession instrumentHandle,
                         ViReal64 videoTriggerLevel)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    errStatus = delayVPrintf(instrumentHandle, 
                                    "TRIG:VID:LEV %lg\n", videoTriggerLevel);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                    end hpesa_triggerSetVideoLevel                         */
/*                                                                           */
/*****************************************************************************/


/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                        SWEEP CONTROL FUNCTIONS                            |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_sweepSetMode -                                                     */
/*    This method selects whether the trigger system is continuously         */
/*    initiated or not.  This corresponds to continuous measurement or single*/
/*    measurement operation.  When set to ON, at the completion of each      */
/*    trigger cycle, the trigger system immediately initiates another        */
/*    trigger cycle.  When set to OFF, the trigger system remains in "idle"  */
/*    state until continuous is set to ON or an INITiate[:IMMediate] command */
/*    is received.  On receiving the INITiate[IMMediate] command, it will    */
/*    go through a single trigger cycle and then return to the "idle" state. */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16     sweepMode                                                  */
/*        - Instrument's new sweep mode                                      */
/*        - Values:                                                          */
/*                hpesa_SWEEP_TRIGGER_SINGLE - single sweep mode             */
/*                hpesa_SWEEP_TRIGGER_CONTINUOUS - continuous sweep mode     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_sweepSetMode
                        (ViSession instrumentHandle,
                         ViInt16 sweepMode)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(sweepMode, 0, hpesa_SWEEP_TRIGGER_LASTENUM, VI_ERROR_PARAMETER2)

    errStatus = delayVPrintf(instrumentHandle, "INIT:CONT %d\n", sweepMode);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_sweepSetMode                             */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_sweepGetMode -                                                     */
/*    This method gets the spectrum analyzer's sweep mode.                   */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViPInt16     sweepMode_Q (out)                                         */
/*        - Instrument's current trigger source                              */
/*             0 = hpesa_SWEEP_TRIGGER_SINGLE                                */
/*             1 = hpesa_SWEEP_TRIGGER_CONTINUOUS                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_sweepGetMode
                        (ViSession instrumentHandle,
                         ViPInt16 sweepMode_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(sweepMode_Q, VI_ERROR_PARAMETER2)

    errStatus = delayVQueryf(instrumentHandle, "INIT:CONT?\n", 
                                                    "%hd%*t", sweepMode_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  No conversion necessary, so return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_sweepGetMode                             */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_sweepSetTime -                                                     */
/*    This method specifies the time in which the instrument sweeps the      */
/*    displayed frequency range.                                             */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64    sweepTime                                                  */
/*        - Instrument's new sweep time in seconds                           */
/*        - Range checked by instrument                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_sweepSetTime
                        (ViSession instrumentHandle, 
                         ViReal64 sweepTime)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    errStatus = delayVPrintf(instrumentHandle, "SWE:TIME %.15g\n", sweepTime);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_sweepSetTime                             */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_sweepGetTime -                                                     */
/*    This method gets the spectrum analyzer's sweep time.                   */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViPReal64   sweepTime_Q (out)                                          */
/*        - Instrument's current sweep time in secs.                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_sweepGetTime
                        (ViSession instrumentHandle,
                         ViPReal64 sweepTime_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(sweepTime_Q, VI_ERROR_PARAMETER2)

    errStatus = delayVQueryf(instrumentHandle, "SWE:TIME?\n", 
                                                    "%lg%*t", sweepTime_Q);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_sweepGetTime                             */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_sweepSetTimeAuto -                                                 */
/*    This method sets the spectrum analyzer's sweep time to AUTO, where     */
/*    sweep time is coupled to the frequency span, resolution bandwidth      */
/*    and video bandwidth.                                                   */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_sweepSetTimeAuto
                        (ViSession instrumentHandle)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    errStatus = delayVPrintf(instrumentHandle, "SWE:TIME:AUTO ON\n");
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_sweepSetTimeAuto                           */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_sweepDoSweep -                                                     */
/*    This method causes a sweep to start and waits for it complete.  If     */
/*    sweep mode is continuous, the sweep will be re-started.  If sweep is   */
/*    single then the sweep is started.                                      */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64    sweepTimeOut (in)                                          */
/*        -Time in seconds for this method to wait for the sweep to complete */
/*        -Range - 0 to hpesa_TIMEOUT_MAX                                    */
/*    ViPBoolean  sweepComplete (out)                                        */
/*        -Status indicating whether sweep completed successfully.           */
/*             0 - VI_FALSE                                                  */
/*             1 - VI_TRUE                                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_sweepDoSweep
                        (ViSession instrumentHandle,
                         ViReal64 sweepTimeOut,
                         ViPBoolean sweepComplete)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViInt32 oldTimeOut;

    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_REAL_RANGE(sweepTimeOut, 0, hpesa_TIMEOUT_MAX, VI_ERROR_PARAMETER2);
    CHK_NULL_POINTER(sweepComplete, VI_ERROR_PARAMETER3)

    *sweepComplete = VI_FALSE;

     /*----------------------------------------------------------------*
      |  First, retrieve the current timeout setting, since we are     |
      |  going to be changing that setting for this function.          |
      *----------------------------------------------------------------*/

    errStatus = hpesa_timeOut_Q(instrumentHandle, &oldTimeOut);
    if (errStatus < VI_SUCCESS)
        return errStatus;

     /*----------------------------------------------------------------*
      |  Next, set the timeout for this function.                      |
      *----------------------------------------------------------------*/

    errStatus = hpesa_timeOut(instrumentHandle, (ViInt32)(sweepTimeOut*1000));
    if (errStatus < VI_SUCCESS)
        return  errStatus;

     /*----------------------------------------------------------------*
      |  Send the first SCPI command, stopping any measurements in     |
      |  progress.                                                     |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "ABOR\n");
    if (errStatus < VI_SUCCESS)
    {
        hpesa_timeOut(instrumentHandle, oldTimeOut);
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
    }

     /*----------------------------------------------------------------*
      |  Send the second SCPI, initiating the sweep.                   |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "INIT\n");
    if (errStatus < VI_SUCCESS)
    {
        hpesa_timeOut(instrumentHandle, oldTimeOut);//reset timeout to default
        return errStatus;
    }

     /*----------------------------------------------------------------*
      |  Check to see if the operation completed.                      |
      *----------------------------------------------------------------*/

    errStatus = hpesa_opc_Q(instrumentHandle, sweepComplete);
    if (errStatus < VI_SUCCESS)
    {
        hpesa_timeOut(instrumentHandle, oldTimeOut);//reset timeout to default
        return errStatus;
    }

     /*----------------------------------------------------------------*
      |  Reset timeout to default before exiting the function.         |
      *----------------------------------------------------------------*/

    
    errStatus = hpesa_timeOut(instrumentHandle, oldTimeOut); 
    if (errStatus < VI_SUCCESS)
        return errStatus;

    /*  Return by calling updateStatus */
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_sweepDoSweep                             */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_sweepStartSweep -                                                  */
/*    This method causes a sweep to start.  It doesn't wait for the sweep to */
/*    complete.  If the sweep mode is continuous, the sweep will be restarted*/
/*    If sweep is single, then the sweep is started.                         */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_sweepStartSweep
                        (ViSession instrumentHandle)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    errStatus = delayVPrintf(instrumentHandle, "INIT\n");
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_sweepStartSweep                            */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_sweepAbortSweep -                                                  */
/*    This method stops any measurement in progress and resets the trigger   */
/*    system.  If the sweep mode is in single measure mode, then a           */
/*    "hpesa_sweepStartSweep" will start a new measurement.  If sweep mode   */
/*    is in continuous measure mode, then a new measurement begins           */
/*    immediately.                                                           */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_sweepAbortSweep
                        (ViSession instrumentHandle)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    errStatus = delayVPrintf(instrumentHandle, "ABOR\n");
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_sweepAbortSweep                            */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_sweepWaitForSweepComplete -                                        */
/*    This method causes a sweep to complete.                                */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64    sweepWaitTimeOut (in)                                      */
/*        -Time in seconds for this method to wait for the sweep to complete */
/*        -Range - 0 to hpesa_TIMEOUT_MAX                                    */
/*    ViPBoolean  sweepWaitComplete (out)                                    */
/*        -Status indicating whether sweep completed successfully.           */
/*             0 - VI_FALSE                                                  */
/*             1 - VI_TRUE                                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_sweepWaitForSweepComplete
                        (ViSession instrumentHandle,
                         ViReal64 sweepWaitTimeOut, 
                         ViPBoolean sweepWaitComplete)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViInt32 oldTimeOut;

    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_REAL_RANGE(sweepWaitTimeOut, 0, hpesa_TIMEOUT_MAX, 
                                                        VI_ERROR_PARAMETER2);
    CHK_NULL_POINTER(sweepWaitComplete, VI_ERROR_PARAMETER3)

    *sweepWaitComplete = VI_FALSE;

     /*----------------------------------------------------------------*
      |  First, retrieve the current timeout setting, since we are     |
      |  going to be changing that setting for this function.          |
      *----------------------------------------------------------------*/

    errStatus = hpesa_timeOut_Q(instrumentHandle, &oldTimeOut);
    if (errStatus < VI_SUCCESS)
        return errStatus;

     /*----------------------------------------------------------------*
      |  Next, set the timeout for this function.                      | 
      *----------------------------------------------------------------*/

    errStatus = hpesa_timeOut(instrumentHandle, 
                              (ViInt32)(sweepWaitTimeOut * 1000));
    if (errStatus < VI_SUCCESS)
        return  errStatus;

     /*----------------------------------------------------------------*
      |  Check to see if the operation completed.                      | 
      *----------------------------------------------------------------*/

    errStatus = hpesa_opc_Q(instrumentHandle, sweepWaitComplete);
    if (errStatus < VI_SUCCESS)
    {
        hpesa_timeOut(instrumentHandle, oldTimeOut);//reset timeout to default
        return errStatus;
    }

     /*----------------------------------------------------------------*
      |  Reset timeout to default before exiting the function.         |
      *----------------------------------------------------------------*/

    errStatus = hpesa_timeOut(instrumentHandle, oldTimeOut);
    if (errStatus < VI_SUCCESS)
        return errStatus;

    /*  Return  */
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                     end hpesa_sweepWaitForSweepComplete                   */
/*                                                                           */
/*****************************************************************************/


/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                       MARKER CONTROL FUNCTIONS                            |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_markerSetMode -                                                    */
/*     This method selects the type of markers to activate.                  */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16     modeMarkerNumber                                           */
/*        - Marker number to select.                                         */
/*        - Values:                                                          */
/*            hpesa_MARKER_1 (default) - Marker 1                            */
/*            hpesa_MARKER_2 - Marker 2                                      */
/*            hpesa_MARKER_3 - Marker 3                                      */
/*            hpesa_MARKER_4 - Marker 4                                      */
/*    ViInt16     markerMode                                                 */
/*        - Instrument's new marker mode                                     */
/*        - Values:                                                          */
/*             hpesa_MARKER_NORMAL - selects a normal type of marker that    */
/*               you can position on a trace and readout the exact trace     */
/*               information.                                                */
/*             hpesa_MARKER_DELTA - activates a pair of delta markers, one   */
/*               of which is fixed at the current marker location.  The      */
/*               marker can then be moved around on the trace and the marker */
/*               readout shows the difference between two markers.           */
/*             hpesa_MARKER_BAND - activates a pair of band markers, where   */
/*               each marker can be independently positioned on the trace.   */
/*               The marker readout shows the difference between the two     */
/*               markers.                                                    */
/*             hpesa_MARKER_SPAN - activates a pair of span markers, where   */
/*               the marker positioning is controlled by changing the span   */
/*               and/or center frequency between the two markers.  The       */
/*               marker readout shows the difference between the two         */
/*               markers.                                                    */
/*             hpesa_MARKER_MODEOFF - turns specified marker off             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_markerSetMode
                        (ViSession instrumentHandle,
                         ViInt16 modeMarkerNumber,
                         ViInt16 markerMode)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViChar SCPImarkerMode[10];

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(modeMarkerNumber, 0, hpesa_MARKER_NUM_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)
    CHK_ENUM(markerMode, 0, hpesa_MARKER_MODE_LASTENUM, VI_ERROR_PARAMETER3)

    // Adjust the marker number from the enumeration.
    modeMarkerNumber += 1;

    switch(markerMode)
    {
        case hpesa_MARKER_NORMAL:  strcpy(SCPImarkerMode, "MODE POS"); break;
        case hpesa_MARKER_DELTA:   strcpy(SCPImarkerMode, "MODE DELT"); break;
        case hpesa_MARKER_BAND:    strcpy(SCPImarkerMode, "MODE BAND"); break;
        case hpesa_MARKER_SPAN:    strcpy(SCPImarkerMode, "MODE SPAN"); break;
        case hpesa_MARKER_MODEOFF: strcpy(SCPImarkerMode, "STAT OFF"); break;
        default:
            return(statusUpdate(instrumentHandle, thisPtr, 
                                                        VI_ERROR_PARAMETER3));
    }

    errStatus = delayVPrintf(instrumentHandle, "CALC:MARK%d:%s\n",
                                        modeMarkerNumber, SCPImarkerMode);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_markerSetMode                            */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_markerPeakSearch -                                                 */
/*     This method uses the spectrum analyzer's marker peak search function. */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16     peakSearchMarkerNumber                                     */
/*        - Marker number to select.                                         */
/*        - Values:                                                          */
/*            hpesa_MARKER_1 - Marker 1                                      */
/*            hpesa_MARKER_2 - Marker 2                                      */
/*            hpesa_MARKER_3 - Marker 3                                      */
/*            hpesa_MARKER_4 - Marker 4                                      */
/*    ViInt16     peakSearchType                                             */
/*        - Marker search type to execute.  Note:    Instrument's peak       */
/*          search algorithm for PEAKNEXT, NEXTLEFT, and NEXTRIGHT is        */
/*          dependant on marker threshold and excursion value set.           */
/*        - Values:                                                          */
/*            hpesa_MARKER_PEAK - Places the selected marker on the highest  */
/*              point on the trace that is assigned to that particular       */
/*              marker number.                                               */
/*            hpesa_MARKER_PEAKNEXT - Places the selected marker on the next */
/*              highest signal peak from the current marked peak.            */
/*            hpesa_MARKER_PEAKLEFT - Places the selected marker on the next */
/*              highest signal peak to the left of the current marked peak.  */
/*            hpesa_MARKER_PEAKRIGHT - Places the selected marker on the     */
/*              next highest signal peak to the right of the current marked  */
/*              peak.                                                        */
/*            hpesa_MARKER_MIN - Places the selected marker on the lowest    */
/*              point on the trace that is assigned to that particular       */
/*              marker number.                                               */  
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_markerPeakSearch
                        (ViSession instrumentHandle,
                         ViInt16 peakSearchMarkerNumber, 
                         ViInt16 peakSearchType)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViChar SCPIpeakSearchType[10];

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(peakSearchMarkerNumber, 0, hpesa_MARKER_NUM_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)
    CHK_ENUM(peakSearchType, 0, hpesa_MARKER_PEAK_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)

    // Adjust the marker number from the enumeration.
    peakSearchMarkerNumber += 1;

    switch(peakSearchType)
    {
        case hpesa_MARKER_PEAK:       strcpy(SCPIpeakSearchType, "MAX"); 
                                      break;
        case hpesa_MARKER_PEAKNEXT:   strcpy(SCPIpeakSearchType, "MAX:NEXT");
                                      break;
        case hpesa_MARKER_PEAKLEFT:   strcpy(SCPIpeakSearchType, "MAX:LEFT"); 
                                      break;
        case hpesa_MARKER_PEAKRIGHT:  strcpy(SCPIpeakSearchType, "MAX:RIGH"); 
                                      break;
        case hpesa_MARKER_MIN:        strcpy(SCPIpeakSearchType, "MIN");
                                      break;
        default:
            return(statusUpdate(instrumentHandle, thisPtr, 
                                                      VI_ERROR_PARAMETER3));
    }

    errStatus = delayVPrintf(instrumentHandle, "CALC:MARK%d:%s\n", 
                                peakSearchMarkerNumber, SCPIpeakSearchType);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_markerPeakSearch                           */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_markerToMarker -                                                   */
/*     This method sets the spectrum analyzer's selected instrument state to */
/*     the selected marker.                                                  */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16     markerNumberTo                                             */
/*        - Marker number to select.                                         */
/*        - Values:                                                          */
/*            hpesa_MARKER_1 - Marker 1                                      */
/*            hpesa_MARKER_2 - Marker 2                                      */
/*            hpesa_MARKER_3 - Marker 3                                      */
/*            hpesa_MARKER_4 - Marker 4                                      */
/*    ViInt16     instStateToMarker                                          */
/*        - Instrument's marker peak function to select.                     */
/*        - Values:                                                          */
/*            hpesa_MARKER_CENTERFREQ - Sets the center frequency equal to   */
/*              the specified marker's frequency, which moves the marker     */
/*              to the center of the screen.                                 */
/*            hpesa_MARKER_CENTERFREQSTEP - Sets the center frequency step   */
/*              equal to the specified marker's frequency.                   */
/*            hpesa_MARKER_SPANFREQ - Sets the span to the value of the      */
/*              specified marker's frequency.  The specified marker must     */
/*              in delta mode.  Select the delta marker mode with            */
/*              hpesa_markerSetMode function.                                */
/*            hpesa_MARKER_STARTFREQ - Sets the start frequency to the value */
/*              of the specified marker's frequency.                         */
/*            hpesa_MARKER_STOPFREQ - Sets the stop frequency to the value   */
/*              of the specified marker's frequency.                         */
/*            hpesa_MARKER_REFLEVEL - Sets the reference level to the        */
/*              specified marker's amplitude.                                */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_markerToMarker
                        (ViSession instrumentHandle,
                         ViInt16 markerNumberTo,
                         ViInt16 instStateToMarker)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViChar SCPIinstStateToMarker[10];

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(markerNumberTo, 0, hpesa_MARKER_NUM_LASTENUM, VI_ERROR_PARAMETER2)
    CHK_ENUM(instStateToMarker, 0, hpesa_MARKER_MOVE_LASTENUM, 
                                                           VI_ERROR_PARAMETER3)

    // Adjust the marker number from the enumeration.
    markerNumberTo += 1;
                                                           
    switch(instStateToMarker)
    {
      case hpesa_MARKER_CENTERFREQ:     strcpy(SCPIinstStateToMarker, "CENT");
                                          break;
      case hpesa_MARKER_CENTERFREQSTEP: strcpy(SCPIinstStateToMarker, "STEP");
                                          break;
      case hpesa_MARKER_SPANFREQ:       strcpy(SCPIinstStateToMarker, "SPAN"); 
                                          break;
      case hpesa_MARKER_STARTFREQ:      strcpy(SCPIinstStateToMarker, "STAR"); 
                                          break;
      case hpesa_MARKER_STOPFREQ:       strcpy(SCPIinstStateToMarker, "STOP"); 
                                          break;
      case hpesa_MARKER_REFLEVEL:       strcpy(SCPIinstStateToMarker, "RLEV"); 
                                          break;
      default:
          return(statusUpdate(instrumentHandle, thisPtr, VI_ERROR_PARAMETER3));
    }

    errStatus = delayVPrintf(instrumentHandle, "CALC:MARK%d:%s\n", 
                                    markerNumberTo, SCPIinstStateToMarker);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_markerToMarker                             */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_markerSetSignalTrackOn -                                           */
/*     This method turns on or off marker signal tracking.  When enabled, it */
/*     continuously puts the selected marker on the highest displayed signal */
/*     peak and moves it to the center frequency.                            */
/*     Only one marker at a time can be enable for signal tracking.          */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16     signalTrackMarkerNumber                                    */
/*        - Marker number to select.                                         */
/*        - Values:                                                          */
/*            hpesa_MARKER_1 - Marker 1                                      */
/*            hpesa_MARKER_2 - Marker 2                                      */
/*            hpesa_MARKER_3 - Marker 3                                      */
/*            hpesa_MARKER_4 - Marker 4                                      */
/*    ViInt16     markerSignalTrackOn                                        */
/*        - Select marker signal tracking on (VI_TRUE) or off (VI_FALSE).    */
/*        - Values:                                                          */
/*            VI_TRUE - On                                                   */
/*            VI_FALSE - OFF                                                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_markerSetSignalTrackOn
                        (ViSession instrumentHandle,
                         ViInt16 signalTrackMarkerNumber,
                         ViBoolean markerSignalTrackOn)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(signalTrackMarkerNumber, 0, hpesa_MARKER_NUM_LASTENUM,
                                                        VI_ERROR_PARAMETER2)
    CHK_BOOLEAN(markerSignalTrackOn, VI_ERROR_PARAMETER3)

    // Adjust the marker number from the enumeration.
    signalTrackMarkerNumber += 1;

    errStatus = delayVPrintf(instrumentHandle, "CALC:MARK%d:TRCK %d\n", 
                                signalTrackMarkerNumber, markerSignalTrackOn);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                   end hpesa_markerSetSignalTrackOn                        */
/*                                                                           */
/*****************************************************************************/




/*****************************************************************************/
/*                                                                           */
/*  hpesa_markerGetYValue -                                                  */
/*     This method measures the current Y value for the designated marker    */
/*     on its assigned trace.  The value is in the Y-axis units for the      */
/*     current trace (which is often dBm).                                   */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16     yValueMarkerNumber                                         */
/*        - Marker number to select.                                         */
/*        - Values:                                                          */
/*            hpesa_MARKER_1 - Marker 1                                      */
/*            hpesa_MARKER_2 - Marker 2                                      */
/*            hpesa_MARKER_3 - Marker 3                                      */
/*            hpesa_MARKER_4 - Marker 4                                      */
/*    ViPReal64    markerYValue_Q                                            */
/*        - Current Y axis value in the Y-axis units for the current trace   */
/*          (which is often dBm).                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_markerGetYValue
                        (ViSession instrumentHandle,
                         ViInt16 yValueMarkerNumber,
                         ViPReal64 markerYValue_Q)
{
    ViStatus  errStatus;
    ViChar buffer[80];
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(yValueMarkerNumber, 0, hpesa_MARKER_NUM_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)
       CHK_NULL_POINTER(markerYValue_Q, VI_ERROR_PARAMETER3)

    // Adjust the marker number from the enumeration.
    yValueMarkerNumber += 1;

    sprintf(buffer, "CALC:MARK%d:Y?\n", yValueMarkerNumber);

    errStatus = delayVQueryf(instrumentHandle, buffer, 
                                            "%lg%*t", markerYValue_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                       end hpesa_markerGetYValue                           */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_markerGetXPosition -                                               */
/*     This method measures the current X position for the designated marker.*/
/*     A trace is composed of 401 display points (X positions); therefore,   */
/*     the range of values that can be returned is 0 to 400.                 */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16     xPositionMarkerNumberQ                                     */
/*        - Marker number to measure the X position.                         */
/*        - Values:                                                          */
/*            hpesa_MARKER_1 - Marker 1                                      */
/*            hpesa_MARKER_2 - Marker 2                                      */
/*            hpesa_MARKER_3 - Marker 3                                      */
/*            hpesa_MARKER_4 - Marker 4                                      */
/*    ViPInt16    markerXPosition_Q                                          */
/*        - Current X axis position.  Range of 0 to 400 for the 401 point    */
/*          display.                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_markerGetXPosition
                        (ViSession instrumentHandle,
                         ViInt16 xPositionMarkerNumberQ,
                         ViPInt16 markerXPosition_Q)
{
    ViStatus  errStatus;
    ViChar buffer[80];
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(xPositionMarkerNumberQ, 0, hpesa_MARKER_NUM_LASTENUM,
                                                        VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(markerXPosition_Q, VI_ERROR_PARAMETER3)

    // Adjust the marker number from the enumeration.
    xPositionMarkerNumberQ += 1;

    sprintf(buffer, "CALC:MARK%d:X:POS?\n", xPositionMarkerNumberQ);

    errStatus = delayVQueryf(instrumentHandle, buffer, 
                                        "%ld%*t", markerXPosition_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_markerGetXPosition                         */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_markerSetXPosition -                                               */
/*     This method positions the designated marker on its assigned trace at  */
/*     the specified X position.  A trace is composed of 401 display points  */
/*     (X positions).  If the marker selected is not active, it will         */
/*     activate the marker.                                                  */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16     xPositionMarkerNumber                                      */
/*        - Marker number to measure the X position.                         */
/*        - Values:                                                          */
/*            hpesa_MARKER_1 - Marker 1                                      */
/*            hpesa_MARKER_2 - Marker 2                                      */
/*            hpesa_MARKER_3 - Marker 3                                      */
/*            hpesa_MARKER_4 - Marker 4                                      */
/*    ViInt32     markerXPosition                                            */
/*        - X axis position to which the specified marker will be moved.     */
/*          Range of 0 to 400 for the 401 point display.                     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_markerSetXPosition
                        (ViSession instrumentHandle,
                         ViInt16 xPositionMarkerNumber,
                         ViInt32 markerXPosition)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViBoolean MarkerOn;
    ViChar buffer[25];

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(xPositionMarkerNumber, 0, hpesa_MARKER_NUM_LASTENUM, 
                                                    VI_ERROR_PARAMETER2)

    // Adjust the marker number from the enumeration.
    xPositionMarkerNumber += 1;

    sprintf(buffer, "CALC:MARK%d:STAT?\n", xPositionMarkerNumber);

     /*----------------------------------------------------------------*
      |  Find out the current state of the selected marker.            |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, buffer, "%ld%*t", &MarkerOn);

     /*----------------------------------------------------------------*
      |  If the current marker isn't on, turn it on.                   |
      *----------------------------------------------------------------*/

    if(!MarkerOn)
        delayVPrintf(instrumentHandle,
                        "CALC:MARK%d:MODE POS\n", xPositionMarkerNumber);

    errStatus = delayVPrintf(instrumentHandle, "CALC:MARK%d:X:POS %d\n", 
                             xPositionMarkerNumber, markerXPosition);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_markerSetXPosition                         */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_markerGetXValue -                                                  */
/*     This method measures the current X value of the designated marker     */
/*     on its assigned trace.  The value is in the X-axis units for the      */
/*     trace (which is often frequency (Hz) or time (secs)).                 */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16     xValueMarkerNumber                                         */
/*        - Marker number to measure.                                        */
/*        - Values:                                                          */
/*            hpesa_MARKER_1 - Marker 1                                      */
/*            hpesa_MARKER_2 - Marker 2                                      */
/*            hpesa_MARKER_3 - Marker 3                                      */
/*            hpesa_MARKER_4 - Marker 4                                      */
/*    ViPReal64    markerXValue_Q                                            */
/*        - Current X axis value in the X-axis units for the current trace   */
/*          (which is often Hz or secs)                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_markerGetXValue
                        (ViSession instrumentHandle,
                         ViInt16 xValueMarkerNumber,
                         ViPReal64 markerXValue_Q)
{
    ViStatus  errStatus;
    ViChar buffer[80];
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(xValueMarkerNumber, 0, hpesa_MARKER_NUM_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(markerXValue_Q, VI_ERROR_PARAMETER3)

    // Adjust the marker number from the enumeration.
    xValueMarkerNumber += 1;

    sprintf(buffer, "CALC:MARK%d:X?\n", xValueMarkerNumber);

    errStatus = delayVQueryf(instrumentHandle, buffer, 
                                        "%lg%*t", markerXValue_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_markerGetXValue                          */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_markerSetFunction -                                                */
/*     This method selects the marker function for the specified marker.     */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16     functionMarkerNumber                                       */
/*        - Marker number to select.                                         */
/*        - Values:                                                          */
/*            hpesa_MARKER_1 - Marker 1                                      */
/*            hpesa_MARKER_2 - Marker 2                                      */
/*            hpesa_MARKER_3 - Marker 3                                      */
/*            hpesa_MARKER_4 - Marker 4                                      */
/*    ViInt16     markerFunction                                             */
/*        - Selects the marker function.                                     */
/*        - Values:                                                          */
/*            hpesa_MARKER_BPOWER - selects power integrated within the      */
/*              bandwidth marker function.                                   */
/*            hpesa_MARKER_NOISE - selects noise measurement marker function */
/*            hpesa_MARKER_FUNCOFF - turns off marker function mode.         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_markerSetFunction
                       (ViSession instrumentHandle,
                        ViInt16 functionMarkerNumber,
                        ViInt16 markerFunction)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViChar SCPImarkerFunction[5];

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(functionMarkerNumber, 0, hpesa_MARKER_NUM_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)
    CHK_ENUM(markerFunction, 0, hpesa_MARKER_FUNC_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)

    // Adjust the marker number from the enumeration.
    functionMarkerNumber += 1;

    switch(markerFunction)
    {
        case hpesa_MARKER_BPOWER:  strcpy(SCPImarkerFunction, "BPOW"); break;
        case hpesa_MARKER_NOISE:   strcpy(SCPImarkerFunction, "NOIS"); break;
        case hpesa_MARKER_FUNCOFF: strcpy(SCPImarkerFunction, "OFF"); break;
        default:
          return(statusUpdate(instrumentHandle, thisPtr, VI_ERROR_PARAMETER3));
    }

    errStatus = delayVPrintf(instrumentHandle, "CALC:MARK%d:FUNC %s\n", 
                             functionMarkerNumber, SCPImarkerFunction);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                       end hpesa_markerSetFunction                         */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_markerSetPeakExcursion -                                           */
/*     This method specifies the minimum signal excursion for the analyzer's */
/*     internal peak identification routine to recognize a signal as a peak. */
/*     This applies to all traces.  (The excursion is the delta power from   */
/*     a trace minimum value before (or after) a trace maximum value.)       */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64    peakExcursionLevel                                         */
/*        - Excursion delta power level in dB.                               */
/*        - Values:   Range checked by instrument.                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_markerSetPeakExcursion
                        (ViSession instrumentHandle,
                         ViReal64 peakExcursionLevel)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    errStatus = delayVPrintf(instrumentHandle, "CALC:MARK:PEAK:EXC %.15g\n", 
                             peakExcursionLevel);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                       end hpesa_markerSetPeakExcursion                    */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_markerSetPeakThreshold -                                           */
/*     This method specifies the minimum signal level for the analyzer's     */
/*     internal peak identification routine to recognize a signal as a peak. */
/*     This applies to all traces.                                           */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64    peakThresholdLevel                                         */
/*        - Threshold level in current display units.                        */
/*        - Values:   Range checked by instrument.                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_markerSetPeakThreshold
                        (ViSession instrumentHandle,
                         ViReal64 peakThresholdLevel)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    errStatus = delayVPrintf(instrumentHandle, "CALC:MARK:PEAK:THR %.15g\n", 
                             peakThresholdLevel);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                       end hpesa_markerSetPeakThreshold                    */
/*                                                                           */
/*****************************************************************************/


/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                    FREQUENCY COUNTER CONTROL FUNCTIONS                    |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_freqCounterSetResolution -                                         */
/*     This method sets the spectrum analyzer's frequency counter            */
/*     resolution.  The frequency counter resolution is normally coupled to  */
/*     the span frequency to generate the fastest accurate count.  By using  */
/*     this function, the resolution will be un-coupled until an instrument  */
/*     preset (hpesa_reset) or by calling hpesa_freqCounterSetResolutionAuto.*/
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViReal64    freqCounterResolution                                      */
/*        - Sets the resolution of the frequency counter.  Instrument rounds */
/*          values to the nearest power of 10, from 1 Hz to 100 kHz.         */
/*        - Values:   Range checked by instrument.                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_freqCounterSetResolution
                        (ViSession instrumentHandle,
                         ViReal64 freqCounterResolution)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    errStatus = delayVPrintf(instrumentHandle, "CALC:MARK:FCO:RES %.15gHZ\n", 
                             freqCounterResolution);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                     end hpesa_freqCounterSetResolution                    */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_freqCounterSetResolutionAuto -                                     */
/*     This method sets the spectrum analyzer's frequency counter resolution */
/*     to be auto coupled to the frequency span.                             */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_freqCounterSetResolutionAuto
                        (ViSession instrumentHandle)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    errStatus = delayVPrintf(instrumentHandle, "CALC:MARK:FCO:RES:AUTO ON\n");

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                   end hpesa_freqCounterSetResolutionAuto                  */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_freqCounterSetOn -                                                 */
/*     This method enables or disables the frequency counter for the         */
/*     specified marker.  Note that only one marker can be enabled for the   */
/*     frequency.                                                            */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16     frequencyCounterMarker                                     */
/*        - Marker number to enable frequency counter operation.  Please     */
/*          note that only one marker can be active for a frequency counter  */
/*          mode at a time.  Enabling another marker for frequency counter   */
/*          operation will automatically disable the previous marker as the  */
/*          active frequency counter.                                        */
/*        - Values:                                                          */
/*            hpesa_MARKER_1 - Marker 1                                      */
/*            hpesa_MARKER_2 - Marker 2                                      */
/*            hpesa_MARKER_3 - Marker 3                                      */
/*            hpesa_MARKER_4 - Marker 4                                      */
/*    ViBoolean   frequencyCounterOn                                         */
/*        - Sets the frequency counter on (VI_TRUE) or off (VI_FALSE).       */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_freqCounterSetOn
                        (ViSession instrumentHandle,
                         ViInt16 frequencyCounterMarker,
                         ViBoolean frequencyCounterOn)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(frequencyCounterMarker, 0, hpesa_MARKER_NUM_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)
    CHK_BOOLEAN(frequencyCounterOn, VI_ERROR_PARAMETER3)

    // Adjust the marker number from the enumeration.
    frequencyCounterMarker += 1;

    errStatus = delayVPrintf(instrumentHandle, "CALC:MARK%d:FCO:STAT %d\n", 
                             frequencyCounterMarker, frequencyCounterOn);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                       end hpesa_freqCounterSetOn                          */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_freqCounterGetXValue -                                             */
/*     This method measures the current X value of the frequency counter     */
/*     marker.  The value is in the X-axis units for the current trace       */
/*     (which is often frequency (Hz) or time (secs)).                       */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViPReal64   freqCounterGetXValue_Q                                     */
/*        - Current X axis value of the frequency in the X-axis units for    */
/*          the current trace (which is often Hz or secs).                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_freqCounterGetXValue
                        (ViSession instrumentHandle,
                         ViPReal64 freqCounterGetXValue_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(freqCounterGetXValue_Q, VI_ERROR_PARAMETER2)

    errStatus = delayVQueryf(instrumentHandle, "CALC:MARK:FCO:X?\n", 
                             "%lg%*t", freqCounterGetXValue_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                     end hpesa_freqCounterGetXValue                        */
/*                                                                           */
/*****************************************************************************/


/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                         INPUT CONTROL FUNCTIONS                           |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_inputCouplingSetMode -                                             */
/*     This method selects AC or DC coupling for the RF INPUT port.  A       */
/*     blocking capacitor is switched in for AC mode.                        */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16   inputCouplingMode                                            */
/*        - Instrument's new coupling mode.                                  */
/*        - Range:   hpesa_INPUT_COUPLE_AC - AC                              */
/*                   hpesa_INPUT_COUPLE_DC - DC                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_inputCouplingSetMode
                        (ViSession instrumentHandle,
                         ViInt16 inputCouplingMode)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViChar SCPIinputCouplingMode[3];

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(inputCouplingMode, 0, hpesa_INPUT_COUPLE_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)

    if(inputCouplingMode == hpesa_INPUT_COUPLE_AC)
        strcpy(SCPIinputCouplingMode, "AC");
    else
        strcpy(SCPIinputCouplingMode, "DC");

    errStatus = delayVPrintf(instrumentHandle, "INP:COUP %s\n", 
                             SCPIinputCouplingMode);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                     end hpesa_inputCouplingSetMode                        */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_inputSetImpedance -                                                */
/*     This method selects the input impedance correction method to use.     */
/*     Amplitude correction is applied to the display data to adjust for the */
/*     measurement situations where the unit under test has a different      */
/*     impedance then the instrument's input impedance.                      */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViInt16   inputImpedance                                               */
/*        - Specifies the input impedance                                    */
/*        - Range:   hpesa_INPUT_IMPEDANCE_50 - 50 Ohms                      */
/*                   hpesa_INPUT_IMPEDANCE_75 - 75 Ohms                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_inputSetImpedance
                        (ViSession instrumentHandle,
                         ViInt16 inputImpedance)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViInt16 SCPIinputSetImpedance;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(inputImpedance, 0, hpesa_INPUT_IMPEDANCE_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)

    if(inputImpedance == hpesa_INPUT_IMPEDANCE_50)
        SCPIinputSetImpedance = 50;
    else
        SCPIinputSetImpedance = 75;

    errStatus = delayVPrintf(instrumentHandle, "CORR:IMP %d\n", 
                             SCPIinputSetImpedance);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_inputSetImpedance                          */
/*                                                                           */
/*****************************************************************************/


/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                       DISPLAY CONTROL FUNCTIONS                           |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_displayLineSetup -                                                 */
/*     This method turns the display line on or off and sets the display     */
/*     line level.                                                           */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*    ViBoolean   displayLineOn                                              */
/*        - Enable or disables the display line.                             */
/*        - Range:   VI_TRUE - On                                            */
/*                   VI_FALSE- Off                                           */
/*    ViReal64    displayLineLevel                                           */
/*        - Sets the display line level in current active units.             */
/*        - Range:  Determined by instrument                                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_displayLineSetup
                        (ViSession instrumentHandle,
                         ViBoolean displayLineOn,
                         ViReal64 displayLineLevel)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_BOOLEAN(displayLineOn, VI_ERROR_PARAMETER2)

    errStatus = delayVPrintf(instrumentHandle, 
          ":DISP:WIND:TRAC:Y:DLIN:STAT %d;:DISP:WIND:TRAC:Y:DLIN %.15g\n", 
                             displayLineOn, displayLineLevel);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                       end hpesa_displayLineSetup                          */
/*                                                                           */
/*****************************************************************************/



/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                     TRACE MATH CONTROL FUNCTIONS                          |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_traceMeasureMean -                                                 */
/*     This method gets the mean of the amplitude of the trace elements in   */
/*     current amplitude measurement units.                                  */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*    ViInt16     meanTraceNumber (in)                                       */
/*        - Instrument trace number to select.                               */
/*        - Range:  hpesa_TRACE_1 - Trace 1                                  */
/*                  hpesa_TRACE_2 - Trace 2                                  */
/*                  hpesa_TRACE_3 - Trace 3                                  */
/*    ViPReal64   traceMean_Q (out)                                          */
/*        - Y-Axis (amplitude) mean of the specified trace in the current    */
/*          y-axis units (which is often dBm).                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_traceMeasureMean
                        (ViSession instrumentHandle,
                         ViInt16 meanTraceNumber,
                         ViPReal64 traceMean_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(meanTraceNumber, 0, hpesa_TRACE_LASTENUM, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(traceMean_Q, VI_ERROR_PARAMETER3)

    // Adjust the enumeration to a valid value.
    meanTraceNumber += 1;

    errStatus = delayVQueryf(instrumentHandle, "TRAC:MATH:MEAN? TRACE%d\n", 
                                "%lg%*t", meanTraceNumber, traceMean_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                       end hpesa_traceMeasureMean                          */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_traceSetSmooth -                                                   */
/*     This method smoothes the specified trace according to the number of   */
/*     specified points.                                                     */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*    ViInt16     smoothTraceNumber (in)                                     */
/*        - Instrument trace number to select.                               */
/*        - Range:  hpesa_TRACE_1 - Trace 1                                  */
/*                  hpesa_TRACE_2 - Trace 2                                  */
/*                  hpesa_TRACE_3 - Trace 3                                  */
/*    ViInt32     smoothTracePoints (in)                                     */
/*        - Specifies the number of points that will be smoothed.            */
/*        - Range:  Checked by instrument                                    */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_traceSetSmooth
                        (ViSession instrumentHandle,
                         ViInt16 smoothTraceNumber,
                         ViInt32 smoothTracePoints)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(smoothTraceNumber, 0, hpesa_TRACE_LASTENUM, VI_ERROR_PARAMETER2)

    // Adjust the enumeration to a valid value.
    smoothTraceNumber += 1;

    errStatus = delayVPrintf(instrumentHandle, 
                        ":TRAC:MATH:SMO:POIN %d;:TRAC:MATH:SMO TRACE%d\n",
                         smoothTracePoints, smoothTraceNumber);
                                 
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_traceSetSmooth                           */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_traceMeasurePeaks -                                                */
/*     This method gets the number of peaks and the peak amplitude values in */
/*     the active trace.                                                     */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*    ViInt16     tracePeakSortMode (in)                                     */
/*        - Select how the identified peaks are sorted in the parameters     */
/*          "tracePeakFrequencyArray_Q" and "tracePeakAmplitudeArray_Q".     */
/*        - Range:  hpesa_PEAKSORT_AMPL - sorts the identified peaks by      */
/*                                        descending amplitude.              */
/*                  hpesa_PEAKSORT_FREQ - sorts the identified peaks by      */
/*                                        increasing frequency.              */
/*    ViPInt32    traceNumberPeaks_Q(out)                                    */
/*        - Returns the number of peaks detected in the active trace.        */
/*          It also indicates the actual number of values returned in the    */
/*          frequency and amplitude data arrays.                             */
/*    ViReal64   tracePeakFrequencyArray_Q[] (out)                           */
/*        - This is an array of frequencies of the identified peaks in the   */
/*          current active trace.                                            */
/*    ViReal64   tracePeakAmplitudeArray_Q[] (out)                           */
/*        - This is an array of amplitudes of the identified peaks in the    */
/*          current active trace.                                            */
/*    ViInt32     tracePeakArrayMaxSize (in)                                 */
/*        - This value specifies the maximum size of the peak data arrays    */
/*          "tracePeakFrequencyArray_Q" and "tracePeakAmplitudeArray_Q".     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_traceMeasurePeaks
                        (ViSession instrumentHandle,
                         ViInt16 tracePeakSortMode,
                         ViPInt32 traceNumberPeaks_Q,
                         ViReal64 _VI_FAR tracePeakFrequencyArray_Q[],
                         ViReal64 _VI_FAR tracePeakAmplitudeArray_Q[],
                         ViInt32 tracePeakArrayMaxSize)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViChar sortType[5], oldFormat[10];
    ViChar *FreqAmpArray, *temptr1, *temptr2;
    ViInt32 ActualPeakArraySize, dummy;
    int i;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(tracePeakSortMode, 0, hpesa_PEAKSORT_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(traceNumberPeaks_Q, VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(tracePeakFrequencyArray_Q, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(tracePeakAmplitudeArray_Q, VI_ERROR_PARAMETER5)


     /*----------------------------------------------------------------*
      |  First, determine which sorting method is to be used.          |  
      *----------------------------------------------------------------*/

    switch(tracePeakSortMode)
    {
        case hpesa_PEAKSORT_AMPL:  strcpy(sortType, "AMPL"); break;
        case hpesa_PEAKSORT_FREQ:  strcpy(sortType, "FREQ"); break;
        default:
          return(statusUpdate(instrumentHandle, thisPtr, VI_ERROR_PARAMETER2));
    }

     /*----------------------------------------------------------------*
      |  Send the appropriate SCPI command to set up the sorting       |
      |  method.                                                       |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "TRAC:MATH:PEAK:SORT %s\n", 
                                                                    sortType);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Store the old instrument output format and then set the new.  |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "FORM?\n", "%t", oldFormat);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);


    errStatus = delayVPrintf(instrumentHandle, "FORM ASC\n");
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Next, find out how many peaks currently exist.                |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "TRAC:MATH:PEAK:POIN?\n",
                                        "%ld%*t", traceNumberPeaks_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  If any peaks exist, get thier values.                         |
      *----------------------------------------------------------------*/
    
    if(*traceNumberPeaks_Q > 0)
    {

     /*----------------------------------------------------------------*
      |  Since each peak has a frequency and amplitude value, set this |
      |  variable to twice the number of peaks.                        |
      *----------------------------------------------------------------*/

        ActualPeakArraySize = *traceNumberPeaks_Q * 2;

     /*----------------------------------------------------------------*
      |  Send the instrument the command to get the array of values.   |
      *----------------------------------------------------------------*/

        errStatus = delayVPrintf(instrumentHandle,"TRAC:MATH:PEAK?\n");
        if (errStatus < VI_SUCCESS)
            return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Allocate memory to handle the peak information.  Since each   |
      |  number coming back will be 16 bytes in length plus 1 byte for |
      |  a comma, allocate 17 times the number of values to be read.   |
      *----------------------------------------------------------------*/

        FreqAmpArray = (ViChar *)calloc((ActualPeakArraySize*17)+1, 
                                                        sizeof(ViChar));
        if(!FreqAmpArray)
        {
            thisPtr->errNumber = VI_ERROR_ALLOC;
            return VI_ERROR_ALLOC;
        }

     /*----------------------------------------------------------------*
      |  Query the instrument for the array.  Get 17 characters        |
      |  (16 digits + 1 comma) for each number to be dumped.           |
      *----------------------------------------------------------------*/

        errStatus = viRead(instrumentHandle, FreqAmpArray, 
                                        (ActualPeakArraySize*17), &dummy);
        if (errStatus < VI_SUCCESS)
        {
            free(FreqAmpArray);
            return statusUpdate(instrumentHandle, thisPtr, errStatus);
        }

     /*----------------------------------------------------------------*
      |  Sort the values into their respective arrays.  Also, only     |
      |  sort as many as the user allows.  traceNumberPeaks_Q contains |
      |  the actual number of peaks, while tracePeakArrayMaxSize is    |
      |  the amount the user wants.                                    |
      *----------------------------------------------------------------*/

        strcat(FreqAmpArray, "\0");
        temptr1 = FreqAmpArray;
        
        for(i=0;
            i < (*traceNumberPeaks_Q < tracePeakArrayMaxSize ? 
                        (*traceNumberPeaks_Q): (tracePeakArrayMaxSize));
            i++)
        {
            tracePeakFrequencyArray_Q[i] = strtod(temptr1, &temptr2);
            temptr2++;  // advance past the comma
            tracePeakAmplitudeArray_Q[i] = strtod(temptr2, &temptr1);
            temptr1++;  // advance past the comma
        }


     /*----------------------------------------------------------------*
      |  Free up allocated memory                                      |
      *----------------------------------------------------------------*/

        free(FreqAmpArray);

    }  // end of "if(*traceNumberPeaks_Q > 0)"

     /*----------------------------------------------------------------*
      |  Restore the format back to the previous value.                |
      *----------------------------------------------------------------*/
    
    errStatus = delayVPrintf(instrumentHandle, "FORM %s\n", oldFormat);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                       end hpesa_traceMeasurePeaks                         */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_traceGetTraceData -                                                */
/*     This method transfers data from the instrument to the controller.     */
/*     There are normally 401 points in a trace.                             */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*                                                                           */
/*    ViInt16     traceNumberRead (in)                                       */
/*        - Specifies the data trace to read.                                */
/*        - Range:  hpesa_TRACE_1 - Trace 1                                  */
/*                  hpesa_TRACE_2 - Trace 2                                  */
/*                  hpesa_TRACE_3 - Trace 3                                  */
/*                                                                           */
/*    ViReal64    traceDataReadArray_Q[] (out)                               */
/*        - This is x-axis data values for the specified trace in the        */
/*          current x-axis units.  Normally the number of points in the      */
/*          trace will be 401.                                               */
/*                                                                           */
/*    ViInt32      traceDataReadArrayMaxSize (in)                            */
/*        - This value specifies the maximum size of the                     */
/*          "traceDataReadArray_Q" array.  The value should be large enough  */
/*          for the number of points in the trace, which is normally 401     */
/*          display points.                                                  */
/*                                                                           */
/*    ViPInt32     traceDataReadArraySize_Q                                  */
/*        - This is the actual number of data points read from the           */
/*          instrument.                                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_traceGetTraceData
                        (ViSession instrumentHandle,
                         ViInt16 traceNumberRead,
                         ViReal64 traceDataReadArray_Q[],
                         ViInt32 traceDataReadArrayMaxSize,
                         ViPInt32 traceDataReadArraySize_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViChar oldFormat[10], SCPIcommand[15];
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(traceNumberRead, 0, hpesa_TRACE_LASTENUM, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(traceDataReadArray_Q, VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(traceDataReadArraySize_Q, VI_ERROR_PARAMETER5)

    // Adjust the enumeration to a valid value.
    traceNumberRead += 1;

     /*----------------------------------------------------------------*
      |  Find out what the current output format is and store it in    |
      |  oldFormat.                                                    |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "FORM?\n", "%t", oldFormat);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Set the output format to Real 64.                             |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "FORM REAL,64\n");
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Set the correct trace number and then send the command.       |
      *----------------------------------------------------------------*/

    sprintf(SCPIcommand, "TRAC? TRACE%d", traceNumberRead);


    errStatus = hpesa_cmdReal64Arr_Q(instrumentHandle, SCPIcommand,
                                     traceDataReadArrayMaxSize,
                                     traceDataReadArray_Q, traceDataReadArraySize_Q);

    
    if (errStatus < VI_SUCCESS)
        return errStatus;

     /*----------------------------------------------------------------*
      |  Set the output format back to its original setting.           |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "FORM %s\n", oldFormat);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
                         
    /*  Return by calling updateStatus */
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_traceGetTraceData                        */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_traceSetTraceData -                                                */
/*     This method transfers data from the controller to the instrument.     */
/*     There are normally 401 points in a trace.                             */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*                                                                           */
/*    ViInt16     traceNumberWrite (in)                                      */
/*        - Specifies the data trace to write.                               */
/*        - Range:  hpesa_TRACE_1 - Trace 1                                  */
/*                  hpesa_TRACE_2 - Trace 2                                  */
/*                  hpesa_TRACE_3 - Trace 3                                  */
/*                                                                           */
/*    ViReal64    traceDataWriteArray_Q[] (out)                              */
/*        - This is x-axis data values for the specified trace in the        */
/*          current x-axis units.                                            */
/*                                                                           */
/*    ViInt32      traceDataWriteArraySize (in)                              */
/*        - This value specifies the size of the "traceDataWriteArray" array */
/*          This value should be large enough for the number of points in    */
/*          the trace, which is normally 401 display points.                 */     
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_traceSetTraceData
                        (ViSession instrumentHandle,
                         ViInt16 traceNumberWrite,
                         ViPReal64 traceDataWriteArray_Q,
                         ViInt32 traceDataWriteArraySize)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViChar SCPIstring[30], oldFormat[10];
    int i, count=0;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(traceNumberWrite, 0, hpesa_TRACE_LASTENUM, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(traceDataWriteArray_Q, VI_ERROR_PARAMETER3)

    // Adjust the enumeration to a valid value.
    traceNumberWrite += 1;

     /*----------------------------------------------------------------*
      |  Find out what the current output format is and store it in    |
      |  oldFormat.                                                    |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "FORM?\n", "%t", oldFormat);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Set the output format to ASCII.                               |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "FORM ASC\n");
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Send the TRAC TRACEn SCPI command.  After that, send each of  |
      |  the numbers to the machine, and then finish it with the "\n". |
      *----------------------------------------------------------------*/

    sprintf(SCPIstring, "TRAC TRACE%d", traceNumberWrite);

    errStatus = delayVPrintf(instrumentHandle, "%s", SCPIstring);

        // Note:  This may cause a memory problem if the array size and 
        //        allocated array are not equal.

    for (i=0; i<traceDataWriteArraySize; i++)
        errStatus=delayVPrintf(instrumentHandle, ",%.15g", 
                                            traceDataWriteArray_Q[i]);

    errStatus = delayVPrintf(instrumentHandle, "\n");

    if(errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Set the output format back to its original setting.           |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "FORM %s\n", oldFormat);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
                         
    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                       end hpesa_traceSetTraceData                         */
/*                                                                           */
/*****************************************************************************/


/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                     SWEEP GATE CONTROL FUNCTIONS                          |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_sweepGateSetUp -                                                   */
/*     This method sets up the spectrum analyzer's sweep gate functionality. */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*                                                                           */
/*    ViBoolean   sweepGateOn (in)                                           */
/*        - Enable or disable the sweep gate operation.                      */
/*        - Range:  VI_TRUE (On) or VI_FALSE (Off)                           */
/*                                                                           */
/*    ViInt16     sweepGateType                                              */
/*        - Select sweep gate trigger type                                   */
/*        - Range:  hpesa_GATESWEEPTYPE_LEVEL - triggers the gate when       */
/*                         the signal surpasses a specific level.  Set       */
/*                         "sweepGateLevelType" to either low or high        */
/*                  hpesa_GATESWEEPTYPE_EDGE - triggers the gate when the    */
/*                         edge of a signal is encountered.  Set             */
/*                         "sweepGateEdgePol" to either a negative-going     */
/*                         or a positive-going edge.                         */
/*                                                                           */
/*    ViInt16     sweepGateLevelType                                         */
/*        - Select sweep gate trigger level type. This is for LEVEL          */
/*          triggering only.                                                 */
/*        - Range:  hpesa_GATESWEEPLEVEL_HIGH - gate triggers when level is  */
/*                        TTL high (> 2.0V),                                 */
/*                  hpesa_GATESWEEPLEVEL_LOW - gate triggers when level is   */
/*                        TTL low (<0.8V).                                   */
/*                                                                           */
/*    ViInt16     sweepGateEdgePol                                           */
/*        - Select sweep gate trigger edge polarity.  This is for EDGE       */
/*          triggering only.                                                 */
/*        - Range:    hpesa_GATESWEEPPOL_POSITIVE - gate triggers when       */
/*                        edge is positive.                                  */
/*                    hpesa_GATESWEEPPOL_NEGATIVE- gate triggers when        */
/*                        edge is negative.                                  */
/*                                                                           */
/*    ViReal64    sweepGateEdgeDelay                                         */
/*        - Sets the delay time (in seconds) from when the gate trigger      */
/*          occurs to when the gate opens.  This is for EDGE triggering only.*/
/*                                                                           */
/*    ViReal64    sweepGateEdgeLength                                        */
/*        - Sets the gate time (in seconds) length.  This is for EDGE        */
/*          triggering only.                                                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/

ViStatus _VI_FUNC hpesa_sweepGateSetUp
                        (ViSession instrumentHandle,
                         ViBoolean sweepGateOn,
                         ViInt16 sweepGateType,
                         ViInt16 sweepGateLevelType,
                         ViInt16 sweepGateEdgePol,
                         ViReal64 sweepGateEdgeDelay,
                         ViReal64 sweepGateEdgeLength)

{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViChar SCPIbuffer[5];

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_BOOLEAN(sweepGateOn, VI_ERROR_PARAMETER2)
    CHK_ENUM(sweepGateType, 0, hpesa_GATESWEEPTYPE_LASTENUM, 
                                                    VI_ERROR_PARAMETER3)
    CHK_ENUM(sweepGateLevelType, 0, hpesa_GATESWEEPLEVEL_LASTENUM, 
                                                    VI_ERROR_PARAMETER4)
    CHK_ENUM(sweepGateEdgePol, 0, hpesa_GATESWEEPPOL_LASTENUM,
                                                    VI_ERROR_PARAMETER5)

     /*----------------------------------------------------------------*
      |  If the sweep gate mode is set to be turned off, send the SCPI |
      |  command and that's all.                                       |
      *----------------------------------------------------------------*/

    if(!sweepGateOn)
    {    
        errStatus = delayVPrintf(instrumentHandle, "SWE:TIME:GATE OFF\n");
        if(errStatus < VI_SUCCESS)
            return statusUpdate(instrumentHandle, thisPtr, errStatus);
    }

     /*----------------------------------------------------------------*
      |  Otherwise, set up and send the the appropriate commands to    |
      |  set up the sweep gate.                                        |
      *----------------------------------------------------------------*/
    
    else
    {

     /*----------------------------------------------------------------*
      |  First, turn on the sweep gate.                                |
      *----------------------------------------------------------------*/

        errStatus = delayVPrintf(instrumentHandle, "SWE:TIME:GATE ON\n");
        if(errStatus < VI_SUCCESS)
            return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Next, set up the sweep gate type.                             |
      *----------------------------------------------------------------*/

        switch(sweepGateType)
        {
            case hpesa_GATESWEEPTYPE_LEVEL: sprintf(SCPIbuffer, "LEV"); break;
            case hpesa_GATESWEEPTYPE_EDGE:  sprintf(SCPIbuffer, "EDGE");break;
            default:
                return(statusUpdate(instrumentHandle, thisPtr, 
                                                        VI_ERROR_PARAMETER2));
        }

        errStatus = delayVPrintf(instrumentHandle, "SWE:TIME:GATE:TYPE %s\n",
                                           SCPIbuffer);

        if(errStatus < VI_SUCCESS)
            return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Check to see whether gate sweet type was "level".  If         |
      |  so, set up the sweep gate level type.                         |
      *----------------------------------------------------------------*/

        if(sweepGateType == hpesa_GATESWEEPTYPE_LEVEL)
        {
            switch(sweepGateLevelType)
            {
                case hpesa_GATESWEEPLEVEL_HIGH:
                    sprintf(SCPIbuffer, "HIGH");  break;
                case hpesa_GATESWEEPLEVEL_LOW:
                    sprintf(SCPIbuffer, "LOW ");  break;
                default:
                    return(statusUpdate(instrumentHandle, thisPtr, 
                                                        VI_ERROR_PARAMETER3));
            
            }

            errStatus = delayVPrintf(instrumentHandle, 
                                     "SWE:TIME:GATE:LEV %s\n", SCPIbuffer);
            if(errStatus < VI_SUCCESS)
                return statusUpdate(instrumentHandle, thisPtr, errStatus);
        }

     /*----------------------------------------------------------------*
      |  Otherwise, set the polarity, delay, and length.               |
      *----------------------------------------------------------------*/
        else
        {
            switch(sweepGateEdgePol)
            {
                case hpesa_GATESWEEPPOL_POSITIVE:
                    sprintf(SCPIbuffer, "POS "); break;
                case hpesa_GATESWEEPPOL_NEGATIVE:
                    sprintf(SCPIbuffer, "NEG "); break;
                default:
                    return(statusUpdate(instrumentHandle, thisPtr, 
                                                    VI_ERROR_PARAMETER2));
            }

            errStatus = delayVPrintf(instrumentHandle, 
                                     "SWE:TIME:GATE:POL %s\n", SCPIbuffer);
            if(errStatus < VI_SUCCESS)
                return statusUpdate(instrumentHandle, thisPtr, errStatus);

            errStatus = delayVPrintf(instrumentHandle,
                                     "SWE:TIME:GATE:DEL %15g\n", 
                                     sweepGateEdgeDelay);

            if(errStatus < VI_SUCCESS)
                return statusUpdate(instrumentHandle, thisPtr, errStatus);

            errStatus = delayVPrintf(instrumentHandle,
                                     "SWE:TIME:GATE:LENG %15g\n", 
                                     sweepGateEdgeLength);

            if(errStatus < VI_SUCCESS)
                return statusUpdate(instrumentHandle, thisPtr, errStatus);
        }

    }

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_sweepGateSetUp                           */
/*                                                                           */
/*****************************************************************************/



/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                 TRACKING GENERATOR CONTROL FUNCTIONS                      |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_trackGenSetOn -                                                    */
/*     This method enables or disables the tracking generator output.        */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*                                                                           */
/*    ViBoolean   trackingGeneratorOn (in)                                   */
/*        - Enable or disable the tracking generator output.                 */
/*        - Range:  VI_TRUE (on) or VI_FALSE (off)                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_trackGenSetOn 
                        (ViSession instrumentHandle,
                         ViBoolean trackingGeneratorOn)

{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViInt16 temp;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_BOOLEAN(trackingGeneratorOn, VI_ERROR_PARAMETER2)
                         
    errStatus = delayVPrintf(instrumentHandle, "OUTP %d\n", 
                                               trackingGeneratorOn);
    if(errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    errStatus = hpesa_opc_Q(instrumentHandle, &temp);
    if(errStatus < VI_SUCCESS)
        return errStatus;

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                          end hpesa_trackGenSetOn                          */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_trackGenSetAttenuation -                                           */
/*     This method sets the spectrum analyzer's RF tracking generator        */
/*     attenuation value.  Setting the amplitude attenuation with this       */
/*     function un-couples the attenuator from the output amplitude level.   */
/*     To re-couple the attenuator from the output amplitude level, call the */
/*     the function "hpesa_trackGenSetAttenationAuto".                       */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*                                                                           */
/*    ViReal64    trackingGeneratorAttenuation                               */
/*        - Instrument new tracking generator amplitude attenuation in dB    */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_trackGenSetAttenuation 
                        (ViSession instrumentHandle,
                         ViReal64 trackingGeneratorAttenuation)

{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

                         
    errStatus = delayVPrintf(instrumentHandle, "SOUR:POW:ATT %.15g\n", 
                                               trackingGeneratorAttenuation);
    if(errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                       end hpesa_trackGenSetAttenuation                    */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_trackGenSetAttenuationAuto -                                       */
/*     This method couples the spectrum analyzer's RF tracking generator     */
/*     attenuation value to be set automatically by the instrument.          */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_trackGenSetAttenuationAuto 
                        (ViSession instrumentHandle)

{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

                         
    errStatus = delayVPrintf(instrumentHandle, "SOUR:POW:ATT:AUTO ON\n");
    if(errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                     end hpesa_trackGenSetAttenuationAuto                  */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_trackGenSetAmplitude -                                             */
/*     This method sets the spectrum analyzer's tracking generator source    */
/*     output amplitude level.                                               */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*                                                                           */
/*    ViReal64    trackingGeneratorAmplitude (in)                            */
/*        - Instrument's new source output amplitude level in current        */
/*          display units.                                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_trackGenSetAmplitude
                        (ViSession instrumentHandle,
                         ViReal64 trackingGeneratorAttenuation)

{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)
                         
    errStatus = delayVPrintf(instrumentHandle, "SOUR:POW %.15g\n", 
                                               trackingGeneratorAttenuation);
    if(errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                     end hpesa_trackGenSetAmplitude                        */
/*                                                                           */
/*****************************************************************************/




/*****************************************************************************/
/*                                                                           */
/*  hpesa_trackGenSetAmplitudePeakOn -                                       */
/*     This method enables the tracking of the source output                 */
/*     with the spectrum analyzer sweep so that the power is maximized.      */
/*     This method is not applicable for the 1.5 GHz tracking generator.     */
/*     This command should be followed by a hpesa_sweepDoSweep in order      */
/*     to be effective.                                                      */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_trackGenSetAmplitudePeakOn
                        (ViSession instrumentHandle)

{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    errStatus = delayVPrintf(instrumentHandle, "SOUR:POW:TRCK:PEAK\n"); 

    if(errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                  end hpesa_trackGenSetAmplitudePeakOn                     */
/*                                                                           */
/*****************************************************************************/



/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                CALIBRATION/ALIGNMENT CONTROL FUNCTIONS                    |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_alignSignalRFSetOn -                                               */
/*     This method turns of or on the internal 50 MHz oscillator.            */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*                                                                           */
/*    ViBoolean   alignSignalRFOn (in)                                       */
/*        - Select 50 MHz oscillator on or off.                              */
/*        - Range:  VI_TRUE (on) or VI_FALSE (off)                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_alignSignalRFSetOn 
                        (ViSession instrumentHandle,
                         ViBoolean alignSignalRFOn)

{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_BOOLEAN(alignSignalRFOn, VI_ERROR_PARAMETER2)
                         
    errStatus = delayVPrintf(instrumentHandle, "CAL:SOUR:STAT %d\n", 
                                               alignSignalRFOn);
    if(errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_alignSignalRFSetOn                         */
/*                                                                           */
/*****************************************************************************/




/*****************************************************************************/
/*                                                                           */
/*  hpesa_alignAutoSetMode -                                                 */
/*     The automatic alignment routines normally run continuously in the     */
/*     background. This method allows you to choose to have all the routines */
/*     running, all the routines but not the RF alignment running, or no     */
/*     automatic alignment routines running at all.                          */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*                                                                           */
/*    ViInt16     alignAutoMode (in)                                         */
/*        - Select the auto alignment mode to operate in.                    */
/*        - Range:  hpesa_ALIGN_AUTO_ALL - selects auto align all            */
/*                  hpesa_ALGIN_AUTO_NRF - selects auto align all but RF     */
/*                  hpesa_ALIGN_AUTO_OFF - turns off auto alignment          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_alignAutoSetMode 
                        (ViSession instrumentHandle,
                         ViInt16 alignAutoMode)

{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViChar SCPIbuffer[35];

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(alignAutoMode, 0, hpesa_ALIGN_AUTO_LASTENUM, VI_ERROR_PARAMETER2)

    switch(alignAutoMode)
    {
        case hpesa_ALIGN_AUTO_ALL:  sprintf(SCPIbuffer, 
                                            ":CAL:AUTO:MODE ALL;:CAL:AUTO 1");
                                    break;
        case hpesa_ALIGN_AUTO_NRF:  sprintf(SCPIbuffer, 
                                            ":CAL:AUTO:MODE NRF;:CAL:AUTO 1");
                                    break;
        case hpesa_ALIGN_AUTO_OFF:  sprintf(SCPIbuffer, "CAL:AUTO 0");
                                    break;
        default:
            return(statusUpdate(instrumentHandle, thisPtr, 
                                                        VI_ERROR_PARAMETER2));
    }
                         
    errStatus = delayVPrintf(instrumentHandle, "%s\n", SCPIbuffer);
    if(errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                       end hpesa_alignAutoSetMode                          */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_alignFreqCorrSetOn -                                               */
/*     The method enables or disables the spectrum analyzer's frequency      */
/*     operation.                                                            */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*                                                                           */
/*    ViBoolean   alignFreqCorrOn (in)                                       */
/*        - Select frequency correction mode to on or off.                   */
/*        - Range:  VI_TRUE (on) or VI_FALSE (off)                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_alignFreqCorrSetOn
                        (ViSession instrumentHandle,
                         ViBoolean alignFreqCorrOn)

{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_BOOLEAN(alignFreqCorrOn, VI_ERROR_PARAMETER2)

    errStatus = delayVPrintf(instrumentHandle, "CAL:FREQ %d\n", 
                             alignFreqCorrOn);

    if(errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_alignFreqCorrSetOn                       */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_alignDoAlignment -                                                 */
/*     This method forces an immediate alignment of the specified assembly.  */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*                                                                           */
/*    ViInt16     alignmentType(in)                                          */
/*        - Select the assembly to do an immediate alignment on.             */
/*        - Range:  hpesa_ALIGN_ALL - align all assemblies.                  */
/*                  hpesa_ALIGN_RF - align the RF assembly                   */
/*                  hpesa_ALIGN_TG - align the tracking generator assembly   */
/*                  hpesa_ALIGN_FMD - align the FM Demod assembly            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_alignDoAlignment
                        (ViSession instrumentHandle,
                         ViInt16 alignmentType)

{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViChar SCPIbuffer[5];
    ViInt32 oldTimeOut;
    ViInt16 temp;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(alignmentType, 0, hpesa_ALIGN_LASTENUM, VI_ERROR_PARAMETER2)

     /*----------------------------------------------------------------*
      |  Retrieve the current timeout and then temproarily set a new   |
      |  one, 100 seconds long.                                        |
      *----------------------------------------------------------------*/

    errStatus = hpesa_timeOut_Q(instrumentHandle, &oldTimeOut);
    if(errStatus < VI_SUCCESS) return errStatus;

    errStatus = hpesa_timeOut(instrumentHandle, 
                                  (ViInt32)(100000));
    if(errStatus < VI_SUCCESS) return errStatus;

     /*----------------------------------------------------------------*
      |  Determine the correct parameter.                              |
      *----------------------------------------------------------------*/

    switch(alignmentType)
    {
        case hpesa_ALIGN_ALL: sprintf(SCPIbuffer, "ALL"); break;
        case hpesa_ALIGN_RF: sprintf(SCPIbuffer, "RF"); break;
        case hpesa_ALIGN_TG: sprintf(SCPIbuffer, "TG"); break;
        case hpesa_ALIGN_FMD: sprintf(SCPIbuffer, "FMD"); break;
        default:
         return(statusUpdate(instrumentHandle, thisPtr, VI_ERROR_PARAMETER2));
    }
                         
    errStatus = delayVPrintf(instrumentHandle, "CAL:%s\n", SCPIbuffer);
    if(errStatus < VI_SUCCESS)
    {
        hpesa_timeOut(instrumentHandle, oldTimeOut);
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
    }

    errStatus = hpesa_opc_Q(instrumentHandle, &temp);
    if(errStatus < VI_SUCCESS)
    {
        hpesa_timeOut(instrumentHandle, oldTimeOut);
        return errStatus;
    }

     /*----------------------------------------------------------------*
      |  Reset the timeout value to the previous value.                |
      *----------------------------------------------------------------*/

    errStatus = hpesa_timeOut(instrumentHandle, oldTimeOut);
    if(errStatus < VI_SUCCESS) return errStatus;

    /*  Return by calling updateStatus */
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_alignDoAlignment                         */
/*                                                                           */
/*****************************************************************************/


/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                        MEASURE CONTROL FUNCTIONS                          |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_measureSetMode                                                     */
/*    This method stops the current measurement and sets up the instrument   */
/*    for the specified measurement using the factory default instrument     */
/*    settings.  This will always set the instrument in single sweep mode    */
/*    and place the measurement in the idle state.                           */
/*    If the measurement is set to "Measure Off", the instrument will be     */
/*    placed in base instrument spectrum analyzer state.                     */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle                                           */
/*        - Instrument handle returned from hpesa_init.                      */
/*    ViInt16     measureMode                                                */
/*        - The instrument's new measurement mode.                           */
/*        - Values:                                                          */
/*            hpesa_MEASURE_MODE_OFF (default) - Sets the instrument in base */
/*              instrument spectrum analyzer state.                          */
/*            hpesa_MEASURE_MODE_ADJACENT  - Sets the instrument in adjacent */
/*              channel power mode.                                          */
/*            hpesa_MEASURE_MODE_CHANNEL - Sets the instrument in channel    */
/*              power mode.                                                  */
/*            hpesa_MEASURE_MODE_OCCUPIED - Sets the instrument in occupied  */
/*              bandwidth mode.                                              */
/*            hpesa_MEASURE_MODE_EMISSION - Sets the instrument in emission  */
/*              bandwidth mode.                                              */
/*            hpesa_MEASURE_MODE_HARMONIC - Sets the instrument in harmonic  */
/*              distortion mode.                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_measureSetMode
                        (ViSession instrumentHandle,
                         ViInt16 measureMode)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViChar SCPImeasureMode[5];
        
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_ENUM(measureMode, 0, hpesa_MEASURE_MODE_LASTENUM, VI_ERROR_PARAMETER2)

    switch(measureMode)
    {
        case hpesa_MEASURE_MODE_OFF:       
            strcpy(SCPImeasureMode, "SAN");  break;
        case hpesa_MEASURE_MODE_ADJACENT:  
            strcpy(SCPImeasureMode, "ACP");  break;
        case hpesa_MEASURE_MODE_CHANNEL:   
            strcpy(SCPImeasureMode, "CHP");  break;
        case hpesa_MEASURE_MODE_OCCUPIED:  
            strcpy(SCPImeasureMode, "OBW");  break;
        case hpesa_MEASURE_MODE_EMISSION:  
            strcpy(SCPImeasureMode, "EBW");  break;
        case hpesa_MEASURE_MODE_HARMONIC:  
            strcpy(SCPImeasureMode, "HARM"); break;
        default:
            return(statusUpdate(instrumentHandle, thisPtr, VI_ERROR_PARAMETER2));
    }

    errStatus = delayVPrintf(instrumentHandle, "CONF:%s\n", SCPImeasureMode);
    if(errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                         end hpesa_measureSetMode                          */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_measureGetMode                                                     */
/*    This method returns the current measurement state of the instrument.   */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle                                           */
/*        - Instrument handle returned from hpesa_init.                      */
/*    ViPInt16    measureMode_Q                                              */
/*        - Instrument's current measurement mode.                           */
/*           0 = Measure Off (Spectrum Analyzer)                             */
/*           1 = Adjacent Channel Power                                      */
/*           2 = Channel Power                                               */
/*           3 = Occupied Bandwidth                                          */
/*           4 = Emission Bandwidth                                          */
/*           5 = Harmonic Distortion                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_measureGetMode
                       (ViSession instrumentHandle,
                        ViPInt16 measureMode_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    int x;
    ViChar tempMeasMode[15];
    struct measTable{ViString MeasName; ViInt16 MeasEnum;};
    struct measTable MeasConv[] =
    {
        {"\"SANalyzer", hpesa_MEASURE_MODE_OFF},
        {"\"ACPower", hpesa_MEASURE_MODE_ADJACENT},
        {"\"CHPower", hpesa_MEASURE_MODE_CHANNEL},
        {"\"OBWidth", hpesa_MEASURE_MODE_OCCUPIED},
        {"\"EBWidth", hpesa_MEASURE_MODE_EMISSION},
        {"\"HARMonics", hpesa_MEASURE_MODE_HARMONIC},
    };        

    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(measureMode_Q, VI_ERROR_PARAMETER2)


    errStatus = hpesa_cmdString_Q(instrumentHandle, "CONF?", 15, tempMeasMode);

    /*-------------------------------------------------------------------*
     |  Since statusUpdate was called in hpesa_cmdString_Q, the error    |
     |  is not checked.  However, the conversion of the returned string  |
     |  only takes place if the errStatus is not an error.               |
     *-------------------------------------------------------------------*/

    if(errStatus >= VI_SUCCESS)
    {
        for(x=0; x<6; x++)
        {
            if(!strncmp(tempMeasMode, MeasConv[x].MeasName, 7))
            {
                *measureMode_Q = MeasConv[x].MeasEnum;
                break;
            }
        }

        if(x == 6) return statusUpdate(instrumentHandle, thisPtr, 
                                                     VI_ERROR_SYSTEM_ERROR);
    }

    /*  Return errStatus, statusUpdate having already been called  */

    return errStatus;

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_measureGetMode                           */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_ACPConfig                                                          */
/*    This method sets up the adjacent channel power measurement operation.  */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle                                           */
/*        - Instrument handle returned from hpesa_init.                      */
/*    ViBoolean   ACPAverageOn                                               */
/*        - Instrument's new ACP average state.                              */
/*        - Values:                                                          */
/*            VI_TRUE - Averaging on.                                        */
/*            VI_FALSE - Averaging off.                                      */
/*    ViInt16     ACPAverageCount                                            */
/*        - Specifies the number of ACP measurements that are combined.      */
/*    ViReal64    ACPMainChannelBW                                           */
/*        - Instrument's new main (channel) bandwidth in Hz.                 */
/*    ViReal64    ACPAdjChannelBW                                            */
/*        - Instrument's new adjacent channel bandwidth in Hz.               */
/*    ViReal64    ACPChannelSpacing                                          */
/*        - Instrument's new adjacent channel spacing in Hz.                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_ACPConfig
                        (ViSession instrumentHandle,
                         ViBoolean ACPAverageOn,
                         ViInt16 ACPAverageCount,
                         ViReal64 ACPMainChannelBW,
                         ViReal64 ACPAdjChannelBW,
                         ViReal64 ACPChannelSpacing)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
        
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_BOOLEAN(ACPAverageOn, VI_ERROR_PARAMETER2)

     /*----------------------------------------------------------------*
      |  Set the averaging mode for the adjacent channel power         |
      |  measurement.                                                  |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "ACP:AVER %d\n", ACPAverageOn);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  If the averaging mode is turned on, then set average count    |
      |  for ACP.                                                      |
      *----------------------------------------------------------------*/

    if(ACPAverageOn)
    {
        errStatus = delayVPrintf(instrumentHandle, "ACP:AVER:COUN %d\n", 
                                                            ACPAverageCount);
        if (errStatus < VI_SUCCESS)
            return statusUpdate(instrumentHandle, thisPtr, errStatus);
    }

     /*----------------------------------------------------------------*
      |  Set the ACP main channel bandwidth                            |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "ACP:BAND:INT %.15g\n", 
                                                            ACPMainChannelBW);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
    
     /*----------------------------------------------------------------*
      |  Set the ACP adjacent channel bandwidth                        |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "ACP:BAND:ACH %.15g\n", 
                                                            ACPAdjChannelBW);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Set the ACP channel spacing                                   |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "ACP:CSP %.15g\n", 
                                                          ACPChannelSpacing);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
    

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                          end hpesa_ACPConfig                              */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_ACPConfigQuery                                                     */
/*    This method retrieves the adjacent channel power measurement setup     */
/*    values.                                                                */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle                                           */
/*        - Instrument handle returned from hpesa_init.                      */
/*    ViPBoolean  ACPAverageOn_Q                                             */
/*        - Instrument's current ACP average state.                          */
/*    ViPInt16    ACPAverageCount_Q                                          */
/*        - Returns the number of ACP measurements that are combined.        */
/*    ViPReal64   ACPMainChannelBW_Q                                         */
/*        - Instrument's current main (channel) bandwidth in Hz.             */
/*    ViPReal64   ACPAdjChannelBW_Q                                          */
/*        - Instrument's current adjacent channel bandwidth in Hz.           */
/*    ViPReal64   ACPChannelSpacing_Q                                        */
/*        - Instrument's new adjacent channel spacing in Hz.                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_ACPConfigQuery
                        (ViSession instrumentHandle,
                         ViPBoolean ACPAverageOn_Q,
                         ViPInt16 ACPAverageCount_Q,
                         ViPReal64 ACPMainChannelBW_Q,
                         ViPReal64 ACPAdjChannelBW_Q,
                         ViPReal64 ACPChannelSpacing_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
        
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(ACPAverageOn_Q, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(ACPAverageCount_Q, VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(ACPMainChannelBW_Q, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(ACPAdjChannelBW_Q, VI_ERROR_PARAMETER5)
    CHK_NULL_POINTER(ACPChannelSpacing_Q, VI_ERROR_PARAMETER6)

     /*----------------------------------------------------------------*
      |  Retrieve the current averaging state                          |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "ACP:AVER?\n", "%hd%*t", 
                                                      ACPAverageOn_Q);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Retrieve the current average count                            |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "ACP:AVER:COUN?\n", "%hd%*t", 
                                                      ACPAverageCount_Q);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Retrieve the current main channel bandwidth                   |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "ACP:BAND:INT?\n", "%lg%*t", 
                                                      ACPMainChannelBW_Q);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Retrieve the adjacent channel bandwidth                       |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "ACP:BAND:ACH?\n", "%lg%*t", 
                                                      ACPAdjChannelBW_Q);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Retrieve the current channel spacing                          |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "ACP:CSP?\n", "%lg%*t", 
                                                      ACPChannelSpacing_Q);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                         end hpesa_ACPConfigQuery                          */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_ACPMeasure                                                         */
/*    This method retrieves the main, lower, and upper channel power         */
/*    measurements from the instrument, based on the method of retrieval     */
/*    (measure, read, or fetch).                                             */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle                                           */
/*        - Instrument handle returned from hpesa_init.                      */
/*    ViReal64    ACPMeasureTimeout                                          */
/*        - Temporary timeout value in seconds for measurement.              */
/*    ViInt16     ACPMeasureType                                             */
/*        - The method used to retrieve the ACP measurements.                */
/*        - Values:                                                          */
/*            hpesa_MEASURE_METHOD_MEAS - Initiates and retrieves            */
/*              measurement data from the instrument, using factory default  */
/*              settings.                                                    */
/*            hpesa_MEASURE_METHOD_READ - Initiates and retrieves            */
/*              measurement data from the instrument, using the current      */
/*              setup values.                                                */
/*            hpesa_MEASURE_METHOD_FETCH - Retrieves data from the           */
/*              instrument using the current setup values.  Does not         */
/*              initiate a measurement.                                      */
/*    ViPReal64   MainACP_Q                                                  */
/*        - The value of the main channel power in the current amplitude     */
/*          units.                                                           */
/*    ViPReal64   LowerACP_Q                                                 */
/*        - The value of the lower channel power relative to the main        */
/*          channel power, in dB                                             */
/*    ViPReal64   UpperACP_Q                                                 */
/*        - The value of the upper channel power relative to the main        */
/*          channel power, in dB.                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_ACPMeasure
                        (ViSession instrumentHandle,
                         ViReal64 ACPMeasureTimeout,
                         ViInt16 ACPMeasureType,
                         ViPReal64 MainACP_Q,
                         ViPReal64 LowerACP_Q,
                         ViPReal64 UpperACP_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViChar SCPIMeasureType[5], ACPresults[80], *tmptr;
    ViInt32 oldTimeOut;
    int sz = 80;
        
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(ACPMeasureType, hpesa_MEASURE_METHOD_MEAS, 
                         hpesa_MEASURE_METHOD_LASTENUM, VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(MainACP_Q, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(LowerACP_Q, VI_ERROR_PARAMETER5)
    CHK_NULL_POINTER(UpperACP_Q, VI_ERROR_PARAMETER6)

     /*----------------------------------------------------------------*
      |  Retrieve the current timeout and then temproarily set a new   |
      |  one.                                                          |
      *----------------------------------------------------------------*/

    errStatus = hpesa_timeOut_Q(instrumentHandle, &oldTimeOut);
    if(errStatus < VI_SUCCESS) return errStatus;

    errStatus = hpesa_timeOut(instrumentHandle, 
                                  (ViInt32)(ACPMeasureTimeout*1000));
    if(errStatus < VI_SUCCESS) return errStatus;


     /*----------------------------------------------------------------*
      |  Set the string to the appropriate SCPI command.               |
      *----------------------------------------------------------------*/

    switch(ACPMeasureType)
    {
        case hpesa_MEASURE_METHOD_MEAS:
            strcpy(SCPIMeasureType, "MEAS");  break;
        case hpesa_MEASURE_METHOD_READ:
            strcpy(SCPIMeasureType, "READ");  break;
        case hpesa_MEASURE_METHOD_FETCH:
            strcpy(SCPIMeasureType, "FETC");  break;
        default:
            return(statusUpdate(instrumentHandle, thisPtr, 
                                                     VI_ERROR_PARAMETER2));
    }

     /*----------------------------------------------------------------*
      |  Send the complete SCPI command, with an array of 80 for the   |
      |  the results.  Note that the actual amount read (returned in   |
      |  sz) is not used, since it is known that there will only be    |
      |  three values.                                                 |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "%s:ACP?\n", "%#t", 
                                           SCPIMeasureType, &sz, ACPresults);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Convert and sort the character array into the correct return  |
      |  values.  The "++" advances the array past the comma in the    |
      |  list.
      *----------------------------------------------------------------*/

    *MainACP_Q = strtod(ACPresults, &tmptr);
    tmptr++;   // Advance past the comma
    *LowerACP_Q = strtod(tmptr, &tmptr);
    tmptr++;   // Advance past the comma
    *UpperACP_Q = strtod(tmptr, &tmptr);

     /*----------------------------------------------------------------*
      |  Reset the timeout value to the previous value.                |
      *----------------------------------------------------------------*/

    errStatus = hpesa_timeOut(instrumentHandle, oldTimeOut);
    if(errStatus < VI_SUCCESS) return errStatus;

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                         end hpesa_ACPMeasure                              */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_CHPConfig                                                          */
/*    This method sets up the channel power measurement operation.           */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle                                           */
/*        - Instrument handle returned from hpesa_init.                      */
/*    ViBoolean   CHPAverageOn                                               */
/*        - Instrument's new CHP average state.                              */
/*        - Values:                                                          */
/*            VI_TRUE - Averaging on.                                        */
/*            VI_FALSE - Averaging off.                                      */
/*    ViInt16     CHPAverageCount                                            */
/*        - Specifies the number of CHP measurements that are combined.      */
/*    ViReal64    CHPIntegrationBW                                           */
/*        - Instrument's new frequency span (bandwidth) over which to        */
/*          integrate power.                                                 */
/*    ViReal64    CHPSpan                                                    */
/*        - Instrument's new channel power span..                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_CHPConfig
                        (ViSession instrumentHandle,
                         ViBoolean CHPAverageOn,
                         ViInt16 CHPAverageCount,
                         ViReal64 CHPIntegrationBW,
                         ViReal64 CHPSpan)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
        
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_BOOLEAN(CHPAverageOn, VI_ERROR_PARAMETER2)

     /*----------------------------------------------------------------*
      |  Set the averaging mode for the channel power measurement.     |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "CHP:AVER %d\n", CHPAverageOn);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  If the averaging mode is turned on, then set average count    |
      |  for CHP.                                                      |
      *----------------------------------------------------------------*/

    if(CHPAverageOn)
    {
        errStatus = delayVPrintf(instrumentHandle, "CHP:AVER:COUN %d\n", 
                                                            CHPAverageCount);
        if (errStatus < VI_SUCCESS)
            return statusUpdate(instrumentHandle, thisPtr, errStatus);
    }

     /*----------------------------------------------------------------*
      |  Send the frequency and channel span command.                  |
      *----------------------------------------------------------------*/
    
    errStatus = delayVPrintf(instrumentHandle, "CHP:BAND:INT %.15g\n", 
                                                           CHPIntegrationBW);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);


    errStatus = delayVPrintf(instrumentHandle, "CHP:FREQ:SPAN %.15g\n",
                                                           CHPSpan);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                          end hpesa_CHPConfig                              */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_CHPConfigQuery                                                     */
/*    This method retrieves the channel power setup information.             */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle                                           */
/*        - Instrument handle returned from hpesa_init.                      */
/*    ViPBoolean  CHPAverageOn_Q                                             */
/*        - Instrument's current CHP average state.                          */
/*    ViPInt16    CHPAverageCount_Q                                          */
/*        - Instrument's current number of averages.                         */
/*    ViPReal64   CHPIntegrationBW_Q                                         */
/*        - Instrument's current frequency span (bandwidth).                 */
/*    ViPReal64   CHPSpan_Q                                                  */
/*        - Instrument's current channel power span.                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_CHPConfigQuery
                        (ViSession instrumentHandle,
                         ViPBoolean CHPAverageOn_Q,
                         ViPInt16 CHPAverageCount_Q,
                         ViPReal64 CHPIntegrationBW_Q,
                         ViPReal64 CHPSpan_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
        
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(CHPAverageOn_Q, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(CHPAverageCount_Q, VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(CHPIntegrationBW_Q, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(CHPSpan_Q, VI_ERROR_PARAMETER5)

     /*----------------------------------------------------------------*
      |  Retrieve the current averaging state                          |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "CHP:AVER?\n", "%hd%*t", 
                                                      CHPAverageOn_Q);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Retrieve the current average count                            |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "CHP:AVER:COUN?\n", "%hd%*t", 
                                                      CHPAverageCount_Q);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Retrieve the frequency and channel power span.                |
      *----------------------------------------------------------------*/
    
    errStatus = delayVQueryf(instrumentHandle, "CHP:BAND:INT?\n", "%lg%*t",
                                                      CHPIntegrationBW_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);


    errStatus = delayVQueryf(instrumentHandle, "CHP:FREQ:SPAN?\n", "%lg%*t",
                                                      CHPSpan_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
    
    
    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                         end hpesa_CHPConfigQuery                          */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_CHPMeasure                                                         */
/*    This method retrieves the scalar results of the main channel power and */
/*    power density from the instrument, based on the method of retrieval    */
/*    (measure, read, or fetch).                                             */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle                                           */
/*        - Instrument handle returned from hpesa_init.                      */
/*    ViReal64    CHPMeasureTimeout                                          */
/*        - Temporary timeout value in seconds for measurement.              */
/*    ViInt16     CHPMeasureType                                             */
/*        - The method used to retrieve the CHP measurements.                */
/*        - Values:                                                          */
/*            hpesa_MEASURE_METHOD_MEAS - Initiates and retrieves            */
/*              measurement data from the instrument, using factory default  */
/*              settings.                                                    */
/*            hpesa_MEASURE_METHOD_READ - Initiates and retrieves            */
/*              measurement data from the instrument, using the current      */
/*              setup values.                                                */
/*            hpesa_MEASURE_METHOD_FETCH - Retrieves data from the           */
/*              instrument using the current setup values.  Does not         */
/*              initiate a measurement.                                      */
/*    ViPReal64   CHPChannelPower_Q                                          */
/*        - The value of the channel power in the current amplitude units.   */
/*    ViPReal64   CHPDensity_Q                                               */
/*        - The value of the channel power density in amplitude units/Hz     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_CHPMeasure
                        (ViSession instrumentHandle,
                         ViReal64 CHPMeasureTimeout,
                         ViInt16 CHPMeasureType,
                         ViPReal64 CHPChannelPower_Q,
                         ViPReal64 CHPDensity_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViInt32 oldTimeOut;
    ViChar SCPIMeasureType[5], CHPresults[80], *tmptr;
    int sz = 80;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(CHPMeasureType,
                hpesa_MEASURE_METHOD_MEAS, 
                hpesa_MEASURE_METHOD_LASTENUM,
                VI_ERROR_PARAMETER3)

    CHK_NULL_POINTER(CHPChannelPower_Q, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(CHPDensity_Q, VI_ERROR_PARAMETER5)

     /*----------------------------------------------------------------*
      |  Retrieve the current timeout and then temproarily set a new   |
      |  one.                                                          |
      *----------------------------------------------------------------*/

    errStatus = hpesa_timeOut_Q(instrumentHandle, &oldTimeOut);
    if(errStatus < VI_SUCCESS) return errStatus;

    errStatus = hpesa_timeOut(instrumentHandle,
                                  (ViInt32)(CHPMeasureTimeout*1000));
    if(errStatus < VI_SUCCESS) return errStatus;


     /*----------------------------------------------------------------*
      |  Set the string to the appropriate SCPI command.               |
      *----------------------------------------------------------------*/

    switch(CHPMeasureType)
    {
        case hpesa_MEASURE_METHOD_MEAS:
            strcpy(SCPIMeasureType, "MEAS");  break;
        case hpesa_MEASURE_METHOD_READ:
            strcpy(SCPIMeasureType, "READ");  break;
        case hpesa_MEASURE_METHOD_FETCH:
            strcpy(SCPIMeasureType, "FETC");  break;
        default:
            return(statusUpdate(instrumentHandle, thisPtr, 
                                                     VI_ERROR_PARAMETER2));
    }

     /*----------------------------------------------------------------*
      |  Send the complete SCPI command, with an array of 80 for the   |
      |  the results.  Note that the actual amount read (returned in   |
      |  sz) is not used, since it is known that there will only be    |
      |  two values.                                                   |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "%s:CHP?\n", "%#t", 
                                           SCPIMeasureType, &sz, CHPresults);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Convert and sort the character array into the correct return  |
      |  values.  The "++" advances the array past the comma in the    |
      |  list.                                                         |
      *----------------------------------------------------------------*/

    *CHPChannelPower_Q = strtod(CHPresults, &tmptr);
    tmptr++;   // Advance past the comma
    *CHPDensity_Q = strtod(tmptr, &tmptr);

     /*----------------------------------------------------------------*
      |  Reset the timeout value to the prevous value.                 |
      *----------------------------------------------------------------*/

    errStatus = hpesa_timeOut(instrumentHandle, oldTimeOut);
    if(errStatus < VI_SUCCESS) return errStatus;
 
    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                          end hpesa_CHPMeasure                             */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_OBWConfig                                                          */
/*    This method sets up the occupied bandwidth measurement operation.      */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle                                           */
/*        - Instrument handle returned from hpesa_init.                      */
/*    ViBoolean   OBWAverageOn                                               */
/*        - Instrument's new occupied bandwidth average state.               */
/*        - Values:                                                          */
/*            VI_TRUE - Averaging on.                                        */
/*            VI_FALSE - Averaging off.                                      */
/*    ViInt16     OBWAverageCount                                            */
/*        - Specifies the number of occupied bandwidth measurements that are */
/*          combined.                                                        */
/*    ViReal64    OBWSpan                                                    */
/*        - Instrument's new occupied bandwidth span.  The analyzer span     */
/*          will retain this value throughout the measurement.               */
/*    ViReal64    OBWPercentPower                                            */
/*        - Instrument's new occupied bandwidth power in percent..           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_OBWConfig
                        (ViSession instrumentHandle,
                         ViBoolean OBWAverageOn,
                         ViInt16 OBWAverageCount, 
                         ViReal64 OBWSpan,
                         ViReal64 OBWPercentPower)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
        
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_BOOLEAN(OBWAverageOn, VI_ERROR_PARAMETER2)

     /*----------------------------------------------------------------*
      |  Set the averaging mode for the occupied bandwidth measurement |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "OBW:AVER %d\n", OBWAverageOn);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  If the averaging mode is turned on, then set average count    |
      |  for OBW.                                                      |
      *----------------------------------------------------------------*/

    if(OBWAverageOn)
    {
        errStatus = delayVPrintf(instrumentHandle, "OBW:AVER:COUN %d\n", 
                                                            OBWAverageCount);
        if (errStatus < VI_SUCCESS)
            return statusUpdate(instrumentHandle, thisPtr, errStatus);
    }

     /*----------------------------------------------------------------*
      |  Send the commands for the OBW span and bandwidth power.       |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "OBW:FREQ:SPAN %.15g\n",
                                                           OBWSpan);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    errStatus = delayVPrintf(instrumentHandle, "OBW:PERC %.15g\n",
                                                           OBWPercentPower);


    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                          end hpesa_OBWConfig                              */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_OBWConfigQuery                                                     */
/*    This method sets up the occupied bandwidth measurement operation.      */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle                                           */
/*        - Instrument handle returned from hpesa_init.                      */
/*    ViPBoolean  OBWAverageOn_Q                                             */
/*        - Instrument's current occupied bandwidth average state.           */
/*    ViPInt16    OBWAverageCount_Q                                          */
/*        - Instrument's current number of occupied bandwidth averages.      */
/*    ViPReal64   OBWSpan_Q                                                  */
/*        - Instrument's current occupied bandwidth span.                    */
/*    ViPReal64   OBWPercentPower_Q                                          */
/*        - Instrument's current occupied bandwidth power in percent.        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_OBWConfigQuery
                        (ViSession instrumentHandle,
                         ViPBoolean OBWAverageOn_Q,
                         ViPInt16 OBWAverageCount_Q,
                         ViPReal64 OBWSpan_Q,
                         ViPReal64 OBWPercentPower_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
        
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(OBWAverageOn_Q, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(OBWAverageCount_Q, VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(OBWSpan_Q, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(OBWPercentPower_Q, VI_ERROR_PARAMETER5)

     /*----------------------------------------------------------------*
      |  Retrieve the current averaging state                          |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "OBW:AVER?\n", "%hd%*t", 
                                                      OBWAverageOn_Q);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Retrieve the current average count                            |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "OBW:AVER:COUN?\n", "%hd%*t", 
                                                      OBWAverageCount_Q);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Retrieve the occupied bandwidth span and power                |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "OBW:FREQ:SPAN?\n", "%lg%*t",
                                                      OBWSpan_Q);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    errStatus = delayVQueryf(instrumentHandle, "OBW:PERC?\n", "%lg%*t",
                                                      OBWPercentPower_Q);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
    

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                         end hpesa_OBWConfigQuery                          */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_OBWMeasure                                                         */
/*    This method retrieves the scalar results of occupied bandwidth and     */
/*    transmit frequency error from the instrument, based on the method of   */
/*    retrieval (measure, read, or fetch).                                   */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle                                           */
/*        - Instrument handle returned from hpesa_init.                      */
/*    ViReal64    OBWMeasureTimeout                                          */
/*        - Temporary timeout value in seconds for measurement.              */
/*    ViInt16     OBWMeasureType                                             */
/*        - The method used to retrieve the occupied bandwidth measurements. */
/*        - Values:                                                          */
/*            hpesa_MEASURE_METHOD_MEAS - Initiates and retrieves            */
/*              measurement data from the instrument, using factory default  */
/*              settings.                                                    */
/*            hpesa_MEASURE_METHOD_READ - Initiates and retrieves            */
/*              measurement data from the instrument, using the current      */
/*              setup values.                                                */
/*            hpesa_MEASURE_METHOD_FETCH - Retrieves data from the           */
/*              instrument using the current setup values.  Does not         */
/*              initiate a measurement.                                      */
/*    ViPReal64   OBWOccupiedBandwidth_Q                                     */
/*        - The value of the occupied bandwidth in Hz.                       */
/*    ViPReal64   OBWFreqError_Q                                             */
/*        - The value of transmit frequency error in Hz.                     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_OBWMeasure
                        (ViSession instrumentHandle,
                         ViReal64 OBWMeasureTimeout,
                         ViInt16 OBWMeasureType,
                         ViPReal64 OBWOccupiedBandwidth_Q,
                         ViPReal64 OBWFreqError_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViInt32 oldTimeOut;
    ViChar SCPIMeasureType[5], OBWresults[80], *tmptr;
    int sz = 80;
        
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(OBWMeasureType, 
                hpesa_MEASURE_METHOD_MEAS, 
                hpesa_MEASURE_METHOD_LASTENUM, 
                VI_ERROR_PARAMETER3)

    CHK_NULL_POINTER(OBWOccupiedBandwidth_Q, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(OBWFreqError_Q, VI_ERROR_PARAMETER5)

     /*----------------------------------------------------------------*
      |  Retrieve the current timeout and then temproarily set a new   |
      |  one.                                                          |
      *----------------------------------------------------------------*/

    errStatus = hpesa_timeOut_Q(instrumentHandle, &oldTimeOut);
    if(errStatus < VI_SUCCESS) return errStatus;

    errStatus = hpesa_timeOut(instrumentHandle, 
                                  (ViInt32)(OBWMeasureTimeout*1000));

    if(errStatus < VI_SUCCESS) return errStatus;

     /*----------------------------------------------------------------*
      |  Set the string to the appropriate SCPI command.               |
      *----------------------------------------------------------------*/

    switch(OBWMeasureType)
    {
        case hpesa_MEASURE_METHOD_MEAS:
            strcpy(SCPIMeasureType, "MEAS");  break;
        case hpesa_MEASURE_METHOD_READ:
            strcpy(SCPIMeasureType, "READ");  break;
        case hpesa_MEASURE_METHOD_FETCH:
            strcpy(SCPIMeasureType, "FETC");  break;
        default:
            return(statusUpdate(instrumentHandle, thisPtr, 
                                                     VI_ERROR_PARAMETER2));
    }
        
     /*----------------------------------------------------------------*
      |  Send the complete SCPI command, with an array of 80 for the   |
      |  the results.  Note that the actual amount read (returned in   |
      |  sz) is not used, since it is known that there will only be    |
      |  two values.                                                   |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "%s:OBW?\n", "%#t", 
                                           SCPIMeasureType, &sz, OBWresults);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Convert and sort the character array into the correct return  |
      |  values.  The "++" advances the array past the comma in the    |
      |  list.                                                         |
      *----------------------------------------------------------------*/

    *OBWOccupiedBandwidth_Q = strtod(OBWresults, &tmptr);
    tmptr++;   // Advance past the comma
    *OBWFreqError_Q = strtod(tmptr, &tmptr);

     /*----------------------------------------------------------------*
      |  Reset the timeout to previous value.                          |
      *----------------------------------------------------------------*/

    errStatus = hpesa_timeOut(instrumentHandle, oldTimeOut);
    if(errStatus < VI_SUCCESS) return errStatus;

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                         end hpesa_OBWMeasure                              */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_EBWConfig                                                          */
/*    This method sets up the emission bandwidth measurement operation.      */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle                                           */
/*        - Instrument handle returned from hpesa_init.                      */
/*    ViBoolean   EBWAverageOn                                               */
/*        - Instrument's new EBW average state.                              */
/*        - Values:                                                          */
/*            VI_TRUE - Averaging on.                                        */
/*            VI_FALSE - Averaging off.                                      */
/*    ViInt16     EBWAverageCount                                            */
/*        - Specifies the number of EBW measurements that are combined.      */
/*    ViBoolean   EBWMaxHold                                                 */
/*        - Turns on or off the trace max hold trace feature for emission    */
/*          bandwidth measurements.                                          */
/*        - Values:                                                          */
/*            VI_TRUE - Trace max hold on.                                   */
/*            VI_FALSE - Trace max hold off.                                 */
/*    ViReal64    EBWSpan                                                    */
/*        - Instrument's new emission bandwidth span.                        */
/*    ViReal64    EmissBWXdB                                                 */
/*        - Sets the dB value (X dB) below the maximum value on the signal   */
/*          at which to measure the emission bandwidth.                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_EBWConfig
                        (ViSession instrumentHandle,
                         ViBoolean EBWAverageOn,
                         ViInt16 EBWAverageCount,
                         ViBoolean EBWMaxHold,
                         ViReal64 EBWSpan,
                         ViReal64 EmissBWXdB)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
        
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_BOOLEAN(EBWAverageOn, VI_ERROR_PARAMETER2)
    CHK_BOOLEAN(EBWMaxHold, VI_ERROR_PARAMETER4)

     /*----------------------------------------------------------------*
      |  Set the averaging mode for the channel power measurement.     |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "EBW:AVER %d\n", EBWAverageOn);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  If the averaging mode is turned on, then set average count    |
      |  for EBW.                                                      |
      *----------------------------------------------------------------*/

    if(EBWAverageOn)
    {
        errStatus = delayVPrintf(instrumentHandle, "EBW:AVER:COUN %d\n", 
                                                            EBWAverageCount);
        if (errStatus < VI_SUCCESS)
            return statusUpdate(instrumentHandle, thisPtr, errStatus);
    }

     /*----------------------------------------------------------------*
      |  Set the max hold trace                                        |
      *----------------------------------------------------------------*/
    
    errStatus = delayVPrintf(instrumentHandle, "EBW:MAXH %d\n", EBWMaxHold);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Set the span                                                  |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle,
                             "EBW:FREQ:SPAN %.15g\n",
                             EBWSpan);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Set the X db value                                            |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "EBW:XDB %.15g\n", EmissBWXdB);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                           end hpesa_EBWConfig                             */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_EBWConfigQuery                                                     */
/*    This method retrieves the current emission bandwidth settings.         */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle                                           */
/*        - Instrument handle returned from hpesa_init.                      */
/*    ViPBoolean  EBWAverageOn_Q                                             */
/*        - Instrument's current emission bandwidth average state.           */
/*    ViPInt16    EBWAverageCount_Q                                          */
/*        - Instrument's current number of emission bandwidth averages.      */
/*    ViPBoolean  EBWMaxHold_Q                                               */
/*        - Instrument's current emission bandwidth trace max hold state.    */
/*    ViPReal64   EBWSpan_Q                                                  */
/*        - Instrument's current emission bandwidth span.                    */
/*    ViPReal64   EmissBWXdB_Q                                               */
/*        - Current  dB value (X dB) below the maximum value on the signal   */
/*          at which to measure the emission bandwidth.                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_EBWConfigQuery
                        (ViSession instrumentHandle,
                         ViPBoolean EBWAverageOn_Q,
                         ViPInt16 EBWAverageCount_Q,
                         ViPBoolean EBWMaxHold_Q,
                         ViPReal64 EBWSpan_Q,
                         ViPReal64 EmissBWXdB_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
        
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(EBWAverageOn_Q, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(EBWAverageCount_Q, VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(EBWMaxHold_Q, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(EBWSpan_Q, VI_ERROR_PARAMETER5)
    CHK_NULL_POINTER(EmissBWXdB_Q, VI_ERROR_PARAMETER6)

     /*----------------------------------------------------------------*
      |  Retrieve the current averaging state                          |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "EBW:AVER?\n", "%hd%*t", 
                                                      EBWAverageOn_Q);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Retrieve the current average count                            |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, "EBW:AVER:COUN?\n", "%hd%*t", 
                                                      EBWAverageCount_Q);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Retrieve the current max hold state                           |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, 
                             "EBW:MAXH?\n", 
                             "%hd%*t", 
                             EBWMaxHold_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Retrieve the current span                                     |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle,
                             "EBW:FREQ:SPAN?\n",
                             "%lg%*t",
                             EBWSpan_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Retrieve the current X dB                                     |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle,
                             "EBW:XDB?\n",
                             "%lg%*t",
                             EmissBWXdB_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                         end hpesa_EBWConfigQuery                          */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_EBWMeasure                                                         */
/*    This method retrieves the emission bandwidth from the instrument,      */
/*    based on the method of retrieval (measure, read, or fetch).            */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle                                           */
/*        - Instrument handle returned from hpesa_init.                      */
/*    ViReal64    EBWMeasureTimeout                                          */
/*        - Temporary timeout value in seconds for measurement.              */
/*    ViInt16     EBWMeasureType                                             */
/*        - The method used to retrieve the EBW measurements.                */
/*        - Values:                                                          */
/*            hpesa_MEASURE_METHOD_MEAS - Initiates and retrieves            */
/*              measurement data from the instrument, using factory default  */
/*              settings.                                                    */
/*            hpesa_MEASURE_METHOD_READ - Initiates and retrieves            */
/*              measurement data from the instrument, using the current      */
/*              setup values.                                                */
/*            hpesa_MEASURE_METHOD_FETCH - Retrieves data from the           */
/*              instrument using the current setup values.  Does not         */
/*              initiate a measurement.                                      */
/*    ViPReal64   emissionBandwidth_Q                                        */
/*        - The value of the emission bandwidth in Hz.                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_EBWMeasure
                        (ViSession instrumentHandle,
                         ViReal64 EBWMeasureTimeout,
                         ViInt16 EBWMeasureType,
                         ViPReal64 emissionBandwidth_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViInt32 oldTimeOut;
    ViChar SCPIMeasureType[5];
        
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(EBWMeasureType, 
                hpesa_MEASURE_METHOD_MEAS, 
                hpesa_MEASURE_METHOD_LASTENUM, 
                VI_ERROR_PARAMETER3)

    CHK_NULL_POINTER(emissionBandwidth_Q, VI_ERROR_PARAMETER4)

     /*----------------------------------------------------------------*
      |  Retrieve the current timeout and then temproarily set a new   |
      |  one.                                                          |
      *----------------------------------------------------------------*/

    errStatus = hpesa_timeOut_Q(instrumentHandle, &oldTimeOut);
    if(errStatus < VI_SUCCESS) return errStatus;

    errStatus = hpesa_timeOut(instrumentHandle, 
                                  (ViInt32)(EBWMeasureTimeout*1000));

    if(errStatus < VI_SUCCESS) return errStatus;

     /*----------------------------------------------------------------*
      |  Set the string to the appropriate SCPI command.               |
      *----------------------------------------------------------------*/

    switch(EBWMeasureType)
    {
        case hpesa_MEASURE_METHOD_MEAS:
            strcpy(SCPIMeasureType, "MEAS");  break;
        case hpesa_MEASURE_METHOD_READ:
            strcpy(SCPIMeasureType, "READ");  break;
        case hpesa_MEASURE_METHOD_FETCH:
            strcpy(SCPIMeasureType, "FETC");  break;
        default:
            return(statusUpdate(instrumentHandle, thisPtr, 
                                                     VI_ERROR_PARAMETER2));
    }

     /*----------------------------------------------------------------*
      |  Retrieve the emission bandwidth value.                        |
      *----------------------------------------------------------------*/
    
    errStatus = delayVQueryf(instrumentHandle,
                             "%s:EBW?\n",
                             "%lg%*t",
                             SCPIMeasureType,
                             emissionBandwidth_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Reset the timeout to the previous value.                      |
      *----------------------------------------------------------------*/

    errStatus = hpesa_timeOut(instrumentHandle, oldTimeOut);
    if(errStatus < VI_SUCCESS) return errStatus;

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                          end hpesa_EBWMeasure                             */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_harmonicDistConfig                                                 */
/*    This method sets up the harmonic distortion measurement operation.     */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle                                           */
/*        - Instrument handle returned from hpesa_init.                      */
/*    ViBoolean   harmonicDistAverageOn                                      */
/*        - Instrument's new harmonic average state.                         */
/*        - Values:                                                          */
/*            VI_TRUE - Averaging on.                                        */
/*            VI_FALSE - Averaging off.                                      */
/*    ViInt16     harmonicDistAverageCount                                   */
/*        - Specifies the number of harmonic measurements that are combined. */
/*    ViInt16     harmonicDistCount                                          */
/*        - The number of harmonics to be measured.                          */
/*    ViInt16     harmonicDistSweepMode                                      */
/*        - Instrument's sweep mode per harmonic.                            */
/*        - Values:                                                          */
/*            hpesa_HARMONIC_SWEEP_AUTO - The sweep time for measuring each  */
/*              harmonic will be set to 200/RBW, where RBW is the resolution */
/*              bandwidth in Hz.                                             */
/*            hpesa_HARMONIC_SWEEP_MANUAL - Allows the user to set the sweep */
/*              time used for the zero span measuring of the harmonics.      */
/*    ViReal64    harmonicDistSweepTime                                      */
/*        - Instrument's new sweep time, in seconds, used to measure each    */
/*          harmonic.  This sweep time is used only for the zero span        */
/*          measuring of the harmonics, and not during the search for the    */
/*          fundamental.  In this case, the sweep time used will be the      */
/*          sweep time used before the measurement began.                    */
/*    ViBoolean   harmonicDistCenterZoomOn                                   */
/*        - Turn off or on the fundamental signal zoom before the frequency  */
/*          count occurs.                                                    */
/*        - Values:                                                          */
/*            VI_TRUE - Fundamental align zoom on.                           */
/*            VI_FALSE - Fundamental align zoom off.                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_harmonicDistConfig
                        (ViSession instrumentHandle,
                         ViBoolean harmonicDistAverageOn,
                         ViInt16 harmonicDistAverageCount,
                         ViInt16 harmonicDistCount,
                         ViBoolean harmonicDistSweepMode,
                         ViReal64 harmonicDistSweepTime,
                         ViBoolean harmonicDistCenterZoomOn)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
        
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_BOOLEAN(harmonicDistAverageOn, VI_ERROR_PARAMETER2)

    CHK_ENUM(harmonicDistSweepMode,
                0, 
                hpesa_HARMONIC_SWEEP_LASTENUM,
                VI_ERROR_PARAMETER5)

    CHK_BOOLEAN(harmonicDistCenterZoomOn, VI_ERROR_PARAMETER7)

     /*----------------------------------------------------------------*
      |  Set the averaging mode for the channel power measurement.     |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "HARM:AVER %d\n", 
                                                       harmonicDistAverageOn);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  If the averaging mode is turned on, then set average count    |
      |  for harmonic distortion.                                      |
      *----------------------------------------------------------------*/

    if(harmonicDistAverageOn)
    {
        errStatus = delayVPrintf(instrumentHandle, "HARM:AVER:COUN %d\n", 
                                                  harmonicDistAverageCount);
        if (errStatus < VI_SUCCESS)
            return statusUpdate(instrumentHandle, thisPtr, errStatus);
    }

     /*----------------------------------------------------------------*
      |  Set the number of harmonics to be measured.                   |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle,
                             "HARM:NUMB %d\n",
                             harmonicDistCount);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Set the harmonic sweep mode.ESA Firmware version prior        |
      |  to A.03.03 used the command HARM:SWE:STAT to set the mode.    |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle,
                             "HARM:SWE:AUTO %d\n",
                             harmonicDistSweepMode);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  If the sweep mode is set to manual, then set the sweep time.  |
      |  ESA Firmware prior to A.03.03 used the command HARM:SWE:TIME. |
      *----------------------------------------------------------------*/

    if(harmonicDistSweepMode==hpesa_HARMONIC_SWEEP_MANUAL)
    {
        errStatus = delayVPrintf(instrumentHandle, "HARM:SWE %.15g\n", 
                                                  harmonicDistSweepTime);
        if (errStatus < VI_SUCCESS)
            return statusUpdate(instrumentHandle, thisPtr, errStatus);
    }

     /*----------------------------------------------------------------*
      |  Turn on or off the fundamental signal zoom.                   |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle,
                             "HARM:ZOOM %d\n",
                             harmonicDistCenterZoomOn);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                       end hpesa_harmonicDistConfig                        */
/*                                                                           */
/*****************************************************************************/




/*****************************************************************************/
/*                                                                           */
/*  hpesa_harmonicDistConfigQuery                                            */
/*    This method retrieves the current harmonic distortion measurement      */
/*    settings.                                                              */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle                                           */
/*        - Instrument handle returned from hpesa_init.                      */
/*    ViPBoolean  harmonicDistAverageOn_Q                                    */
/*        - Instrument's current harmonic average state.                     */
/*    ViPInt16    harmonicDistAverageCount_Q                                 */
/*        - The current number of harmonic measurements that are combined.   */
/*    ViPInt16    harmonicDistCount_Q                                        */
/*        - The current number of harmonics to be measured.                  */
/*    ViPBoolean  harmonicDistSweepMode_Q                                    */
/*        - Instrument's current sweep mode per harmonic.                    */
/*    ViPReal64   harmonicDistSweepTime_Q                                    */
/*        - Instrument's current sweep time (in seconds)                     */
/*    ViPBoolean  harmonicDistCenterZoomOn_Q                                 */
/*        - Instrument's current signal zoom state.                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_harmonicDistConfigQuery
                        (ViSession instrumentHandle,
                         ViPBoolean harmonicDistAverageOn_Q,
                         ViPInt16 harmonicDistAverageCount_Q,
                         ViPInt16 harmonicDistCount_Q,
                         ViPBoolean harmonicDistSweepMode_Q,
                         ViPReal64 harmonicDistSweepTime_Q,
                         ViPBoolean harmonicDistCenterZoomOn_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
        
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(harmonicDistAverageOn_Q, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(harmonicDistAverageCount_Q, VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(harmonicDistCount_Q, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(harmonicDistSweepMode_Q, VI_ERROR_PARAMETER5)
    CHK_NULL_POINTER(harmonicDistSweepTime_Q, VI_ERROR_PARAMETER6)
    CHK_NULL_POINTER(harmonicDistCenterZoomOn_Q, VI_ERROR_PARAMETER7)


     /*----------------------------------------------------------------*
      |  Retrieve the current averaging state                          |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle,
                                "HARM:AVER?\n",
                                "%hd%*t", 
                                harmonicDistAverageOn_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Retrieve the current average count                            |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, 
                                "HARM:AVER:COUN?\n", 
                                "%hd%*t", 
                                harmonicDistAverageCount_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Retrieve the harmonic count                                   |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, 
                             "HARM:NUMB?\n",
                             "%hd%*t", 
                             harmonicDistCount_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Retrieve the current sweep mode.  ESA Firmware version prior  |
      |  to A.03.03 used the command HARM:SWE:STAT to query the mode.  |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, 
                             "HARM:SWE:AUTO?\n",
                             "%hd%*t", 
                             harmonicDistSweepMode_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Retrieve the current sweep time.  ESA Firmware versions prior |
      |  to A.03.03 accepted the command HARM:SWE:TIME?.               |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, 
                             "HARM:SWE?\n",
                             "%lg%*t", 
                             harmonicDistSweepTime_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Retrieve the current signal zoom state                        |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, 
                             "HARM:ZOOM?\n",
                             "%hd%*t", 
                             harmonicDistCenterZoomOn_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);


    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      end hpesa_harmonicDistConfigQuery                    */
/*                                                                           */
/*****************************************************************************/




/*****************************************************************************/
/*                                                                           */
/*  hpesa_harmonicDistMeasure                                                */
/*    This method retrieves the total harmonic distortion as a percentage    */
/*    and the amplitude and frequency values of the harmonics, based on the  */
/*    method of retrieval (measure, read, or fetch).                         */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle                                           */
/*        - Instrument handle returned from hpesa_init.                      */
/*    ViReal64    harmonicDistMeasureTimeout                                 */
/*        - Temporary timeout value in seconds for measurement.              */
/*    ViInt16     harmonicDistMeasureType                                    */
/*        - The method used to retrieve the harmonic measurements.           */
/*        - Values:                                                          */
/*            hpesa_MEASURE_METHOD_MEAS - Initiates and retrieves            */
/*              measurement data from the instrument, using factory default  */
/*              settings.                                                    */
/*            hpesa_MEASURE_METHOD_READ - Initiates and retrieves            */
/*              measurement data from the instrument, using the current      */
/*              setup values.                                                */
/*            hpesa_MEASURE_METHOD_FETCH - Retrieves data from the           */
/*              instrument using the current setup values.  Does not         */
/*              initiate a measurement.                                      */
/*    ViPReal64   harmonicDistTotal_Q                                        */
/*        - The total harmonic distortion as a percentage.                   */
/*    ViInt16     harmonicDistArraySize                                      */
/*        - The number of frequency and amplitude values to retrieve.  This  */
/*          value should normally be the same as the number of harmonics     */
/*          measured.                                                        */
/*    ViReal64    harmonicDistAmplitude[]                                    */
/*        - An array of the amplitude values of the current harmonics.  The  */
/*          first value is measured in dBm (fundamental); all others are     */
/*          measured in dBc.                                                 */
/*    ViReal64    harmonicDistFrequency[]                                    */
/*        - An array of the frequency values of the current harmonics        */
/*          measured in Hz.                                                  */
/*    ViPInt16    harmonicDistValuesRead_Q                                   */
/*        - The actual number of harmonics measured.                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_harmonicDistMeasure
                        (ViSession instrumentHandle,
                         ViReal64 harmonicDistMeasureTimeout,
                         ViInt16 harmonicDistMeasureType,
                         ViPReal64 harmonicDistTotal_Q,
                         ViInt16 harmonicDistArraySize,
                         ViReal64 _VI_FAR harmonicDistAmplitude[],
                         ViReal64 _VI_FAR harmonicDistFrequency[],
                         ViPInt16 harmonicDistValuesRead_Q)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViInt32 oldTimeOut;
    ViInt32 tempCount;
    ViChar SCPIMeasureType[5];

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(harmonicDistMeasureType, hpesa_MEASURE_METHOD_MEAS, 
                         hpesa_MEASURE_METHOD_LASTENUM, VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(harmonicDistTotal_Q, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(harmonicDistAmplitude, VI_ERROR_PARAMETER6)
    CHK_NULL_POINTER(harmonicDistFrequency, VI_ERROR_PARAMETER7)
    CHK_NULL_POINTER(harmonicDistValuesRead_Q, VI_ERROR_PARAMETER8)

    *harmonicDistValuesRead_Q = 0;

     /*----------------------------------------------------------------*
      |  Retrieve the current timeout and then temproarily set a new   |
      |  one.                                                          |
      *----------------------------------------------------------------*/

    errStatus = hpesa_timeOut_Q(instrumentHandle, &oldTimeOut);
    if(errStatus < VI_SUCCESS) return errStatus;

    errStatus = hpesa_timeOut(instrumentHandle, 
                                  (ViInt32)(harmonicDistMeasureTimeout*1000));
    if(errStatus < VI_SUCCESS) return errStatus;

     /*----------------------------------------------------------------*
      |  Set the string to the appropriate SCPI command.               |
      *----------------------------------------------------------------*/

    switch(harmonicDistMeasureType)
    {
        case hpesa_MEASURE_METHOD_MEAS:
            strcpy(SCPIMeasureType, "MEAS");  break;
        case hpesa_MEASURE_METHOD_READ:
            strcpy(SCPIMeasureType, "READ");  break;
        case hpesa_MEASURE_METHOD_FETCH:
            strcpy(SCPIMeasureType, "FETC");  break;
        default:
            return(statusUpdate(instrumentHandle, thisPtr, 
                                                     VI_ERROR_PARAMETER2));
    }

     /*----------------------------------------------------------------*
      |  Get total harmonic distorion                                  |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, 
                                "%s:HARM?\n", 
                                "%lg%*t", 
                                SCPIMeasureType, 
                                harmonicDistTotal_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Since the inital retrieval of data from the harmonic measure  |
      |  will have placed the machine in the state that the user wants,|
      |  the FETCH method will be used to retrieve the remaining data, |
      |  as a MEAS or READ method would do another sweep.              |
      *----------------------------------------------------------------*/

    errStatus = delayVPrintf(instrumentHandle, "FETC:HARM:AMPL:ALL?\n");
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    errStatus = GetCommaArray(instrumentHandle, harmonicDistAmplitude, (ViInt32)harmonicDistArraySize, &tempCount);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    errStatus = delayVPrintf(instrumentHandle, "FETC:HARM:FREQ:ALL?\n");
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    errStatus = GetCommaArray(instrumentHandle, harmonicDistFrequency, harmonicDistArraySize, &tempCount);
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

     /*----------------------------------------------------------------*
      |  Since the fetching of the arrays will always retrieve 10      |
      |  values, even if less are selected, use the SCPI command to    |
      |  retrieve the current number of harmonics set to be measured.  |
      *----------------------------------------------------------------*/

    errStatus = delayVQueryf(instrumentHandle, 
                             "HARM:NUMB?\n",
                             "%hd%*t", 
                             harmonicDistValuesRead_Q);

    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);
        
     /*----------------------------------------------------------------*
      |  Reset the timeout to previous value.                          |
      *----------------------------------------------------------------*/

    errStatus = hpesa_timeOut(instrumentHandle, oldTimeOut);
    if(errStatus < VI_SUCCESS) return errStatus;

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_harmonicDistMeasure                      */
/*                                                                           */
/*****************************************************************************/


/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                     MISCELLANEOUS CONTROL FUNCTIONS                       |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_couplingSetAuto -                                                  */
/*     The instrument can automatically couple instrument settings together  */
/*     for accurate measurements and optimal range.  This method is used to  */
/*     override the coupling for special measuring needs.                    */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*                                                                           */
/*    ViBoolean   autoCouplingOn (in)                                        */
/*        - Select auto couple mode on or off.                               */
/*        - Range:  VI_TRUE (on) or VI_FALSE (off)                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_couplingSetAuto
                        (ViSession instrumentHandle,
                         ViBoolean autoCouplingOn)

{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_BOOLEAN(autoCouplingOn, VI_ERROR_PARAMETER2)

    if(autoCouplingOn)
        errStatus = delayVPrintf(instrumentHandle, "COUP ALL\n");
    else
        errStatus = delayVPrintf(instrumentHandle, "COUP NONE\n");

    if(errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                         end hpesa_couplingSetAuto                         */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_detectorSetMode -                                                  */
/*     This method specifies the detection mode.                             */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*                                                                           */
/*    ViInt16    detectorMode (in)                                           */
/*        - Select the detector mode.                                        */
/*        - Range:  hpesa_DETECTOR_POSITIVEPEAK - Positive peak detection    */
/*                        displays the highest sample taken during the       */
/*                        interval being displayed.                          */
/*                  hpesa_DETECTOR_SAMPLE - Sample detection displays the    */
/*                        first sample taken during the interval being       */
/*                        displayed.                                         */
/*                  hpesa_DETECTOR_NEGATIVEPEAK - Negative peak detection    */
/*                        displays the lowest sample taken during the        */
/*                        interval being displayed.                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_detectorSetMode
                        (ViSession instrumentHandle,
                         ViInt16 detectorMode)

{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
    ViChar SCPIbuffer[5];
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(detectorMode, 0, hpesa_DETECTOR_LASTENUM, VI_ERROR_PARAMETER2)

    switch (detectorMode)
    {
        case hpesa_DETECTOR_POSITIVEPEAK:  sprintf(SCPIbuffer, "POS\0"); 
                                           break;
        case hpesa_DETECTOR_SAMPLE:        sprintf(SCPIbuffer, "SAMP\0");
                                           break;
        case hpesa_DETECTOR_NEGATIVEPEAK:  sprintf(SCPIbuffer, "NEG\0"); 
                                           break;
        default:
         return(statusUpdate(instrumentHandle, thisPtr, VI_ERROR_PARAMETER2));
    }

    errStatus = delayVPrintf(instrumentHandle, "DET %s\n", SCPIbuffer);

    if(errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                         end hpesa_couplingSetAuto                         */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_preAmpSetOn -                                                      */
/*     This method turns the internal preamp on or off.                      */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        - Instrument handle returned from hpesa_init()                     */
/*                                                                           */
/*    ViBoolean   preAmpOn (in)                                              */
/*        - Turn preamp on or off.  .                                        */
/*        - Range:  VI_TRUE (on) or VI_FALSE (off)                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_preAmpSetOn
                        (ViSession instrumentHandle,
                         ViBoolean preAmpOn)

{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;
        
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_BOOLEAN(preAmpOn, VI_ERROR_PARAMETER2)

    errStatus = delayVPrintf(instrumentHandle, "POW:GAIN %d\n", preAmpOn);

    if(errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */
    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                          end hpesa_preAmpSetOn                            */
/*                                                                           */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_preselectorCenter -                                                */
/*     This method centers the preselector tracking to maximum amplitude of  */
/*     the signal at the specified marker by minimizing the loss through     */
/*     the filter.                                                           */
/*                                                                           */
/*     Use the function "hpesa_opc_q" to test instrument for completion of   */
/*     preselector centering                                                 */
/*                                                                           */
/*  PARAMETERS                                                               */
/*    ViSession   instrumentHandle (in)                                      */
/*        Instrument handle returned from hpesa_init()                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_preselectorCenter
                        (ViSession instrumentHandle)
{
    ViStatus  errStatus;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    errStatus = delayVPrintf(instrumentHandle, "POW:PCEN\n");
    if (errStatus < VI_SUCCESS)
        return statusUpdate(instrumentHandle, thisPtr, errStatus);

    /*  Return by calling updateStatus */

    return statusUpdate(instrumentHandle, thisPtr, VI_SUCCESS);
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                        end hpesa_preselectorCenter                        */
/*                                                                           */
/*****************************************************************************/


/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                        VERIFICATION FUNCTIONS                             |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_EnableVerification                                                 */
/*                                                                           */
/*      This function enables or disables checking of various instrument     */
/*      settings.                                                            */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 verifyID                                                       */
/*                                                                           */
/*      The ID of the instrument setting that is to be affected. Possible    */
/*      values are:                                                          */
/*      0 = hpesa_VERIFY_APPLICATION.                                        */
/*                                                                           */
/*      This verification being enabled will result in the Instrument being  */
/*      queried for it's current application when all 'measurement'          */
/*      functions are called. (SPECTRUM AND WAVEFORM are exceptions.) I.e.   */
/*      CHP for CDMAOne or TXP for GSM.                                      */
/*                                                                           */
/*    ViBoolean verifyOn                                                     */
/*                                                                           */
/*      Sets the state of the verification.                                  */
/*      VI_FALSE - Verify off.                                               */
/*      VI_TRUE - Verify on                                                  */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_EnableVerification
                       (ViSession instrumentHandle,
                        ViInt16 verifyID,
                        ViBoolean verifyOn)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(verifyID, 0, hpesa_VERIFY_LASTENUM, VI_ERROR_PARAMETER2)
    CHK_BOOLEAN(verifyOn, VI_ERROR_PARAMETER3)

    switch(verifyID)
    {
        case hpesa_VERIFY_APPLICATION:
            thisPtr->verifyApp = verifyOn;
            break;
        default:
            fprintf(stderr, "Program logic error (case statement) in: "
                "hpesa_EnableVerification()\n");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    return VI_SUCCESS;
}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_EnableVerification                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GetVerification                                                    */
/*                                                                           */
/*      This function returns the state of the specified verify ID.          */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 verifyIDQ                                                      */
/*                                                                           */
/*      Determines which instrument ID verification to retreive.  Possible   */
/*      values are:                                                          */
/*      0 = hpesa_VERIFY_APPLICATION                                         */
/*                                                                           */
/*    ViPBoolean verifyOnQuery                                               */
/*                                                                           */
/*      Returns the State as specified by the verify IDQ.                    */
/*      0 = VI_FALSE (off)                                                   */
/*      1 = VI_TRUE (on)                                                     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GetVerification
                       (ViSession instrumentHandle,
                        ViInt16 verifyIDQ,
                        ViPBoolean verifyOnQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(verifyIDQ, 0, hpesa_VERIFY_LASTENUM, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(verifyOnQuery, VI_ERROR_PARAMETER3)

    switch(verifyIDQ)
    {
        case hpesa_VERIFY_APPLICATION:
            *verifyOnQuery = thisPtr->verifyApp;
            break;
        default:
            fprintf(stderr, "Program logic error (case statement) in: "
                "hpesa_GetVerification()\n");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    return VI_SUCCESS;
}
/*---------------------------------------------------------------------------*/
/*                         end hpesa_GetVerification                         */
/*****************************************************************************/


/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                    APPLICATION SELECTION FUNCTIONS                        |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_InstrumentSetApplication                                           */
/*                                                                           */
/*      Select the measurement Application by enumerated choice. The         */
/*      available choices depend upon which modes are installed in the       */
/*      instrument. Use "hpesa_InstrumentGetAllApplications" to determine    */
/*      applications installed.                                              */
/*                                                                           */
/*      If you are using the SCPI status registers and the analyzer mode is  */
/*      changed, the status bits should be read, and any errors resolved,    */
/*      prior to switching modes. Error conditions that exist prior to       */
/*      switching modes cannot be detected using the condition registers     */
/*      after the mode change. This is true unless they recur after the mode */
/*      change, although transitions of these conditions can be detected     */
/*      using the event registers.                                           */
/*                                                                           */
/*      Changing modes resets all SCPI status registers and mask registers   */
/*      to their power-on defaults. Hence, any event or condition register   */
/*      masks must be re-established after a mode change. Also note that the */
/*      power up status bit is set by any mode change, since that is the     */
/*      default state after power up.                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 instrumentApplication                                          */
/*                                                                           */
/*      Application mode to set.                                             */
/*                                                                           */
/*      hpesa_APPLICATION_SA - Spectrum analyzer mode                        */
/*      hpesa_ APPLICATION _CDMA - CDMA One mode                             */
/*      hpesa_ APPLICATION _GSM - GSM Mode                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_InstrumentSetApplication
                       (ViSession instrumentHandle,
                        ViInt16 instrumentApplication)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    ViChar buffer[64] = "\0";
    ViInt32 temp = 0;
    ViInt32 previousTimeout = 0;

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(instrumentApplication, 0, hpesa_APPLICATION_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)

    // Change the timeout value if necessary
    errStatus = TempTimeoutChange(instrumentHandle, 30000, &previousTimeout);
    if (errStatus < VI_SUCCESS) return errStatus;

    switch(instrumentApplication)
    {
        case hpesa_APPLICATION_SA:
            sprintf(buffer, "INST:SEL 'SA';*OPC?");
            break;

        case hpesa_APPLICATION_CDMA:
            sprintf(buffer, "INST:SEL 'CDMA';*OPC?");
            break;

        case hpesa_APPLICATION_GSM:
            sprintf(buffer, "INST:SEL 'GSM';*OPC?");
            break;

        default:
            fprintf(stderr, "Program logic error (case statement) in: "
                "hpesa_InstrumentSetApplication()\n");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmdInt32_Q(instrumentHandle, buffer, &temp);
    if(errStatus < VI_SUCCESS)
        return errStatus;

    errStatus = hpesa_cmdInt32_Q(instrumentHandle, "INIT;*OPC?", &temp);

    // Set the necessary specified timeout value.
    viSetAttribute(instrumentHandle,VI_ATTR_TMO_VALUE, previousTimeout);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_InstrumentSetApplication                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_InstrumentGetApplication                                           */
/*                                                                           */
/*      This method returns the current measurement mode.                    */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 instrumentApplicationQuery                                    */
/*                                                                           */
/*      Returns the current instrument application.                          */
/*                                                                           */
/*      0 = hpesa_APPLICATION_SA                                             */
/*      1 = hpesa_APPLICATION_CDMA                                           */
/*      2 = hpesa_APPLICATION_GSM                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_InstrumentGetApplication
                       (ViSession instrumentHandle,
                        ViPInt16 instrumentApplicationQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    ViChar buffer[128] = "\0";
    int x = 0;
    char *applicationNames[4] = {"\"SA\"", "\"CDMA\"", "\"GSM\"", NULL};

    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(instrumentApplicationQuery, VI_ERROR_PARAMETER2)

    errStatus = hpesa_cmdString_Q(instrumentHandle,"INST:SEL?",128,buffer);
    buffer[strlen(buffer)-1] = '\0';  // remove the trailing \n

    // Find out whether the return string matches 
    for(x = 0; x <= hpesa_APPLICATION_LASTENUM; x++)
    {
        // If it's not found in the table, return an context error
        if(applicationNames[x] == NULL)
        {
            thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
            sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
            return hpesa_INSTR_ERROR_LOOKUP;
        }

        // Check the table to see if the string exists
        if(!strncmp(buffer,applicationNames[x],strlen(buffer)))
        {
            *instrumentApplicationQuery = x; // and then assign the enum
            break;
        }
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_InstrumentGetApplication                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_InstrumentGetAllApplications                                       */
/*                                                                           */
/*      This method returns a comma separated list which contains the names  */
/*      of all installed applications.                                       */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 applicationsMaxSizeQ                                           */
/*                                                                           */
/*      The maximum size of the applicationsQuery array.                     */
/*                                                                           */
/*    ViPString applicationsQuery                                            */
/*                                                                           */
/*      Returns a comma separated list of all modes installed on the         */
/*      instrument.                                                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_InstrumentGetAllApplications
                       (ViSession instrumentHandle,
                        ViInt32 applicationsMaxSizeQ,
                        ViPString applicationsQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    ViChar buffer[1024] = "\0";
    ViInt32 copysize = 0;
    
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_LONG_RANGE(applicationsMaxSizeQ, 1, hpesa_CMDINT32ARR_Q_MAX, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(applicationsQuery, VI_ERROR_PARAMETER3)

    errStatus = hpesa_cmdString_Q(instrumentHandle,"INST:CAT?",1024,buffer);
    if (errStatus < VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0'; // remove trailing \n

    // if the size of the array returned is bigger than expected
    // only return the array size expected.

    if(applicationsMaxSizeQ < (ViInt32)strlen(buffer))
        copysize = applicationsMaxSizeQ;
    else
        copysize = strlen(buffer);

    strncpy(applicationsQuery,buffer, copysize);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                  end hpesa_InstrumentGetAllApplications                   */
/*****************************************************************************/



/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
 |                                                                           |
 |                                                                           |
 |                           CDMA One FUNCTIONS                              |
 |                                                                           |
 |                                                                           |
 *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/


                        /************************/
                        /*  cdmaOne Mode Setup  */
                        /************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_TriggerSetExternal                                           */
/*                                                                           */
/*      This method sets the CDMA One external trigger configuration.        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1TrigExternalDelay                                        */
/*                                                                           */
/*      Sets the trigger delay, in seconds, when using the external trigger  */
/*      input. Instrument range is 0 ns to 429 s. Anything less than 300 ns  */
/*      is equal to off. Default is 0 s.                                     */
/*                                                                           */
/*    ViInt16 cdma1TrigExternalSlope                                         */
/*                                                                           */
/*      Sets the trigger slope when using the external trigger input.        */
/*      Instrument default is positive.                                      */
/*                                                                           */
/*      hpesa_TRIG_SLOPE_POS - Sets the external trigger to positive.        */
/*                                                                           */
/*      hpesa_TRIG_SLOPE_NEG - Sets the external trigger to negative.        */
/*                                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_TriggerSetExternal
                       (ViSession instrumentHandle,
                        ViReal64 cdma1TrigExternalDelay,
                        ViInt16 cdma1TrigExternalSlope)
{
    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(cdma1TrigExternalSlope, 0, hpesa_TRIG_SLOPE_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)

    VERIFY_APP(hpesa_APPLICATION_CDMA)

    // send the external delay trigger time
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              "TRIG:EXT:DEL", 
                              cdma1TrigExternalDelay);
    if(errStatus < VI_SUCCESS) return errStatus;

    // Set the slope command
    switch(cdma1TrigExternalSlope)
    {
        case hpesa_TRIG_SLOPE_POS:
            sprintf(buffer, "TRIG:EXT:SLOP POS");
            break;
        case hpesa_TRIG_SLOPE_NEG:
            sprintf(buffer, "TRIG:EXT:SLOP NEG");
            break;
        default:
            fprintf(stderr, "Logic error in hpesa_cdma1_TriggerSetExternal");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    // Send it
    errStatus = hpesa_cmd(instrumentHandle, buffer);
   
    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_TriggerSetExternal                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_TriggerGetExternal                                           */
/*                                                                           */
/*      This method retrieves the current CDMA One external trigger          */
/*      configuration.                                                       */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPReal64 cdma1TrigExternalDelayQuery                                  */
/*                                                                           */
/*      Returns current trigger delay, in seconds, when using the external   */
/*      trigger input. Instrument range is 0 ns to 429 s. Anything less than */
/*      300 ns is equal to off. Default is 0 s.                              */
/*                                                                           */
/*    ViPInt16 cdma1TrigExternalSlopeQuery                                   */
/*                                                                           */
/*      Returns the current trigger slope when using the external trigger    */
/*      input. Instrument default is positive.                               */
/*                                                                           */
/*      0 = hpesa_TRIG_SLOPE_POS                                             */
/*      1 = hpesa_TRIG_SLOPE_NEG                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_TriggerGetExternal
                       (ViSession instrumentHandle,
                        ViPReal64 cdma1TrigExternalDelayQuery,
                        ViPInt16 cdma1TrigExternalSlopeQuery)
{
    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(cdma1TrigExternalDelayQuery, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(cdma1TrigExternalSlopeQuery, VI_ERROR_PARAMETER3)

    VERIFY_APP(hpesa_APPLICATION_CDMA)

    // Retrieve the external trigger delay
    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  "TRIG:EXT:DEL?", 
                                  cdma1TrigExternalDelayQuery);
    if(errStatus<VI_SUCCESS) return errStatus;

    // Retrieve the external trigger slope
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  "TRIG:EXT:SLOP?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    if(!strcmp(buffer, "POS\n"))
        *cdma1TrigExternalSlopeQuery = hpesa_TRIG_SLOPE_POS;
    else if (!strcmp(buffer, "NEG\n"))
        *cdma1TrigExternalSlopeQuery = hpesa_TRIG_SLOPE_NEG;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_cdma1_TriggerGetExternal                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_TriggerSetRFBurst                                            */
/*                                                                           */
/*      This method sets up the CDMA One RF Burst (wideband) trigger.        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1TrigRFBurstDelay                                         */
/*                                                                           */
/*      Sets the trigger delay, in seconds, when using the RF burst          */
/*      (wideband) trigger. Instrument range is 0 ns to 429 s. Anything less */
/*      than 300 ns is equal to off. Default is 0 s.                         */
/*                                                                           */
/*    ViReal64 cdma1TrigRFBurstLevel                                         */
/*                                                                           */
/*      Sets the trigger level, in db, when using the RF burst (wideband)    */
/*      trigger. The value is relative to the peak of the signal. RF Burst   */
/*      is also known as RF Envelope. Instrument range is -25 to 0 dB, and   */
/*      default is - 6dB.                                                    */
/*                                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_TriggerSetRFBurst
                       (ViSession instrumentHandle,
                        ViReal64 cdma1TrigRFBurstDelay,
                        ViReal64 cdma1TrigRFBurstLevel)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    VERIFY_APP(hpesa_APPLICATION_CDMA)

    // send the rfburst delay trigger time
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              "TRIG:RFB:DEL", 
                              cdma1TrigRFBurstDelay);
    if(errStatus < VI_SUCCESS) return errStatus;

    // send the rfburst trigger level 
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              "TRIG:RFB:LEV", 
                              cdma1TrigRFBurstLevel);
    if(errStatus < VI_SUCCESS) return errStatus;
	 

    // Send it
    errStatus = hpesa_cmd(instrumentHandle, buffer);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_cdma1_TriggerSetRfBurst                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_TriggerGetRFBurst                                            */
/*                                                                           */
/*      This method retrieves the current CDMA One RF Burst (wideband)       */
/*      trigger configuration.                                               */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPReal64 cdma1TrigRFBurstDelayQuery                                   */
/*                                                                           */
/*      Returns the current trigger delay, in seconds, when using the RF     */
/*      burst (wideband) trigger.                                            */
/*                                                                           */
/*    ViPReal64 cdma1TrigRFBurstLevelQuery                                   */
/*                                                                           */
/*      Returns the current trigger level, in dB, when using the RF burst    */
/*      (wideband) trigger. The value is relative to the peak of the signal. */
/*      RF Burst is also known as RF Envelope.                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_TriggerGetRFBurst
                       (ViSession instrumentHandle,
                        ViPReal64 cdma1TrigRFBurstDelayQuery,
                        ViPReal64 cdma1TrigRFBurstLevelQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(cdma1TrigRFBurstDelayQuery, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(cdma1TrigRFBurstLevelQuery, VI_ERROR_PARAMETER3)
    
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    // Get the trigger delay
    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  "TRIG:RFB:DEL?", 
                                  cdma1TrigRFBurstDelayQuery);
    if(errStatus < VI_SUCCESS) return errStatus;

    // Get the level
    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  "TRIG:RFB:LEV?", 
                                  cdma1TrigRFBurstLevelQuery);
    if(errStatus < VI_SUCCESS) return errStatus;
	    
    if(errStatus<VI_SUCCESS) return errStatus;
	
    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_cdma1_TriggerGetRFBurst                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_TriggerSetFrameTimer                                         */
/*                                                                           */
/*      This method sets the CDMA One Frame Timer trigger configuration.     */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1TrigFrameTimerPeriod                                     */
/*                                                                           */
/*      Sets the frame period, in seconds, when using the external frame     */
/*      timer trigger. If the traffic rate is changed, the value of the      */
/*      frame period is initialized to the preset value. The instrument      */
/*      range is 50 us to 13.65333 s, and the default is 26.6666667 ms.      */
/*                                                                           */
/*    ViReal64 cdma1TrigFrameTimerDelay                                      */
/*                                                                           */
/*      Sets the trigger delay, in seconds, to be used in zero span          */
/*      measurements to adjust the active burst within a mask. Use positive  */
/*      values to achieve trigger delay (that is, to measure later than the  */
/*      trigger source event) and use negative values to achieve pre-trigger */
/*      (that is, to measure earlier than the trigger source event).         */
/*      Instrument range is 0 ns to 429. Anything less than 300 ns is equal  */
/*      to off. Default is 0 s.                                              */
/*                                                                           */
/*    ViInt16 cdma1TrigFrameTimerSlope                                       */
/*                                                                           */
/*      Sets the trigger slope when using the external frame timer trigger.  */
/*      Instrument default is positive.                                      */
/*                                                                           */
/*      hpesa_TRIG_SLOPE_POS - Sets the exteral frame timer slope to         */
/*      positive.                                                            */
/*                                                                           */
/*      hpesa_TRIG_SLOPE_NEG - Sets the external frame timer slope to        */
/*      negative.                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_TriggerSetFrameTimer
                       (ViSession instrumentHandle,
                        ViReal64 cdma1TrigFrameTimerPeriod,
                        ViReal64 cdma1TrigFrameTimerDelay,
                        ViInt16 cdma1TrigFrameTimerSlope )
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(cdma1TrigFrameTimerSlope, 0, hpesa_TRIG_SLOPE_LASTENUM, 
                                                        VI_ERROR_PARAMETER4)

    VERIFY_APP(hpesa_APPLICATION_CDMA)

    // send the FrameTimer trigger period 
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              "TRIG:FRAM:PER", 
                              cdma1TrigFrameTimerPeriod);
    if(errStatus < VI_SUCCESS) return errStatus;

    // send the FrameTimer delay trigger time
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              "TRIG:FRAM:DEL", 
                              cdma1TrigFrameTimerDelay);
    if(errStatus < VI_SUCCESS) return errStatus;

    // Set the slope command
    switch(cdma1TrigFrameTimerSlope)
    {
        case hpesa_TRIG_SLOPE_POS:
            sprintf(buffer, "TRIG:FRAM:SLOP POS");
            break;
        case hpesa_TRIG_SLOPE_NEG:
            sprintf(buffer, "TRIG:FRAM:SLOP NEG");
            break;
        default:
            fprintf(stderr, "Logic error in hpesa_cdma1_TriggerSetFrameTimer");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    // Send it
    errStatus = hpesa_cmd(instrumentHandle, buffer);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_cdma1_TriggerSetFrameTimer                   */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_TriggerGetFrameTimer                                         */
/*                                                                           */
/*      This method retrieves the CDMA One Frame Timer trigger configuration.*/
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPReal64 cdma1TrigFramTimerPerQuery                                   */
/*                                                                           */
/*      Returns the current frame period, in seconds, when using the         */
/*      external frame timer trigger. If the traffic rate is changed, the    */
/*      value of the frame period is initialized to the preset value. The    */
/*      instrument range is 50 us to 13.65333 s, and the default is          */
/*      26.6666667 ms.                                                       */
/*                                                                           */
/*    ViPReal64 cdma1TrigFramTimerDelQuery                                   */
/*                                                                           */
/*      Returns the current trigger delay, in seconds, to be used in zero    */
/*      span measurements to adjust the active burst within a mask. Use      */
/*      positive values to achieve trigger delay (that is, to measure later  */
/*      than the trigger source event) and use negative values to achieve    */
/*      pre-trigger (that is, to measure earlier than the trigger source     */
/*      event). Instrument range is 0 ns to 429. Anything less than 300 ns   */
/*      is equal to off. Default is 0 s.                                     */
/*                                                                           */
/*    ViPInt16 cdma1TrigFramTimerSlpQuery                                    */
/*                                                                           */
/*      Returns the current trigger slope when using the external frame      */
/*      timer trigger.                                                       */
/*      0 = hpesa_TRIG_SLOPE_POS                                             */
/*      1 = hpesa_TRIG_SLOPE_NEG                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_TriggerGetFrameTimer
                       (ViSession instrumentHandle,
                        ViPReal64 cdma1TrigFramTimerPerQuery,
                        ViPReal64 cdma1TrigFramTimerDelQuery,
                        ViPInt16 cdma1TrigFramTimerSlpQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(cdma1TrigFramTimerPerQuery, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(cdma1TrigFramTimerDelQuery, VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(cdma1TrigFramTimerSlpQuery, VI_ERROR_PARAMETER4)

    VERIFY_APP(hpesa_APPLICATION_CDMA)

    // Get the period
    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  "TRIG:FRAM:PER?", 
                                  cdma1TrigFramTimerPerQuery);
    if(errStatus < VI_SUCCESS) return errStatus;

    // Get the trigger delay
    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  "TRIG:FRAM:DEL?", 
                                  cdma1TrigFramTimerDelQuery);
    if(errStatus < VI_SUCCESS) return errStatus;



    // Get and translate the slope
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  "TRIG:FRAM:SLOP?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    if(!strcmp(buffer, "POS\n"))
        *cdma1TrigFramTimerSlpQuery = hpesa_TRIG_SLOPE_POS;
    else if (!strcmp(buffer, "NEG\n"))
        *cdma1TrigFramTimerSlpQuery = hpesa_TRIG_SLOPE_NEG;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_cdma1_TriggerGetFrameTimer                   */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_FrequencySetChannel                                          */
/*                                                                           */
/*      This method sets the RF channel frequency for CDMA One measurements. */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1ChannelFrequency                                         */
/*                                                                           */
/*      Sets the new channel frequency, in Hz. Instrument range is the same  */
/*      as the full frequency span, and the default is 870.03 MHz (radio     */
/*      device type base) for cdmaOne measurements.                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_FrequencySetChannel
                       (ViSession instrumentHandle,
                        ViReal64 cdma1ChannelFrequency )
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = hpesa_cmdReal(instrumentHandle, "CHAN:RFCH:FREQ", 
                                                    cdma1ChannelFrequency);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_cdma1_FrequencySetChannel                    */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_FrequencyGetChannel                                          */
/*                                                                           */
/*      This method retrieves the RF channel frequency for CDMA One          */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPReal64 cdma1ChannelFrequencyQuery                                   */
/*                                                                           */
/*      Returns the current channel frequency, in Hz.                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_FrequencyGetChannel
                       (ViSession instrumentHandle,
                        ViPReal64 cdma1ChannelFrequencyQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(cdma1ChannelFrequencyQuery, VI_ERROR_PARAMETER2)

    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = hpesa_cmdReal64_Q(instrumentHandle, "CHAN:RFCH:FREQ?", 
                                                cdma1ChannelFrequencyQuery);
    

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_cdma1_FrequencyGetChannel                    */
/*****************************************************************************/


                       /*****************************/
                       /*  cdmaOne CHP Measurements */
                       /*****************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CHPConfigure                                                 */
/*                                                                           */
/*      This method sets up the instrument for CDMA One channel power        */
/*      measurements (CHP).                                                  */
/*                                                                           */
/*      This method stops the current measurement and sets up the instrument */
/*      for the Channel Power (CHP) measurement using the factory default    */
/*      instrument settings. It does not initiate the taking of measurement  */
/*      data. This method also turns the averaging function on and sets the  */
/*      number of averages to 10 for all measurements.                       */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CHPConfigure
                       (ViSession instrumentHandle)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = hpesa_cmd(instrumentHandle, "CONF:CHP");

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_cdma1_CHPConfigure                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CHPMeasure                                                   */
/*                                                                           */
/*      This method measures the total RMS power in a specified integration  */
/*      bandwidth. User must be in the cdmaOne mode to use this function.    */
/*                                                                           */
/*      The user can select one of three types of measurement modes:         */
/*      Measure, Read, or Fetch.                                             */
/*                                                                           */
/*      This method returns the CHP measurement results specified by the     */
/*      "cdma1CHPResultsType" parameter as a real array.                     */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1CHPMeasureTimeout                                        */
/*                                                                           */
/*      This value temporarily changes the VISA timeout setting for the      */
/*      duration of the instrument measurement. The user needs to set this   */
/*      value to an appropriate time that will be longer then the expected   */
/*      measurement time. Units are in seconds.                              */
/*                                                                           */
/*    ViInt16 cdma1CHPMeasureType                                            */
/*                                                                           */
/*      Selects measurement type. Note that for hpesa_FETCH type the         */
/*      instrument should already be in this measurement mode else the       */
/*      function will time out. User can select this measurement mode by     */
/*      first using the "MEASURE" or "READ" types or call the                */
/*      hpesa_cdma1_CHPConfigure function.                                   */
/*                                                                           */
/*      hpesa_MEASURE - Stops current measurement, changes to this selected  */
/*      measurement, sets up instrument using factory defaults, makes        */
/*      measurement, returns measurement results.                            */
/*                                                                           */
/*      hpesa_READ - Stops current measurement,  changes to this selected    */
/*      measurement, uses instrument settings from last measurement of this  */
/*      type, makes measurement, returns measurements results.               */
/*                                                                           */
/*      hpesa_FETCH - Returns measurements results only. No new measurement  */
/*      is initiated.                                                        */
/*                                                                           */
/*    ViPReal64 cdma1CHPChannelPowerQ                                        */
/*                                                                           */
/*      Returns the total channel power in the specified integration         */
/*      bandwidth (dBm/<integration bandwidth> Hz).                          */
/*                                                                           */
/*    ViPReal64 cdma1CHPPowSpectDensityQ                                     */
/*                                                                           */
/*      Returns the power (in dBm/Hz) in the specified integration bandwidth.*/
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CHPMeasure
                       (ViSession instrumentHandle,
                        ViReal64 cdma1CHPMeasureTimeout,
                        ViInt16 cdma1CHPMeasureType,
                        ViPReal64 cdma1CHPChannelPowerQ,
                        ViPReal64 cdma1CHPPowSpectDensityQ)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    ViReal64 MeasData[2];
    ViInt32 temp = 0;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_ENUM(cdma1CHPMeasureType, 0, hpesa_MEASURE_METHOD_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(cdma1CHPChannelPowerQ, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(cdma1CHPPowSpectDensityQ, VI_ERROR_PARAMETER5)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = GenMeasureTrace(instrumentHandle,
                               hpesa_APPLICATION_MODE_CHP,
                               cdma1CHPMeasureTimeout,
                               cdma1CHPMeasureType,
                               hpesa_RESULTS_TYPE_1,
                               MeasData,
                               2,
                               &temp);
    if(errStatus < VI_SUCCESS) return errStatus;


    if(temp == 2)
    {
        *cdma1CHPChannelPowerQ = MeasData[0];
        *cdma1CHPPowSpectDensityQ = MeasData[1];
        errStatus = VI_SUCCESS;
    }
    else
        errStatus = hpesa_INSTR_ERROR_UNEXPECTED;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_cdma1_CHPMeasure                         */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CHPMeasureTrace                                              */
/*                                                                           */
/*      This method measures the total RMS power in a specified integration  */
/*      bandwidth. User must be in the cdmaOne mode to use this function.    */
/*                                                                           */
/*      User can select one of three types of measurement modes: Measure,    */
/*      Read, or Fetch.                                                      */
/*                                                                           */
/*      This method returns the CHP measurement results specified by the     */
/*      "cdma1CHPResultsType" parameter as a real array.                     */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1CHPMeasureTraceTimeout                                   */
/*                                                                           */
/*      This value temporarily changes the VISA timeout setting for the      */
/*      duration of the instrument measurement. The user needs to set this   */
/*      value to an appropriate time that will be longer then the expected   */
/*      measurement time. Units are in seconds.                              */
/*                                                                           */
/*    ViInt16 cdma1CHPMeasureTraceType                                       */
/*                                                                           */
/*      Selects measurement type. Note that for hpesa_FETCH type the         */
/*      instrument should already be in this measurement mode else the       */
/*      function will time out. User can select this measurement mode by     */
/*      first using the "MEASURE" or "READ" types or call the                */
/*      hpesa_cdma1_CHPConfigure function.                                   */
/*                                                                           */
/*      hpesa_MEASURE - Stops current measurement, changes to this selected  */
/*      measurement, sets up instrument using factory defaults, makes        */
/*      measurement, returns measurement results.                            */
/*                                                                           */
/*      hpesa_READ - Stops current measurement,  changes to this selected    */
/*      measurement, uses instrument settings from last measurement of this  */
/*      type, makes measurement, returns measurements results.               */
/*                                                                           */
/*      hpesa_FETCH - Returns measurements results only. No new measurement  */
/*      is initiated.                                                        */
/*                                                                           */
/*    ViInt16 cdma1CHPResultsType                                            */
/*                                                                           */
/*      Determines the format of the data returned in cdma1CHPDataResults.   */
/*                                                                           */
/*      RESULTS_TYPE_0: Not supported by instrument.                         */
/*                                                                           */
/*      RESULTS_TYPE_1:                                                      */
/*      Returns 2 scalar results:                                            */
/*      1. Channel Power is the total channel power in the specified         */
/*      integration bandwidth (dBm/<integration bandwidth> Hz).              */
/*      2. Power Spectral Density is the power (in dBm/Hz) in the specified  */
/*      integration bandwidth.                                               */
/*                                                                           */
/*    ViAReal64 cdma1CHPDataResults                                          */
/*                                                                           */
/*      Trace data returned by measurement, formatted according to           */
/*      cdma1CHPResultsType.                                                 */
/*                                                                           */
/*    ViInt32 cdma1CHPDataResultsMaxSz                                       */
/*                                                                           */
/*      Specifies the maximum size of CHPDataResults array.                  */
/*                                                                           */
/*    ViPInt32 cdma1CHPDataResultsSz                                         */
/*                                                                           */
/*      Returns the actual size of CHPDataResults array.                     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CHPMeasureTrace
                       (ViSession instrumentHandle,
                        ViReal64 cdma1CHPMeasureTraceTimeout,
                        ViInt16 cdma1CHPMeasureTraceType,
                        ViInt16 cdma1CHPResultsType ,
                        ViAReal64 cdma1CHPDataResults ,
                        ViInt32 cdma1CHPDataResultsMaxSz,
                        ViPInt32 cdma1CHPDataResultsSz)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    int CHPValidResults[7] = {0,1,0,0,0,0,0};
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_ENUM(cdma1CHPMeasureTraceType, 0, hpesa_MEASURE_METHOD_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)
    CHK_ENUM(cdma1CHPResultsType, 0, hpesa_RESULTS_TYPE_LASTENUM,
                                                        VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(cdma1CHPDataResults, VI_ERROR_PARAMETER5)
    CHK_NULL_POINTER(cdma1CHPDataResultsSz, VI_ERROR_PARAMETER7)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    if((cdma1CHPResultsType > 6) || (CHPValidResults[cdma1CHPResultsType] == 0))
        return hpesa_INSTR_ERROR_INVALID_RESULTS_TYPE;

    errStatus = GenMeasureTrace(instrumentHandle,
                               hpesa_APPLICATION_MODE_CHP,
                               cdma1CHPMeasureTraceTimeout,
                               cdma1CHPMeasureTraceType,
                               cdma1CHPResultsType,
                               cdma1CHPDataResults,
                               cdma1CHPDataResultsMaxSz,
                               cdma1CHPDataResultsSz);
    if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_CHPMeasureTrace                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CHPSetAveraging                                              */
/*                                                                           */
/*      This method sets up averaging for CDMA One channel power (CHP)       */
/*      measurements. User can control the number of averages, turn on and   */
/*      off averaging, and set the terminal control mode for averaging.      */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 cdma1CHPAverageCount                                           */
/*                                                                           */
/*      Sets the number of data acquisitions that will be averaged. After    */
/*      the specified number of average counts, the averaging mode (terminal */
/*      control) setting determines the averaging action. The instrument     */
/*      range is 1 to 1000.                                                  */
/*                                                                           */
/*    ViBoolean cdma1CHPAverageState                                         */
/*                                                                           */
/*      Turns averaging on or off.                                           */
/*                                                                           */
/*      VI_TRUE - Turns averaging on.                                        */
/*      VI_FALSE - Turns averaging off.                                      */
/*                                                                           */
/*    ViInt16 cdma1CHPAverageMode                                            */
/*                                                                           */
/*      Selects the type of terminal control for averaging.                  */
/*                                                                           */
/*      hpesa_AVERAGE_EXPONENTIAL  - Each successive data acquisition after  */
/*      the average count is reached, is exponentially weighted and combined */
/*      with the existing average.                                           */
/*                                                                           */
/*      hpesa_AVERAGE_REPEAT - After reaching the average count, the         */
/*      averaging is reset and a new average is started                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CHPSetAveraging
                       (ViSession instrumentHandle,
                        ViInt32 cdma1CHPAverageCount,
                        ViBoolean cdma1CHPAverageState,
                        ViInt16 cdma1CHPAverageMode)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_BOOLEAN(cdma1CHPAverageState, VI_ERROR_PARAMETER3)
    CHK_ENUM(cdma1CHPAverageMode, 0, hpesa_AVERAGE_MODE_LASTENUM,
                                                        VI_ERROR_PARAMETER4)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = GenSetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_CHP,
                                cdma1CHPAverageCount,
                                cdma1CHPAverageState,
                                cdma1CHPAverageMode);
    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_CHPSetAveraging                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CHPGetAveraging                                              */
/*                                                                           */
/*      This method retrieves the averaging setup for the CDMA One channel   */
/*      power (CHP) measurements.                                            */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt32 cdma1CHPAverageCountQuery                                     */
/*                                                                           */
/*      Returns the current number of data acquisitions being averaged for   */
/*      CDMA One CHP measurements.                                           */
/*                                                                           */
/*    ViPBoolean cdma1CHPAverageStateQuery                                   */
/*                                                                           */
/*      Returns the current average state for CDMA One CHP measurements.     */
/*                                                                           */
/*      0 = VI_FALSE                                                         */
/*      1 = VI_TRUE                                                          */
/*                                                                           */
/*    ViPInt16 cdma1CHPAverageModeQuery                                      */
/*                                                                           */
/*      Returns the current type of terminal control for CDMA One CHP        */
/*      averaging.                                                           */
/*      0 = hpesa_AVERAGE_EXPONENTIAL                                        */
/*      1 = hpesa_AVERAGE_REPEAT                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CHPGetAveraging
                       (ViSession instrumentHandle,
                        ViPInt32 cdma1CHPAverageCountQuery,
                        ViPBoolean cdma1CHPAverageStateQuery,
                        ViPInt16 cdma1CHPAverageModeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_NULL_POINTER(cdma1CHPAverageCountQuery,VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(cdma1CHPAverageStateQuery,VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(cdma1CHPAverageModeQuery,VI_ERROR_PARAMETER4)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = GenGetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_CHP,
                                cdma1CHPAverageCountQuery,
                                cdma1CHPAverageStateQuery,
                                cdma1CHPAverageModeQuery);
    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_CHPGetAveraging                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CHPSetIntegrationBW                                          */
/*                                                                           */
/*      This method sets the integration bandwidth for CDMA One channel      */
/*      power (CHP) measurements.                                            */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1CHPIntegrationBW                                         */
/*                                                                           */
/*      Sets the new integration bandwidth, in Hz. The instrument's range is */
/*      1 kHz to instrument span maximum, and the default is 1.23 MHz.       */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CHPSetIntegrationBW
                       (ViSession instrumentHandle,
                        ViReal64 cdma1CHPIntegrationBW)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = hpesa_cmdReal(instrumentHandle, 
                              "CHP:BAND:INT", 
                              cdma1CHPIntegrationBW);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_cdma1_CHPSetIntegrationBW                    */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CHPGetIntegrationBW                                          */
/*                                                                           */
/*      This method retrieves the integration bandwidth for CDMA One channel */
/*      power (CHP) measurements.                                            */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPReal64 cdma1CHPIntegrationBWQuery                                   */
/*                                                                           */
/*      Returns the current integration bandwidth for CDMA One channel power */
/*      (CHP) measurements, in Hz                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CHPGetIntegrationBW
                       (ViSession instrumentHandle,
                        ViPReal64 cdma1CHPIntegrationBWQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_NULL_POINTER(cdma1CHPIntegrationBWQuery, VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  "CHP:BAND:INT?", 
                                  cdma1CHPIntegrationBWQuery);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_cdma1_CHPGetIntegrationBW                    */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CHPSetFrequencySpan                                          */
/*                                                                           */
/*      This method sets the span frequency for CDMA One channel power (CHP) */
/*      measurements.  If resolution bandwidth is set to a value less than 1 */
/*      kHz, then the maximum span is limited to 5 MHz.                      */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1CHPFrequencySpan                                         */
/*                                                                           */
/*      Sets the new span frequency, in Hz. Instrument range is the          */
/*      intergration bandwidth (IBW) to IBW x 400 and the default is 2 MHz.  */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CHPSetFrequencySpan
                       (ViSession instrumentHandle,
                        ViReal64 cdma1CHPFrequencySpan)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = hpesa_cmdReal(instrumentHandle, 
                              "CHP:FREQ:SPAN", 
                              cdma1CHPFrequencySpan);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_cdma1_CHPSetFrequencySpan                    */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CHPGetFrequencySpan                                          */
/*                                                                           */
/*      This method retrieves the current span frequency for CDMA One        */
/*      channel power (CHP) measurements.                                    */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPReal64 cdma1CHPFrequencySpanQuery                                   */
/*                                                                           */
/*      Returns the current span frequency, in Hz.                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CHPGetFrequencySpan
                       (ViSession instrumentHandle,
                        ViPReal64 cdma1CHPFrequencySpanQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_NULL_POINTER(cdma1CHPFrequencySpanQuery, VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  "CHP:FREQ:SPAN?", 
                                  cdma1CHPFrequencySpanQuery);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_cdma1_CHPGetFrequencySpan                    */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CHPSetTriggerSource                                          */
/*                                                                           */
/*      This method sets the trigger source for CDMA One channel power (CHP) */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 cdma1CHPTriggerSource                                          */
/*                                                                           */
/*      Sets the trigger source for CDMA One channel power measurements.     */
/*                                                                           */
/*      hpesa_CHP_TRIG_IMMEDIATE - the next data acquisition is immediately  */
/*      taken (also called Free Run).                                        */
/*                                                                           */
/*      hpesa_CHP_TRIG _EXTERNAL - rear panel external trigger input.        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CHPSetTriggerSource
                       (ViSession instrumentHandle,
                        ViInt16 cdma1CHPTriggerSource)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(cdma1CHPTriggerSource, 0, hpesa_CHP_TRIG_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    switch(cdma1CHPTriggerSource)
    {
        case hpesa_CHP_TRIG_IMMEDIATE:
            sprintf(buffer, "CHP:TRIG:SOUR IMM");
            break;
        case hpesa_CHP_TRIG_EXTERNAL:
            sprintf(buffer, "CHP:TRIG:SOUR EXT");
            break;
        default:
            fprintf(stderr, "Logic error in hpesa_cdma1_CHPSetTriggerSource");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, buffer);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_cdma1_CHPSetTriggerSource                    */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CHPGetTriggerSource                                          */
/*                                                                           */
/*      This method sets the trigger source for CDMA One channel power (CHP) */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 cdma1CHPTriggerSourceQuery                                    */
/*                                                                           */
/*      Returns the current trigger source for CDMA One channel power        */
/*      measurements.                                                        */
/*                                                                           */
/*      0 = hpesa_CHP_TRIG_IMMEDIATE                                         */
/*      1 = hpesa_CHP_TRIG_EXTERNAL                                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CHPGetTriggerSource
                       (ViSession instrumentHandle,
                        ViPInt16 cdma1CHPTriggerSourceQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(cdma1CHPTriggerSourceQuery, VI_ERROR_PARAMETER2)

    VERIFY_APP(hpesa_APPLICATION_CDMA)

    // Retrieve the external trigger slope
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  "CHP:TRIG:SOUR?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0';  // strip the trailing \n

    if(!strcmp(buffer, "IMM"))
        *cdma1CHPTriggerSourceQuery = hpesa_CHP_TRIG_IMMEDIATE;
    else if (!strcmp(buffer, "EXT"))
        *cdma1CHPTriggerSourceQuery = hpesa_CHP_TRIG_EXTERNAL;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_cdma1_CHPGetTriggerSource                    */
/*****************************************************************************/


                       /*****************************/
                       /*  cdmaOne RHO Measurements */
                       /*****************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_RHOConfigure                                                 */
/*                                                                           */
/*      This method sets up the instrument for CDMA One modulation accuracy  */
/*      measurements (RHO).                                                  */
/*                                                                           */
/*      This function stops the current measurement and sets up the          */
/*      instrument for the Modulation Accuracy (RHO) measurement using the   */
/*      factory default instrument settings. It does not initiate the taking */
/*      of measurement data. This command also turns the averaging function  */
/*      on and sets the number of averages to 10 for all measurements.       */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_RHOConfigure
                       (ViSession instrumentHandle)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    ViInt16 temp = 0;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = hpesa_cmdInt16_Q(instrumentHandle, "CONF:RHO;*OPC?", &temp);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_cdma1_RHOConfigure                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_RHOMeasure                                                   */
/*                                                                           */
/*      This method measures the CDMA One modulation accuracy of the         */
/*      transmitter by checking the magnitude and phase error and the EVM    */
/*      (error vector magnitude). User must be in the cdmaOne application    */
/*      mode to use these commands.                                          */
/*                                                                           */
/*      User can select one of three types of measurement modes: Measure,    */
/*      Read, or Fetch.                                                      */
/*                                                                           */
/*      This function returns 7 RHO measurement scalar results, as described */
/*      in the parameters below.                                             */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1RHOMeasureTimeout                                        */
/*                                                                           */
/*      This value temporarily changes the VISA timeout setting for the      */
/*      duration of the instrument measurement. The user needs to set this   */
/*      value to an appropriate time that will be longer then the expected   */
/*      measurement time. Units are in seconds.                              */
/*                                                                           */
/*    ViInt16 cdma1RHOMeasureType                                            */
/*                                                                           */
/*      Selects measurement type. Note that for hpesa_FETCH type the         */
/*      instrument should already be in this measurement mode else the       */
/*      function will time out. User can select this measurement mode by     */
/*      first using the "MEASURE" or "READ" types or call the                */
/*      hpesa_cdma1_RHOConfigure function.                                   */
/*                                                                           */
/*      hpesa_MEASURE - Stops current measurement, changes to this selected  */
/*      measurement, sets up instrument using factory defaults, makes        */
/*      measurement, returns measurement results.                            */
/*                                                                           */
/*      hpesa_READ - Stops current measurement,  changes to this selected    */
/*      measurement, uses instrument settings from last measurement of this  */
/*      type, makes measurement, returns measurements results.               */
/*                                                                           */
/*      hpesa_FETCH - Returns measurements results only. No new measurement  */
/*      is initiated.                                                        */
/*    ViPReal64 cdma1RHOModAccuracyQuery                                     */
/*                                                                           */
/*      Returns RHO (no units) representing the correlation of the measured  */
/*      power compared to the ideal pilot channel. The calculation is        */
/*      performed after the complimentary filter, so it is IS95 compliant.   */
/*      It is performed at the decision points in the pilot waveform. If     */
/*      averaging is on, this is the average of the individual RMS           */
/*      measurements.                                                        */
/*                                                                           */
/*    ViPReal64 cdma1RHOTimeOffsetQuery                                      */
/*                                                                           */
/*      Returns the time offset (with units of seconds) which is the time    */
/*      delay of the even second clock with respect to the start of the      */
/*      short code PN sequences, at offsets from the 15 zeros in the         */
/*      characteristic phase of the sequence.                                */
/*                                                                           */
/*    ViPReal64 cdma1RHOFreqErrorQuery                                       */
/*                                                                           */
/*      Returns the frequency error of the measured signal, with units of    */
/*      Hz. This is based on the linear best fit of the uncorrected measured */
/*      phase.                                                               */
/*                                                                           */
/*    ViPReal64 cdma1RHOCarrFeedthruQuery                                    */
/*                                                                           */
/*      Returns the carrier feedthrough has units of dB and is the DC error  */
/*      offset of I and Q, from the origin.                                  */
/*                                                                           */
/*    ViPReal64 cdma1RHOErrVectMagQuery                                      */
/*                                                                           */
/*      Returns the error vector magnitude (EVM) as units of percent. The    */
/*      calculation is based on the composite of the phase error and         */
/*      magnitude error, between the measured signal and the ideal pilot     */
/*      channel. It is performed after the complimentary filter, which       */
/*      removes the intersymbol interference in the modulated data. If       */
/*      averaging is on, this is the average of the individual RMS           */
/*      measurements.                                                        */
/*                                                                           */
/*    ViPReal64 cdma1RHOMagErrorQuery                                        */
/*                                                                           */
/*      Returns the magnitude error (with units of percent), which is the    */
/*      RMS error between the measured (compensated) magnitude and the ideal */
/*      magnitude. This is performed after the complimentary filter, which   */
/*      removes the inter-symbol interference in the modulated data. If      */
/*      averaging is on, this is the average of the individual RMS           */
/*      measurements.                                                        */
/*                                                                           */
/*    ViPReal64 cdma1RHOPhaseErrorQuery                                      */
/*                                                                           */
/*      Returns the phase error (with units in percent), which is the RMS    */
/*      phase error between the measured phase and the ideal phase. The      */
/*      calculation is performed after the complimentary filter, which       */
/*      removes the intersymbol interference in the modulated data. If       */
/*      averaging is on, this is the average of the individual RMS           */
/*      measurements.                                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_RHOMeasure
                       (ViSession instrumentHandle,
                        ViReal64 cdma1RHOMeasureTimeout,
                        ViInt16 cdma1RHOMeasureType,
                        ViPReal64 cdma1RHOModAccuracyQuery,
                        ViPReal64 cdma1RHOTimeOffsetQuery,
                        ViPReal64 cdma1RHOFreqErrorQuery,
                        ViPReal64 cdma1RHOCarrFeedthruQuery,
                        ViPReal64 cdma1RHOErrVectMagQuery,
                        ViPReal64 cdma1RHOMagErrorQuery,
                        ViPReal64 cdma1RHOPhaseErrorQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    ViReal64 MeasData[10];
    ViInt32 temp = 0;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_ENUM(cdma1RHOMeasureType, 0, hpesa_MEASURE_METHOD_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(cdma1RHOModAccuracyQuery, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(cdma1RHOTimeOffsetQuery, VI_ERROR_PARAMETER5)
    CHK_NULL_POINTER(cdma1RHOFreqErrorQuery, VI_ERROR_PARAMETER6)
    CHK_NULL_POINTER(cdma1RHOCarrFeedthruQuery, VI_ERROR_PARAMETER7)
    CHK_NULL_POINTER(cdma1RHOErrVectMagQuery, VI_ERROR_PARAMETER8)
    CHK_NULL_POINTER(cdma1RHOMagErrorQuery, hpesa_INSTR_ERROR_PARAMETER9)
    CHK_NULL_POINTER(cdma1RHOPhaseErrorQuery, hpesa_INSTR_ERROR_PARAMETER10)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = GenMeasureTrace(instrumentHandle,
                               hpesa_APPLICATION_MODE_RHO,
                               cdma1RHOMeasureTimeout,
                               cdma1RHOMeasureType,
                               hpesa_RESULTS_TYPE_1,
                               MeasData,
                               10,
                               &temp);
    if(errStatus < VI_SUCCESS) return errStatus;


    if(temp == 7)
    {
        * cdma1RHOModAccuracyQuery = MeasData[0];
        * cdma1RHOTimeOffsetQuery = MeasData[1];
        * cdma1RHOFreqErrorQuery = MeasData[2];
        * cdma1RHOCarrFeedthruQuery = MeasData[3];
        * cdma1RHOErrVectMagQuery = MeasData[4];
        * cdma1RHOMagErrorQuery = MeasData[5];
        * cdma1RHOPhaseErrorQuery = MeasData[6];
       
        errStatus = VI_SUCCESS;
    }
    else
        errStatus = hpesa_INSTR_ERROR_UNEXPECTED;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_cdma1_RHOMeasure                         */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_RHOMeasureTrace                                              */
/*                                                                           */
/*      This method measures the CDMA One modulation accuracy of the         */
/*      transmitter by checking the magnitude and phase error and the EVM    */
/*      (error vector magnitude). User must be in the cdmaOne application    */
/*      mode to use these commands.                                          */
/*                                                                           */
/*      User can select one of three types of measurement modes: Measure,    */
/*      Read, or Fetch.                                                      */
/*                                                                           */
/*      Function returns the ACPR measurement results specified by the       */
/*      "cdma1RHOResultsType" parameter as a real array.                     */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1RHOMeasureTraceTimeout                                   */
/*                                                                           */
/*      This value temporarily changes the VISA timeout setting for the      */
/*      duration of the instrument measurement. The user needs to set this   */
/*      value to an appropriate time that will be longer then the expected   */
/*      measurement time. Units are in seconds.                              */
/*                                                                           */
/*    ViInt16 cdma1RHOMeasureTraceType                                       */
/*                                                                           */
/*      Selects measurement type. Note that for hpesa_FETCH type the         */
/*      instrument should already be in this measurement mode else the       */
/*      function will time out. User can select this measurement mode by     */
/*      first using the "MEASURE" or "READ" types or call the                */
/*      hpesa_cdma1_RHOConfigure function.                                   */
/*                                                                           */
/*      hpesa_MEASURE - Stops current measurement, changes to this selected  */
/*      measurement, sets up instrument using factory defaults, makes        */
/*      measurement, returns measurement results.                            */
/*                                                                           */
/*      hpesa_READ - Stops current measurement,  changes to this selected    */
/*      measurement, uses instrument settings from last measurement of this  */
/*      type, makes measurement, returns measurements results.               */
/*                                                                           */
/*      hpesa_FETCH - Returns measurements results only. No new measurement  */
/*      is initiated.                                                        */
/*                                                                           */
/*    ViInt16 cdma1RHOResultsType                                            */
/*                                                                           */
/*      Determines the format of the values returned in                      */
/*      cdma1_RHODataResults.                                                */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_0:                                                */
/*      Returns unprocessed I/Q trace in volts. The I values are listed      */
/*      first in each pair, using the 0 through even-indexed values. The Q   */
/*      values are the odd-indexed values.                                   */
/*      The standard sample rate is 4.9152 MHz and the trace length is       */
/*      determined by the current measurement interval.                      */
/*      The number of trace points depends on the current measurement        */
/*      interval and points per chip settings.                               */
/*      The numbers are sent in the following order:                         */
/*      In-phase (I) sample, of symbol 0 decision point                      */
/*      Quadrature-phase (Q) sample, of symbol 0 decision point              */
/*      ...                                                                  */
/*      In-phase (I) sample, of symbol 1 decision point                      */
/*      Quadrature-phase (Q) sample, of symbol 1 decision point              */
/*      ...                                                                  */
/*      The trace can be interpolated to 1, 2, 4 points/chip selected with   */
/*      the display Points/Chip softkey or the NSPC remote command.          */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_1:                                                */
/*      Returns 7 floating point numbers, in the following order:            */
/*      1. Rho (no units) represents the correlation of the measured power   */
/*      compared to the ideal pilot channel. The calculation is performed    */
/*      after the complimentary filter, so it is IS95 compliant. It is       */
/*      performed at the decision points in the pilot waveform. If averaging */
/*      is on, this is the average of the individual RMS measurements.       */
/*      2. Time offset (with units of seconds) is the time delay of the even */
/*      second clock with respect to the start of the short code PN          */
/*      sequences, at offsets from the 15 zeros in the characteristic phase  */
/*      of the sequence.                                                     */
/*      3. Frequency error of the measured signal, with units of Hz. This is */
/*      based on the linear best fit of the uncorrected measured phase.      */
/*      4. Carrier feedthrough has units of dB and is the DC error offset of */
/*      I and Q, from the origin.                                            */
/*      5. EVM has units of percent. The calculation is based on the         */
/*      composite of the phase error and magnitude error, between the        */
/*      measured signal and the ideal pilot channel. It is performed after   */
/*      the complimentary filter, which removes the intersymbol interference */
/*      in the modulated data. If averaging is on, this is the average of    */
/*      the individual RMS measurements.                                     */
/*      6. Magnitude error (with units of percent) is the RMS error between  */
/*      the measured (compensated) magnitude and the ideal magnitude. This   */
/*      is performed after the complimentary filter, which removes the       */
/*      inter-symbol interference in the modulated data. If averaging is on, */
/*      this is the average of the individual RMS measurements.              */
/*      7. Phase error (with units in percent) is the RMS phase error        */
/*      between the measured phase and the ideal phase. The calculation is   */
/*      performed after the complimentary filter, which removes the          */
/*      intersymbol interference in the modulated data. If averaging is on,  */
/*      this is the average of the individual RMS measurements.              */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_2:                                                */
/*      Returns a trace of the error vector magnitude (EVM in percent. The   */
/*      first value is the chip 0 decision point. The trace is interpolated  */
/*      for the currently selected points/chips displayed on the front       */
/*      panel. The number of trace points depends on the current measurement */
/*      interval setting.                                                    */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_3:                                                */
/*      Returns a trace of the magnitude in percent. The first value is the  */
/*      chip 0 decision point. The trace is interpolated for the currently   */
/*      selected points/chips displayed on the front panel. The number of    */
/*      trace points depends on the current measurement interval setting.    */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_4:                                                */
/*      Returns a trace of the phase error in degrees. The first value is    */
/*      the symbol 0 decision point. The trace is interpolated for the       */
/*      currently selected chips/symbol displayed on the front panel. The    */
/*      number of trace points depends on the current measurement            */
/*      Interval setting.                                                    */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_5: Not supported by instrument.                   */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_6:                                                */
/*      Returns a series of floating point numbers that alternately          */
/*      represent I and Q pairs of the complimentary filtered measured data. */
/*      This is inverse filtered data of the intersymbol interference in     */
/*      CDMA signals due to the digital transmission filters defined in the  */
/*      standard as well as the base station phase equalization filter.      */
/*      The numbers are sent in the following order:                         */
/*        In-phase (I) sample, of symbol 0 decision point                    */
/*        Quadrature-phase (Q) sample, of symbol 0 decision point            */
/*        ...                                                                */
/*        In-phase (I) sample, of symbol 1 decision point                    */
/*        Quadrature-phase (Q) sample, of symbol 1 decision point            */
/*        ...                                                                */
/*      The trace can be interpolated to 2,4,8 points/chip selected with the */
/*      display Points/Chip softkey. This will change the number of points   */
/*      between decision points in the trace, changing the number of I/Q     */
/*      pairs sent for each decision point.  The number of trace points      */
/*      depends on the current measurement interval setting.                 */
/*                                                                           */
/*    ViAReal64 cdma1RHODataResults                                          */
/*                                                                           */
/*      Trace data returned by measurement, formatted according to           */
/*      cdma1RHOResultsType.                                                 */
/*                                                                           */
/*    ViInt32 cdma1RHODataResultsMaxSz                                       */
/*                                                                           */
/*      Maximum size of cdma1RHOTraceDataResults array.                      */
/*                                                                           */
/*    ViPInt32 cdma1RHODataResultsSz                                         */
/*                                                                           */
/*      Actual size of cdma1RHOTraceDataResults array.                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_RHOMeasureTrace
                       (ViSession instrumentHandle,
                        ViReal64 cdma1RHOMeasureTraceTimeout,
                        ViInt16 cdma1RHOMeasureTraceType,
                        ViInt16 cdma1RHOResultsType,
                        ViAReal64 cdma1RHODataResults,
                        ViInt32 cdma1RHODataResultsMaxSz,
                        ViPInt32 cdma1RHODataResultsSz)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    int RHOValidResults[7] = {1,1,1,1,1,0,1};
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_ENUM(cdma1RHOMeasureTraceType, 0, hpesa_MEASURE_METHOD_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)
    CHK_ENUM(cdma1RHOResultsType, 0, hpesa_RESULTS_TYPE_LASTENUM,
                                                        VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(cdma1RHODataResults, VI_ERROR_PARAMETER5)
    CHK_NULL_POINTER(cdma1RHODataResultsSz, VI_ERROR_PARAMETER7)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    if((cdma1RHOResultsType > 6) || (RHOValidResults[cdma1RHOResultsType] == 0))
        return hpesa_INSTR_ERROR_INVALID_RESULTS_TYPE;

    errStatus = GenMeasureTrace(instrumentHandle,
                               hpesa_APPLICATION_MODE_RHO,
                               cdma1RHOMeasureTraceTimeout,
                               cdma1RHOMeasureTraceType,
                               cdma1RHOResultsType,
                               cdma1RHODataResults,
                               cdma1RHODataResultsMaxSz,
                               cdma1RHODataResultsSz);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_RHOMeasureTrace                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_RHOSetAveraging                                              */
/*                                                                           */
/*      This method sets up averaging for CDMA One modulation accuracy (RHO) */
/*      measurements. User can control the number of averages, turn on and   */
/*      off averaging, and set the terminal control mode for averaging.      */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 cdma1RHOAverageCount                                           */
/*                                                                           */
/*      Sets the number of frames that will be averaged. After the specified */
/*      number of frames (average counts), the averaging mode (terminal      */
/*      control) setting determines the averaging action.                    */
/*                                                                           */
/*    ViBoolean cdma1RHOAverageState                                         */
/*                                                                           */
/*      Turns averaging on or off.                                           */
/*                                                                           */
/*      VI_TRUE - Turns averaging on.                                        */
/*      VI_FALSE - Turns averaging off.                                      */
/*                                                                           */
/*    ViInt16 cdma1RHOAverageMode                                            */
/*                                                                           */
/*      Selects the type of terminal control for averaging.                  */
/*                                                                           */
/*      hpesa_ AVERAGE_EXPONENTIAL  - Each successive data acquisition after */
/*      the average count is reached, is exponentially weighted and combined */
/*      with the existing average.                                           */
/*                                                                           */
/*      hpesa_ AVERAGE_REPEAT - After reaching the average count, the        */
/*      averaging is reset and a new average is started.                     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_RHOSetAveraging
                       (ViSession instrumentHandle,
                        ViInt32 cdma1RHOAverageCount,
                        ViBoolean cdma1RHOAverageState,
                        ViInt16 cdma1RHOAverageMode)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_BOOLEAN(cdma1RHOAverageState, VI_ERROR_PARAMETER3)
    CHK_ENUM(cdma1RHOAverageMode, 0, hpesa_AVERAGE_MODE_LASTENUM,
                                                        VI_ERROR_PARAMETER4)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = GenSetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_RHO,
                                cdma1RHOAverageCount,
                                cdma1RHOAverageState,
                                cdma1RHOAverageMode);
    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_RHOSetAveraging                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_RHOGetAveraging                                              */
/*                                                                           */
/*      This method retrieves the averaging setup for CDMA One modulation    */
/*      accuracy (RHO) measurements.                                         */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt32 cdma1RHOAverageCountQuery                                     */
/*                                                                           */
/*      Returns the number of frames that will be averaged.                  */
/*                                                                           */
/*    ViPBoolean cdma1RHOAverageStateQuery                                   */
/*                                                                           */
/*      Returns current average state.                                       */
/*                                                                           */
/*      0 = VI_FALSE                                                         */
/*      1 = VI_TRUE                                                          */
/*                                                                           */
/*    ViPInt16 cdma1RHOAverageModeQuery                                      */
/*                                                                           */
/*      Returns the current instrument type of terminal control for          */
/*      averaging.                                                           */
/*      0 = hpesa_AVERAGE_EXPONENTIAL                                        */
/*      1 = hpesa_AVERAGE_REPEAT                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_RHOGetAveraging
                       (ViSession instrumentHandle,
                        ViPInt32 cdma1RHOAverageCountQuery,
                        ViPBoolean cdma1RHOAverageStateQuery,
                        ViPInt16 cdma1RHOAverageModeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_NULL_POINTER(cdma1RHOAverageCountQuery,VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(cdma1RHOAverageStateQuery,VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(cdma1RHOAverageModeQuery,VI_ERROR_PARAMETER4)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = GenGetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_RHO,
                                cdma1RHOAverageCountQuery,
                                cdma1RHOAverageStateQuery,
                                cdma1RHOAverageModeQuery);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_RHOGetAveraging                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_RHOSetSweepTime                                              */
/*                                                                           */
/*      This method sets the length of the measurement interval that will be */
/*      used for CDMA One modulation accuracy (RHO) measurements.            */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1RHOSweepTime                                             */
/*                                                                           */
/*      New acquisition time, in seconds. Instrument range is 150 us to 26.7 */
/*      ms, and the default is 1.250 ms.                                     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_RHOSetSweepTime
                       (ViSession instrumentHandle,
                        ViReal64 cdma1RHOSweepTime)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = hpesa_cmdReal(instrumentHandle, 
                              "RHO:SWE:TIME", 
                              cdma1RHOSweepTime);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_RHOSetSweepTime                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_RHOGetSweepTime                                              */
/*                                                                           */
/*      This method retrieves the length of the current measurement interval */
/* that will be used for CDMA One modulation accuracy (RHO) measurements.    */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPReal64 cdma1RHOSweepTimeQuery                                       */
/*                                                                           */
/*      Returns the current acquisition time in seconds.                     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_RHOGetSweepTime
                       (ViSession instrumentHandle,
                        ViPReal64 cdma1RHOSweepTimeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_NULL_POINTER(cdma1RHOSweepTimeQuery, VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  "RHO:SWE:TIME?", 
                                  cdma1RHOSweepTimeQuery);


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_RHOGetSweepTime                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_RHOSetMeasurementSpectrum                                    */
/*                                                                           */
/*      This method selects the measurement spectrum type (normal or         */
/*      inverted) for the CDMA One modulation accuracy (RHO) measurement.    */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 cdma1RHOMeasSpectrum                                           */
/*                                                                           */
/*      Sets the new RHO measurement spectrum type.                          */
/*                                                                           */
/*      hpesa_RHO_MEAS_SPEC_NORMAL - normal spectrum.                        */
/*      hpesa_RHO_MEAS_SPEC_INVERT - inverted spectrum.                      */
/*                                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_RHOSetMeasurementSpectrum
                       (ViSession instrumentHandle,
                        ViInt16 cdma1RHOMeasSpectrum)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    ViChar buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // Parameter check
    CHK_ENUM(cdma1RHOMeasSpectrum, 0, hpesa_RHO_MEAS_SPEC_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    switch(cdma1RHOMeasSpectrum)
    {
        case hpesa_RHO_MEAS_SPEC_NORMAL:
            sprintf(buffer, "RHO:SPEC NORM");
            break;
        case hpesa_RHO_MEAS_SPEC_INVERTED:
            sprintf(buffer, "RHO:SPEC INV");
            break;
        default:
            fprintf(stderr, "Logic error in hpesa_cdma1_RHOSetMeasurementSpectrum");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, buffer);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                 end hpesa_cdma1_RHOSetMeasurementSpectrum                 */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_RHOGetMeasurementSpectrum                                    */
/*                                                                           */
/*      This method retrieves the current measurement spectrum type (normal  */
/*      or inverted) for the CDMA One modulation accuracy (RHO) measurement. */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 cdma1RHOMeasSpectrumQuery                                     */
/*                                                                           */
/*      Current RHO measurement spectrum type.                               */
/*      0 = hpesa_RHO_MEAS_SPEC_NORMAL                                       */
/*      1 = hpesa_RHO_MEAS_SPEC_INVERT                                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_RHOGetMeasurementSpectrum
                       (ViSession instrumentHandle,
                        ViPInt16 cdma1RHOMeasSpectrumQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(cdma1RHOMeasSpectrumQuery, VI_ERROR_PARAMETER2)

    VERIFY_APP(hpesa_APPLICATION_CDMA)

    // Retrieve the external trigger slope
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  "RHO:SPEC?",
                                  64, 
                                  buffer);
    if(errStatus < VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0';  // strip the trailing \n

    if(!strcmp(buffer, "NORM"))
        *cdma1RHOMeasSpectrumQuery = hpesa_RHO_MEAS_SPEC_NORMAL;
    else if (!strcmp(buffer, "INV"))
        *cdma1RHOMeasSpectrumQuery = hpesa_RHO_MEAS_SPEC_INVERTED;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                 end hpesa_cdma1_RHOGetMeasurementSpectrum                 */
/*****************************************************************************/


                       /*****************************/
                       /*  cdmaOne CDP Measurements */
                       /*****************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CDPConfigure                                                 */
/*                                                                           */
/*      This method sets up the instrument for CDMA One code domain power    */
/*      measurement (CDP).                                                   */
/*                                                                           */
/*      This method stops the current measurement and sets up the instrument */
/*      for the code domain power (CDP) measurement using the factory        */
/*      default instrument settings. It does not initiate the taking of      */
/*      measurement data. This command also turns the averaging function on  */
/*      and sets the number of averages to 10 for all measurements.          */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CDPConfigure
                       (ViSession instrumentHandle)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = hpesa_cmd(instrumentHandle, "CONF:CDP");

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_cdma1_CDPConfigure                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CDPMeasure                                                   */
/*                                                                           */
/*      This method measures the CDMA One power for each of the 64 Walsh     */
/*      codes/channels, relative to the total power in the pilot channel.    */
/*      User must be in the cdmaOne application mode to use this function.   */
/*                                                                           */
/*      User can select one of three types of measurement modes: Measure,    */
/*      Read, or Fetch.                                                      */
/*                                                                           */
/*      This method returns 10 CDP measurement scalar results, as described  */
/*      in the parameters below.                                             */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1CDPMeasureTimeout                                        */
/*                                                                           */
/*      This value temporarily changes the VISA timeout setting for the      */
/*      duration of the instrument measurement. The user needs to set this   */
/*      value to an appropriate time that will be longer then the expected   */
/*      measurement time. Units are in seconds.                              */
/*                                                                           */
/*    ViInt16 cdma1CDPMeasureType                                            */
/*                                                                           */
/*      Selects measurement type. Note that for hpesa_FETCH type the         */
/*      instrument should already be in this measurement mode else the       */
/*      function will time out. User can select this measurement mode by     */
/*      first using the "MEASURE" or "READ" types or call the                */
/*      hpesa_cdma1_CDPConfigure function.                                   */
/*                                                                           */
/*      hpesa_MEASURE - Stops current measurement, changes to this selected  */
/*      measurement, sets up instrument using factory defaults, makes        */
/*      measurement, returns measurement results.                            */
/*                                                                           */
/*      hpesa_READ - Stops current measurement,  changes to this selected    */
/*      measurement, uses instrument settings from last measurement of this  */
/*      type, makes measurement, returns measurements results.               */
/*                                                                           */
/*      hpesa_FETCH - Returns measurements results only. No new measurement  */
/*      is initiated.                                                        */
/*                                                                           */
/*    ViPReal64 cdma1CDPTimeOffsetQuery                                      */
/*                                                                           */
/*      Time offset is a floating point number with units of seconds. This   */
/*      is the time delay of the even second clock with respect to the start */
/*      of the short code PN sequences. Time offset takes into account the   */
/*      setting of the PN offset parameter. For example, with the PN offset  */
/*      to 2 the reported time offset would be the calculated time offset    */
/*      times 64 chip intervals (or 2 X 52.0833e-6).                         */
/*                                                                           */
/*    ViPReal64 cdma1CDPFreqErrorQuery                                       */
/*                                                                           */
/*      Returns the frequency error, which is a floating point number (in    */
/*      Hz) of the frequency error in the measured signal. This error is     */
/*      based on the linear best fit of the uncorrected measured phase.      */
/*                                                                           */
/*    ViPReal64 cdma1CDPCarrFeedthruQuery                                    */
/*                                                                           */
/*      Returns the carrier feedthrough, a floating point number (in dB) of  */
/*      the dc offset, of I and Q, from the origin.                          */
/*                                                                           */
/*    ViPReal64 cdma1CDPPilotPowerQuery                                      */
/*                                                                           */
/*      Returns the pilot power, a floating point number with units of dB.   */
/*      It is the relative power of the pilot channel (Walsh code 0) with    */
/*      respect to the carrier power.                                        */
/*                                                                           */
/*    ViPReal64 cdma1CDPPagingPowerQuery                                     */
/*                                                                           */
/*      Paging power is a floating point number with units of dB. It is the  */
/*      relative power of the paging channel (Walsh code 1) with respect to  */
/*      the carrier power.                                                   */
/*                                                                           */
/*    ViPReal64 cdma1CDPSyncPowerQuery                                       */
/*                                                                           */
/*      Returns the sync power, a floating point number with units of dB. It */
/*      is the relative power of the sync channel (Walsh code 32) with       */
/*      respect to the carrier power.                                        */
/*                                                                           */
/*    ViPReal64 cdma1CDPAvgTrafficPowQuery                                   */
/*                                                                           */
/*      Returns the average traffic power, a floating point number with      */
/*      units of dB. It is the average relative power of the active traffic  */
/*      channels with respect to the carrier power. Traffic channels are     */
/*      defined as all of the Walsh codes except Walsh 0,1, 32. A traffic    */
/*      channel is active if its coding power is greater than the active set */
/*      threshold parameter which you have selected.                         */
/*                                                                           */
/*    ViPReal64 cdma1CDPMaxITPowerQuery                                      */
/*                                                                           */
/*      Returns the maximum inactive traffic power, a floating point number  */
/*      with units of dB. It is the maximum relative power of an inactive    */
/*      traffic channel with respect to the carrier power. Traffic channels  */
/*      are defined as all of the Walsh codes except Walsh 0,1, 32. A        */
/*      traffic channel is inactive if its coding power is less than the     */
/*      active set threshold parameter which you have selected.              */
/*                                                                           */
/*    ViPReal64 cdma1CDPAvgITPowerQuery                                      */
/*                                                                           */
/*      Returns the average inactive traffic power, a floating point number  */
/*      with units of dB. It is the average relative power of the inactive   */
/*      traffic channels with respect to the carrier power. Traffic channels */
/*      are defined as all of the Walsh codes except Walsh 0,1, 32. A        */
/*      traffic channel is inactive if its coding power is less than the     */
/*      active set threshold parameter which you have selected.              */
/*                                                                           */
/*    ViPReal64 cdma1CDPRhoEstimateQuery                                     */
/*                                                                           */
/*      Returns the RHO (estimated), a floating point number without units.  */
/*      This is an estimate of Rho based on the input signal as a pilot only */
/*      signal. It is calculated by estimating the noise floor for the       */
/*      active code channels using the average of the noise in all of the    */
/*      inactive channels. The measured noise floor is subtracted from all   */
/*      active channels before they are summed together to get the total     */
/*      signal power. The ratio of total noise power to total power is the   */
/*      Rho (estimated).                                                     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CDPMeasure
                       (ViSession instrumentHandle,
                        ViReal64 cdma1CDPMeasureTimeout,
                        ViInt16 cdma1CDPMeasureType,
                        ViPReal64 cdma1CDPTimeOffsetQuery,
                        ViPReal64 cdma1CDPFreqErrorQuery,
                        ViPReal64 cdma1CDPCarrFeedthruQuery,
                        ViPReal64 cdma1CDPPilotPowerQuery,
                        ViPReal64 cdma1CDPPagingPowerQuery,
                        ViPReal64 cdma1CDPSyncPowerQuery,
                        ViPReal64 cdma1CDPAvgTrafficPowQuery,
                        ViPReal64 cdma1CDPMaxITPowerQuery,
                        ViPReal64 cdma1CDPAvgITPowerQuery,
                        ViPReal64 cdma1CDPRhoEstimateQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    ViReal64 MeasData[10];
    ViInt32 temp = 0;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_ENUM(cdma1CDPMeasureType, 0, hpesa_MEASURE_METHOD_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(cdma1CDPTimeOffsetQuery, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(cdma1CDPFreqErrorQuery, VI_ERROR_PARAMETER5)
    CHK_NULL_POINTER(cdma1CDPCarrFeedthruQuery, VI_ERROR_PARAMETER6)
    CHK_NULL_POINTER(cdma1CDPPilotPowerQuery, VI_ERROR_PARAMETER7)
    CHK_NULL_POINTER(cdma1CDPPagingPowerQuery, VI_ERROR_PARAMETER8)
    CHK_NULL_POINTER(cdma1CDPSyncPowerQuery, hpesa_INSTR_ERROR_PARAMETER9)
    CHK_NULL_POINTER(cdma1CDPAvgTrafficPowQuery, hpesa_INSTR_ERROR_PARAMETER10)
    CHK_NULL_POINTER(cdma1CDPMaxITPowerQuery, hpesa_INSTR_ERROR_PARAMETER11)
    CHK_NULL_POINTER(cdma1CDPAvgITPowerQuery, hpesa_INSTR_ERROR_PARAMETER12)
    CHK_NULL_POINTER(cdma1CDPRhoEstimateQuery, hpesa_INSTR_ERROR_PARAMETER13) 

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = GenMeasureTrace(instrumentHandle,
                               hpesa_APPLICATION_MODE_CDP,
                               cdma1CDPMeasureTimeout,
                               cdma1CDPMeasureType,
                               hpesa_RESULTS_TYPE_1,
                               MeasData,
                               10,
                               &temp);
    if(errStatus < VI_SUCCESS) return errStatus;


    if(temp == 10)
    {
        *cdma1CDPTimeOffsetQuery = MeasData[0];
        *cdma1CDPFreqErrorQuery = MeasData[1];
        *cdma1CDPCarrFeedthruQuery = MeasData[2];
        *cdma1CDPPilotPowerQuery = MeasData[3];
        *cdma1CDPPagingPowerQuery = MeasData[4];
        *cdma1CDPSyncPowerQuery = MeasData[5];
        *cdma1CDPAvgTrafficPowQuery = MeasData[6];
        *cdma1CDPMaxITPowerQuery = MeasData[7];
        *cdma1CDPAvgITPowerQuery = MeasData[8];
        *cdma1CDPRhoEstimateQuery = MeasData[9];
        errStatus = VI_SUCCESS;
    }
    else
        errStatus = hpesa_INSTR_ERROR_UNEXPECTED;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_cdma1_CDPMeasure                         */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CDPMeasureTrace                                              */
/*                                                                           */
/*      This method measures the CDMA One power for each of the 64 Walsh     */
/*      codes/channels, relative to the total power in the pilot channel.    */
/*      User must be in the cdmaOne application mode to use this function.   */
/*                                                                           */
/*      User can select one of three types of measurement modes: Measure,    */
/*      Read, or Fetch.                                                      */
/*                                                                           */
/*      Function returns the CDP measurement results specified by the        */
/*      "cdma1CDPResultsType" parameter as a real array.                     */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1CDPMeasureTraceTimeout                                   */
/*                                                                           */
/*      This value temporarily changes the VISA timeout setting for the      */
/*      duration of the instrument measurement. The user needs to set this   */
/*      value to an appropriate time that will be longer then the expected   */
/*      measurement time. Units are in seconds.                              */
/*                                                                           */
/*    ViInt16 cdma1CDPMeasureTraceType                                       */
/*                                                                           */
/*      Selects measurement type. Note that for hpesa_FETCH type the         */
/*      instrument should already be in this measurement mode else the       */
/*      function will time out. User can select this measurement mode by     */
/*      first using the "MEASURE" or "READ" types or call the                */
/*      hpesa_cdma1_CDPConfigure function.                                   */
/*                                                                           */
/*      hpesa_MEASURE - Stops current measurement, changes to this selected  */
/*      measurement, sets up instrument using factory defaults, makes        */
/*      measurement, returns measurement results.                            */
/*                                                                           */
/*      hpesa_READ - Stops current measurement,  changes to this selected    */
/*      measurement, uses instrument settings from last measurement of this  */
/*      type, makes measurement, returns measurements results.               */
/*                                                                           */
/*      hpesa_FETCH - Returns measurements results only. No new measurement  */
/*      is initiated.                                                        */
/*                                                                           */
/*    ViInt16 cdma1CDPResultsType                                            */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_0: Not supported by instrument.                   */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_1:                                                */
/*      Returns the following 9 scalar results:                              */
/*      1. Time offset is a floating point number with units of seconds.     */
/*      This is the time delay of the even second clock with respect to the  */
/*      start of the short code PN sequences. Time offset takes into account */
/*      the setting of the PN offset parameter. For example, with the PN     */
/*      offset to 2 the reported time offset would be the calculated time    */
/*      offset times 64 chip intervals (or 2 X 52.0833e-6).                  */
/*      2. Frequency error is a floating point number (in Hz) of the         */
/*      frequency error in the measured signal. This error is based on the   */
/*      linear best fit of the uncorrected measured phase.                   */
/*      3. Carrier feedthrough is a floating point number (in dB) of the dc  */
/*      offset, of I and Q, from the origin.                                 */
/*      4. Pilot power is a floating point number with units of dB. It is    */
/*      the relative power of the pilot channel (Walsh code 0) with respect  */
/*      to the carrier power.                                                */
/*      5. Paging power is a floating point number with units of dB. It is   */
/*      the relative power of the paging channel (Walsh code 1) with respect */
/*      to the carrier power.                                                */
/*      6. Sync power is a floating point number with units of dB. It is the */
/*      relative power of the sync channel (Walsh code 32) with respect to   */
/*      the carrier power.                                                   */
/*      7. Average traffic power is a floating point number with units of    */
/*      dB. It is the average relative power of the active traffic channels  */
/*      with respect to the carrier power. Traffic channels are defined as   */
/*      all of the Walsh codes except Walsh 0,1, 32. A traffic channel is    */
/*      active if its coding power is greater than the active set threshold  */
/*      parameter which you have selected.                                   */
/*      8. Maximum inactive traffic power is a floating point number with    */
/*      units of dB. It is the maximum relative power of an inactive traffic */
/*      channel with respect to the carrier power. Traffic channels are      */
/*      defined as all of the Walsh codes except Walsh 0,1, 32. A traffic    */
/*      channel is inactive if its coding power is less than the active set  */
/*      threshold parameter which you have selected.                         */
/*      9. Average inactive traffic power is a floating point number with    */
/*      units of dB. It is the average relative power of the inactive        */
/*      traffic channels with respect to the carrier power. Traffic channels */
/*      are defined as all of the Walsh codes except Walsh 0,1, 32. A        */
/*      traffic channel is inactive if its coding power is less than the     */
/*      active set threshold parameter which you have selected.              */
/*      10. RHO (estimated) is a floating point number without units. This   */
/*      is an estimate of Rho based on the input signal as a pilot only      */
/*      signal. It is calculated by estimating the noise floor for the       */
/*      active code channels using the average of the noise in all of the    */
/*      inactive channels. The measured noise floor is subtracted from all   */
/*      active channels before they are summed together to get the total     */
/*      signal power. The ratio of total noise power to total power is the   */
/*      Rho (estimated).                                                     */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_2:                                                */
/*      Returns floating point numbers that are the trace data of the code   */
/*      domain power trace for all 64 Walsh codes. This series of 64 numbers */
/*      represent the relative power levels (in dB) of all 64 walsh codes,   */
/*      with respect to the carrier power.                                   */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_3:                                                */
/*      Returns floating point numbers that are the trace data of the code   */
/*      domain timing trace for all 64 Walsh codes. This series of 64        */
/*      numbers represent the relative timing estimations (in seconds) of    */
/*      the codes, relative to the pilot channel. Typical values are on the  */
/*      order of 1 ns.                                                       */
/*                                                                           */
/*      The instrument default method is to measure the power only. If you   */
/*      use this result type with the Method left as Power, invalid data     */
/*      will be returned. Set Method to "Timing/Phase" for proper results    */
/*      ("hpesa_SetMeasurementMethod function").                             */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_4:                                                */
/*      Returns floating point numbers that are the trace data of the code   */
/*      domain phase trace for all 64 Walsh codes. This series of 64 numbers */
/*      represent the relative phase estimations (in radians) of the codes,  */
/*      relative to the pilot channel. Typical values are on the order of 1  */
/*      mrad.                                                                */
/*                                                                           */
/*      The instrument default method is to measure the power only. If you   */
/*      use this result type with the Method left as Power, invalid data     */
/*      will be returned. Set Method to "Timing/Phase" for proper results    */
/*      ("hpesa_SetMeasurementMethod function").                             */
/*                                                                           */
/*    ViAReal64 cdma1CDPDataResults                                          */
/*                                                                           */
/*      Trace data returned by measurement, formatted according to           */
/*      cdma1CDPResultsType.                                                 */
/*                                                                           */
/*    ViInt32 cdma1CDPDataResultsMaxSz                                       */
/*                                                                           */
/*      Maximum size of cdma1CDPTraceDataResults array.                      */
/*                                                                           */
/*    ViPInt32 cdma1CDPDataResultsSz                                         */
/*                                                                           */
/*      Actual size of cdma1CDPDataResults array.                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CDPMeasureTrace
                       (ViSession instrumentHandle,
                        ViReal64 cdma1CDPMeasureTraceTimeout,
                        ViInt16 cdma1CDPMeasureTraceType,
                        ViInt16 cdma1CDPResultsType,
                        ViAReal64 cdma1CDPDataResults,
                        ViInt32 cdma1CDPDataResultsMaxSz,
                        ViPInt32 cdma1CDPDataResultsSz)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    int CDPValidResults[7] = {0,1,1,1,1,0,0};
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_ENUM(cdma1CDPMeasureTraceType, 0, hpesa_MEASURE_METHOD_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)
    CHK_ENUM(cdma1CDPResultsType, 0, hpesa_RESULTS_TYPE_LASTENUM,
                                                        VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(cdma1CDPDataResults, VI_ERROR_PARAMETER5)
    CHK_NULL_POINTER(cdma1CDPDataResultsSz, VI_ERROR_PARAMETER7)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    if((cdma1CDPResultsType > 6) || (CDPValidResults[cdma1CDPResultsType] == 0))
        return hpesa_INSTR_ERROR_INVALID_RESULTS_TYPE;

    errStatus = GenMeasureTrace(instrumentHandle,
                               hpesa_APPLICATION_MODE_CDP,
                               cdma1CDPMeasureTraceTimeout,
                               cdma1CDPMeasureTraceType,
                               cdma1CDPResultsType,
                               cdma1CDPDataResults,
                               cdma1CDPDataResultsMaxSz,
                               cdma1CDPDataResultsSz);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_CDPMeasureTrace                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CDPSetAveraging                                              */
/*                                                                           */
/*      This method sets up averaging for CDMA One code domain power (CDP)   */
/*      measurements. User can control the number of averages, turn on and   */
/*      off averaging, and set the terminal control mode for averaging.      */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 cdma1CDPAverageCount                                           */
/*                                                                           */
/*      Sets the number of frames that will be averaged. After the specified */
/*      number of frames (average counts), the averaging mode (terminal      */
/*      control) determines the averaging action.                            */
/*                                                                           */
/*    ViBoolean cdma1CDPAverageState                                         */
/*                                                                           */
/*      Turns averaging on or off.                                           */
/*                                                                           */
/*      VI_TRUE - Turn averaging on.                                         */
/*      VI_FALSE - Turn averaging off.                                       */
/*                                                                           */
/*    ViInt16 cdma1CDPAverageMode                                            */
/*                                                                           */
/*      Selects the type of terminal control for averaging.                  */
/*                                                                           */
/*      hpesa_AVERAGE_EXPONENTIAL  - Each successive data acquisition after  */
/*      the average count is reached, is exponentially weighted and combined */
/*      with the existing average.                                           */
/*                                                                           */
/*      hpesa_AVERAGE_REPEAT - After reaching the average count, the         */
/*      averaging is reset and a new average is started                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CDPSetAveraging
                       (ViSession instrumentHandle,
                        ViInt32 cdma1CDPAverageCount,
                        ViBoolean cdma1CDPAverageState,
                        ViInt16 cdma1CDPAverageMode)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_BOOLEAN(cdma1CDPAverageState, VI_ERROR_PARAMETER3)
    CHK_ENUM(cdma1CDPAverageMode, 0, hpesa_AVERAGE_MODE_LASTENUM,
                                                        VI_ERROR_PARAMETER4)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = GenSetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_CDP,
                                cdma1CDPAverageCount,
                                cdma1CDPAverageState,
                                cdma1CDPAverageMode);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_CDPSetAveraging                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CDPGetAveraging                                              */
/*                                                                           */
/*      This method retrieves the averaging setup for the code domain power  */
/*      (CDP) measurements.                                                  */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt32 cdma1CDPAverageCountQuery                                     */
/*                                                                           */
/*      Returns the current number of sweeps that being averaged.            */
/*                                                                           */
/*    ViPBoolean cdma1CDPAverageStateQuery                                   */
/*                                                                           */
/*      Returns the current instrument current average state.                */
/*                                                                           */
/*      0 = VI_FALSE                                                         */
/*      1 = VI_TRUE                                                          */
/*                                                                           */
/*    ViPInt16 cdma1CDPAverageModeQuery                                      */
/*                                                                           */
/*      Returns the current instrument type of terminal control for          */
/*      averaging.                                                           */
/*      0 = hpesa_AVERAGE_EXPONENTIAL                                        */
/*      1 = hpesa_AVERAGE_REPEAT                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CDPGetAveraging
                       (ViSession instrumentHandle,
                        ViPInt32 cdma1CDPAverageCountQuery,
                        ViPBoolean cdma1CDPAverageStateQuery,
                        ViPInt16 cdma1CDPAverageModeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_NULL_POINTER(cdma1CDPAverageCountQuery,VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(cdma1CDPAverageStateQuery,VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(cdma1CDPAverageModeQuery,VI_ERROR_PARAMETER4)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = GenGetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_CDP,
                                cdma1CDPAverageCountQuery,
                                cdma1CDPAverageStateQuery,
                                cdma1CDPAverageModeQuery);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_CDPGetAveraging                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CDPSetSweepTime                                              */
/*                                                                           */
/*      This method sets the length of the measurement interval that will be */
/*      used for CDMA One code domain power (CDP) measurements.              */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1CDPSweepTime                                             */
/*                                                                           */
/*      Sets the new measurement interval time, in seconds. Instrument range */
/*      is 500 us to 26.7 ms, and the default is 1.250 ms.                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CDPSetSweepTime
                       (ViSession instrumentHandle,
                        ViReal64 cdma1CDPSweepTime)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = hpesa_cmdReal(instrumentHandle, "CDP:SWE:TIME", cdma1CDPSweepTime);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_CDPSetSweepTime                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CDPGetSweepTime                                              */
/*                                                                           */
/*      This method retrieves the current length of the measurement interval */
/*      that will be used for CDMA One code domain power (CDP) measurements. */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPReal64 cdma1CDPSweepTimeQuery                                       */
/*                                                                           */
/*      Returns the measurement interval time in seconds.                    */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CDPGetSweepTime
                       (ViSession instrumentHandle,
                        ViPReal64 cdma1CDPSweepTimeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(cdma1CDPSweepTimeQuery, VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  "CDP:SWE:TIME?", 
                                  cdma1CDPSweepTimeQuery);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_CDPGetSweepTime                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CDPSetMeasurementSpectrum                                    */
/*                                                                           */
/*      This method selects measurement spectrum type (normal or inverted)   */
/*      for the CDMA One code domain power (CDP) measurements.               */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 cdma1CDPMeasSpectrum                                           */
/*                                                                           */
/*      Sets the new CDP measurement spectrum type.                          */
/*                                                                           */
/*      hpesa_CDP_MEAS_SPEC_NORMAL - normal spectrum.                        */
/*      hpesa_CDP_MEAS_SPEC_INVERT - inverted spectrum.                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CDPSetMeasurementSpectrum
                       (ViSession instrumentHandle,
                        ViInt16 cdma1CDPMeasSpectrum)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    ViChar buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // Parameter check
    CHK_ENUM(cdma1CDPMeasSpectrum, 0, hpesa_CDP_MEAS_SPEC_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    switch(cdma1CDPMeasSpectrum)
    {
        case hpesa_CDP_MEAS_SPEC_NORMAL:
            sprintf(buffer, "CDP:SPEC NORM");
            break;
        case hpesa_CDP_MEAS_SPEC_INVERTED:
            sprintf(buffer, "CDP:SPEC INV");
            break;
        default:
            fprintf(stderr, "Logic error in hpesa_cdma1_CDPSetMeasurementSpectrum");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, buffer);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                 end hpesa_cdma1_CDPSetMeasurementSpectrum                 */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CDPGetMeasurementSpectrum                                    */
/*                                                                           */
/*      This method retrieves the current measurement spectrum type (normal  */
/*      or inverted) for CDMA One code domain power (CDP) measurements.      */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 cdma1CDPMeasSpectrumQuery                                     */
/*                                                                           */
/*      Current CDP measurement spectrum type.                               */
/*                                                                           */
/*      0 = hpesa_CDP_MEASURE_SPEC_NORMAL                                    */
/*      1 = hpesa_CDP_MEASURE_SPEC_INVERT                                    */
/*                                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CDPGetMeasurementSpectrum
                       (ViSession instrumentHandle,
                        ViPInt16 cdma1CDPMeasSpectrumQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(cdma1CDPMeasSpectrumQuery, VI_ERROR_PARAMETER2)

    VERIFY_APP(hpesa_APPLICATION_CDMA)

    // Retrieve the external trigger slope
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  "CDP:SPEC?",
                                  64, 
                                  buffer);
    if(errStatus < VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0';  // strip the trailing \n

    if(!strcmp(buffer, "NORM"))
        *cdma1CDPMeasSpectrumQuery = hpesa_CDP_MEAS_SPEC_NORMAL;
    else if (!strcmp(buffer, "INV"))
        *cdma1CDPMeasSpectrumQuery = hpesa_CDP_MEAS_SPEC_INVERTED;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                 end hpesa_cdma1_CDPGetMeasurementSpectrum                 */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CDPSetMeasThreshold                                          */
/*                                                                           */
/*      This method sets the active set threshold value for CDMA One code    */
/*      domain power (CDP) measurements. Walsh Channels with powers less     */
/*      than this value will be treated as non-active (noise) channels.      */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1CDPMeasThreshold                                         */
/*                                                                           */
/*      Sets the new active threshold value in dB. Instrument range is 0 to  */
/*      - 200 dB, and the default is - 20 dB.                                */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CDPSetMeasThreshold
                       (ViSession instrumentHandle,
                        ViReal64 cdma1CDPMeasThreshold)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = hpesa_cmdReal(instrumentHandle, 
                              "CDP:ASET:THR", 
                              cdma1CDPMeasThreshold);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_cdma1_CDPSetMeasThreshold                    */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CDPGetMeasThreshold                                          */
/*                                                                           */
/*      This method retrieves the active set threshold value for CDMA One    */
/*      code domain power (CDP) measurements.                                */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPReal64 cdma1CDPMeasThresholdQuery                                   */
/*                                                                           */
/*      Returns the current active threshold value, in dB.                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CDPGetMeasThreshold
                       (ViSession instrumentHandle,
                        ViPReal64 cdma1CDPMeasThresholdQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(cdma1CDPMeasThresholdQuery, VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = hpesa_cmdReal64_Q(instrumentHandle,
                                  "CDP:ASET:THR?",
                                  cdma1CDPMeasThresholdQuery);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_cdma1_CDPGetMeasThreshold                    */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CDPSetMeasurementMethod                                      */
/*                                                                           */
/*      This method selects the measurement method for CDMA One code domain  */
/*      power (CDP) measurements.                                            */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 cdma1CDPMeasMethod                                             */
/*                                                                           */
/*      Sets the new CDP measurement method.                                 */
/*                                                                           */
/*      hpesa_CDP_MEAS_METHOD_POWER   - Power measures the Code Domain Power */
/*      of all 64 Walsh Channels.                                            */
/*                                                                           */
/*      hpesa_CDP_MEAS_METHOD_TPHASE  - Timing & Phase measures the Code     */
/*      Domain Power, Code Domain Timing, and Code Domain Phase of all 64    */
/*      Walsh Channels.                                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CDPSetMeasurementMethod
                       (ViSession instrumentHandle,
                        ViInt16 cdma1CDPMeasMethod)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    ViChar buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(cdma1CDPMeasMethod, 0, hpesa_CDP_MEAS_METHOD_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    switch(cdma1CDPMeasMethod)
    {
        case hpesa_CDP_MEAS_METHOD_POWER:
            sprintf(buffer, "CDP:METH POW");
            break;
        case hpesa_CDP_MEAS_METHOD_TPHASE:
            sprintf(buffer, "CDP:METH TPH");
            break;
        default:
            fprintf(stderr, "Logic error in hpesa_cdma1_CDPSetMeasurementMethod");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }
    
    errStatus = hpesa_cmd(instrumentHandle, buffer);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                  end hpesa_cdma1_CDPSetMeasurementMethod                  */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CDPGetMeasurementMethod                                      */
/*                                                                           */
/*      This method retrieves the current measurement method for code domain */
/*      power (CDP) measurements.                                            */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 cdma1CDPMeasMethodQuery                                       */
/*                                                                           */
/*      Returns the current CDP measurement method.                          */
/*                                                                           */
/*      0 = hpesa_CDP_MEAS_METHOD_POWER                                      */
/*      1 = hpesa_CDP_MEAS_METHOD_TPHASE                                     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CDPGetMeasurementMethod
                       (ViSession instrumentHandle,
                        ViPInt16 cdma1CDPMeasMethodQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(cdma1CDPMeasMethodQuery, VI_ERROR_PARAMETER2)

    VERIFY_APP(hpesa_APPLICATION_CDMA)

    // Retrieve the external trigger slope
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  "CDP:METH?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0';  // strip the trailing \n

    if(!strcmp(buffer, "POW"))
        *cdma1CDPMeasMethodQuery = hpesa_CDP_MEAS_METHOD_POWER;
    else if (!strcmp(buffer, "TPH"))
        *cdma1CDPMeasMethodQuery = hpesa_CDP_MEAS_METHOD_TPHASE;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                  end hpesa_cdma1_CDPGetMeasurementMethod                  */
/*****************************************************************************/


                       /*****************************/
                       /*  cdmaOne CSP Measurements */
                       /*****************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CSPConfigure                                                 */
/*                                                                           */
/*      This method sets up the instrument for CDMA One close spurs (CSP)    */
/*      measurements.  It stops the current measurement and sets up the      */
/*      instrument for the Close Spurs Power (CSP) measurement using the     */
/*      factory default instrument settings. It does not initiate the taking */
/*      of measurement data. This command also turns the averaging function  */
/*      on and sets the number of averages to 10 for all measurements.       */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CSPConfigure
                       (ViSession instrumentHandle)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr);

    //check the Application
	VERIFY_APP(hpesa_APPLICATION_CDMA);

    errStatus = hpesa_cmd(instrumentHandle, "CONF:CSP");

    return errStatus;

}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_cdma1_CSPConfigure                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CSPMeasure                                                   */
/*                                                                           */
/*      This method measures the CDMA One spurious emissions in the transmit */
/*      band relative to the channel power in the selected channel. User     */
/*      must be in the cdmaOne application mode to use this function.        */
/*                                                                           */
/*      User can select one of three types of measurement modes: Measure,    */
/*      Read, or Fetch.                                                      */
/*                                                                           */
/*      This method returns four CSP measurement scalar results, as          */
/*      described in the parameters below. The user can select the segment   */
/*      (Lower, Center, Upper) from which to return the measurement results. */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1CSPMeasureTimeout                                        */
/*                                                                           */
/*      This value temporarily changes the VISA timeout setting for the      */
/*      duration of the instrument measurement. The user needs to set this   */
/*      value to an appropriate time that will be longer then the expected   */
/*      measurement time. Units are in seconds.                              */
/*                                                                           */
/*    ViInt16 cdma1CSPMeasureType                                            */
/*                                                                           */
/*      Selects measurement type. Note that for hpesa_FETCH type the         */
/*      instrument should already be in this measurement mode else the       */
/*      function will time out. User can select this measurement mode by     */
/*      first using the "MEASURE" or "READ" types or call the                */
/*      hpesa_cdma1_CSPConfigure function.                                   */
/*                                                                           */
/*      hpesa_MEASURE - Stops current measurement, changes to this selected  */
/*      measurement, sets up instrument using factory defaults, makes        */
/*      measurement, returns measurement results.                            */
/*                                                                           */
/*      hpesa_READ - Stops current measurement,  changes to this selected    */
/*      measurement, uses instrument settings from last measurement of this  */
/*      type, makes measurement, returns measurements results.               */
/*                                                                           */
/*      hpesa_FETCH - Returns measurements results only. No new measurement  */
/*      is initiated.                                                        */
/*                                                                           */
/*    ViInt16 cdma1CSPMeasureSegment                                         */
/*                                                                           */
/*      Selects which segment of the instrument measurement results to       */
/*      return (Lower, Center, Upper) for the scalar results below. The      */
/*      channel power scalar is the same for all three segments.             */
/*                                                                           */
/*      The user should use either "hpesa_MEAS" or "hpesa_READ" as the       */
/*      cdma1CSPMeasureType value for the first time the function is invoked */
/*      to get the first segment measurement results, then use "hpesa_FETCH" */
/*      to get the other segments measurement results.                       */
/*                                                                           */
/*      hpesa_CSP_SEGMENT_LOWER -  Lower segment measurement results         */
/*      hpesa_CSP_SEGMENT_CENTER - Center segment measurement results        */
/*      hpesa_CSP_SEGMENT_UPPER -  Upper segment measurement results         */
/*                                                                           */
/*    ViPReal64 cdma1CSPChannelPowerQuery                                    */
/*                                                                           */
/*      Returns the channel power, in dBm.                                   */
/*                                                                           */
/*    ViPReal64 cdma1CSPSpurFreqDiff                                         */
/*                                                                           */
/*      Returns the specified measurement segment spur frequency difference  */
/*      from channel center frequency (in Hz).                               */
/*                                                                           */
/*    ViPReal64 cdma1CSPSpurAmplDiffLimit                                    */
/*                                                                           */
/*      Returns the specified measurement segment spur amplitude difference  */
/*      from the limit (in dB).                                              */
/*                                                                           */
/*    ViPReal64 cdma1CSPSpurAmplDiffCHP                                      */
/*                                                                           */
/*      Returns the specified measurement segment spur amplitude difference  */
/*      from channel power (in dBc).                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CSPMeasure
                       (ViSession instrumentHandle,
                        ViReal64 cdma1CSPMeasureTimeout,
                        ViInt16 cdma1CSPMeasureType,
                        ViInt16 cdma1CSPMeasureSegment,
                        ViPReal64 cdma1CSPChannelPowerQuery,
                        ViPReal64 cdma1CSPSpurFreqDiff,
                        ViPReal64 cdma1CSPSpurAmplDiffLimit,
                        ViPReal64 cdma1CSPSpurAmplDiffCHP)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    ViReal64 MeasData[10];
    ViInt32 temp = 0;
    
    GET_GLOBALS(instrumentHandle, thisPtr);

    // check the input parameters
    CHK_ENUM(cdma1CSPMeasureType, 0, hpesa_MEASURE_METHOD_LASTENUM, 
                                                        VI_ERROR_PARAMETER3);
	CHK_ENUM(cdma1CSPMeasureSegment,0,hpesa_CSP_SEGMENT_LASTENUM,
														VI_ERROR_PARAMETER4);
    																										
    CHK_NULL_POINTER(cdma1CSPChannelPowerQuery, VI_ERROR_PARAMETER5);
    CHK_NULL_POINTER(cdma1CSPSpurFreqDiff,      VI_ERROR_PARAMETER6);
    CHK_NULL_POINTER(cdma1CSPSpurAmplDiffLimit, VI_ERROR_PARAMETER7);
    CHK_NULL_POINTER(cdma1CSPSpurAmplDiffCHP,   VI_ERROR_PARAMETER8);

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA);

    errStatus = GenMeasureTrace(instrumentHandle,
                               hpesa_APPLICATION_MODE_CSP,
                               cdma1CSPMeasureTimeout,
                               cdma1CSPMeasureType,
                               hpesa_RESULTS_TYPE_1,
                               MeasData,
                               10,
                               &temp);

    if(errStatus < VI_SUCCESS) return errStatus;


    //Depending upon the type of the segment copy the contents 
	//of the temp array
	if(temp == 10)
    {
		*cdma1CSPChannelPowerQuery = MeasData[0];
		switch(cdma1CSPMeasureSegment)
		{

		case hpesa_CSP_SEGMENT_LOWER:
			*cdma1CSPSpurFreqDiff      = MeasData[1];
			*cdma1CSPSpurAmplDiffLimit = MeasData[2];
			*cdma1CSPSpurAmplDiffCHP   = MeasData[3];
            errStatus = VI_SUCCESS;
			break;
		
		case hpesa_CSP_SEGMENT_CENTER:
            *cdma1CSPSpurFreqDiff      = MeasData[4];
			*cdma1CSPSpurAmplDiffLimit = MeasData[5];
			*cdma1CSPSpurAmplDiffCHP   = MeasData[6];
			errStatus = VI_SUCCESS;
            break;
		
		case hpesa_CSP_SEGMENT_UPPER:
			*cdma1CSPSpurFreqDiff      = MeasData[7];
			*cdma1CSPSpurAmplDiffLimit = MeasData[8];
			*cdma1CSPSpurAmplDiffCHP   = MeasData[9];
			errStatus = VI_SUCCESS;
            break;
		
		default:
            fprintf(stderr, "Logic error in hpesa_cdma1_CSPSetMeasureSegment");
            return hpesa_INSTR_ERROR_UNEXPECTED;
		}

     }
    
	else
        errStatus = hpesa_INSTR_ERROR_UNEXPECTED;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_cdma1_CSPMeasure                         */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CSPMeasureTrace                                              */
/*                                                                           */
/*      This method measures the CDMA One spurious emissions in the transmit */
/*      band relative to the channel power in the selected channel. User     */
/*      must be in the cdmaOne application mode to use this function.        */
/*                                                                           */
/*      User can select one of three types of measurement modes: Measure,    */
/*      Read, or Fetch.                                                      */
/*                                                                           */
/*      Function returns the CSP measurement results specified by the        */
/*      "cdma1CSPResultsType" parameter as a real array.                     */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1CSPMeasureTraceTimeout                                   */
/*                                                                           */
/*      This value temporarily changes the VISA timeout setting for the      */
/*      duration of the instrument measurement. The user needs to set this   */
/*      value to an appropriate time that will be longer then the expected   */
/*      measurement time. Units are in seconds.                              */
/*                                                                           */
/*    ViInt16 cdma1CSPMeasureTraceType                                       */
/*                                                                           */
/*      Selects measurement type. Note that for hpesa_FETCH type the         */
/*      instrument should already be in this measurement mode else the       */
/*      function will time out. User can select this measurement mode by     */
/*      first using the "MEASURE" or "READ" types or call the                */
/*      hpesa_cdma1_CSPConfigure function.                                   */
/*                                                                           */
/*      hpesa_MEASURE - Stops current measurement, changes to this selected  */
/*      measurement, sets up instrument using factory defaults, makes        */
/*      measurement, returns measurement results.                            */
/*                                                                           */
/*      hpesa_READ - Stops current measurement,  changes to this selected    */
/*      measurement, uses instrument settings from last measurement of this  */
/*      type, makes measurement, returns measurements results.               */
/*                                                                           */
/*      hpesa_FETCH - Returns measurements results only. No new measurement  */
/*      is initiated.                                                        */
/*                                                                           */
/*    ViInt16 cdma1CSPResultsType                                            */
/*                                                                           */
/*      Determines the format of the values returned in cdma1CSPDataResults. */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_0: Not supported by instrument.                   */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_1:                                                */
/*      Returns 10 scalar results. The 10 results represent, first, the      */
/*      channel power and then 3 spur values. The 3 values are composed of   */
/*      the spurious value from each of 3 measurement segments. The          */
/*      measurement segments are Lower, Center, and Upper. For each of the 3 */
/*      spurs displayed, 3 values are returned:                              */
/*      1. The spur frequency difference from channel center frequency (in   */
/*      Hz)                                                                  */
/*      2. The spur amplitude difference from the limit (in dB)              */
/*      3. The spur amplitude difference from channel power (in dBc)         */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_2:                                                */
/*      Returns trace of the segment containing the worst spur.              */
/*                                                                           */
/*    ViAReal64 cdma1CSPDataResults                                          */
/*                                                                           */
/*      Trace data returned by measurement, formatted according to           */
/*      cdma1CSPResultsType.                                                 */
/*                                                                           */
/*    ViInt32 cdma1CSPDataResultsMaxSz                                       */
/*                                                                           */
/*      Maximum size of cdma1CSPDataResults array.                           */
/*                                                                           */
/*    ViPInt32 cdma1CSPDataResultsSz                                         */
/*                                                                           */
/*      Actual size of cdma1CSPDataResults array.                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CSPMeasureTrace
                       (ViSession instrumentHandle,
                        ViReal64 cdma1CSPMeasureTraceTimeout,
                        ViInt16 cdma1CSPMeasureTraceType,
                        ViInt16 cdma1CSPResultsType,
                        ViAReal64 cdma1CSPDataResults,
                        ViInt32 cdma1CSPDataResultsMaxSz,
                        ViPInt32 cdma1CSPDataResultsSz)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	int CSPValidResults[7] = {0,1,1,0,0,0,0};
	
	GET_GLOBALS(instrumentHandle, thisPtr);

    // check the input parameters
    CHK_ENUM(cdma1CSPMeasureTraceType, 0, hpesa_MEASURE_METHOD_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)
    CHK_ENUM(cdma1CSPResultsType, 0, hpesa_RESULTS_TYPE_LASTENUM,
                                                        VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(cdma1CSPDataResults, VI_ERROR_PARAMETER5)

    CHK_NULL_POINTER(cdma1CSPDataResultsSz, VI_ERROR_PARAMETER7)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

	//check for invalid results type
	if((cdma1CSPResultsType > 6) || (CSPValidResults[cdma1CSPResultsType] == 0))
        return hpesa_INSTR_ERROR_INVALID_RESULTS_TYPE;

    errStatus = GenMeasureTrace(instrumentHandle,
                               hpesa_APPLICATION_MODE_CSP,
                               cdma1CSPMeasureTraceTimeout,
                               cdma1CSPMeasureTraceType,
                               cdma1CSPResultsType,
                               cdma1CSPDataResults,
                               cdma1CSPDataResultsMaxSz,
                               cdma1CSPDataResultsSz);

    if(errStatus < VI_SUCCESS) return errStatus;


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_CSPMeasureTrace                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CSPSetAveraging                                              */
/*                                                                           */
/*      This method sets up averaging for CDMA One close spurs power (CSP)   */
/*      measurements. User can control the number of averages, turn on and   */
/*      off averaging, and set the terminal control mode for averaging.      */
/*                                                                           */
/*      The hpesa_cdma1CSPSetMeasurementType function will cause the         */
/*      instrument cdmaOne Close Spurs averaging mode to reset to "Repeat"   */
/*      if the measurement type is set to "Full". Set the measurement type   */
/*      to "Examine" first first (with the                                   */
/*      hpesa_cdma1_CSPSetMeasurementType" function) before invoking this    */
/*      function if  average mode "Exponential" is required.                 */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 cdma1CSPAverageCount                                           */
/*                                                                           */
/*      Sets the number of data acquisitions that will be averaged. After    */
/*      the specified number of average counts, the averaging mode (terminal */
/*      control) determines the averaging action.                            */
/*                                                                           */
/*    ViBoolean cdma1CSPAverageState                                         */
/*                                                                           */
/*      Turns averaging on or off.                                           */
/*                                                                           */
/*      VI_TRUE - Turn averaging on.                                         */
/*      VI_FALSE - Turn averaging off.                                       */
/*                                                                           */
/*    ViInt16 cdma1CSPAverageMode                                            */
/*                                                                           */
/*      Selects the type of terminal control for averaging.                  */
/*                                                                           */
/*      hpesa_AVERAGE_EXPONENTIAL  - Each successive data acquisition after  */
/*      the average count is reached, is exponentially weighted and combined */
/*      with the existing average.                                           */
/*                                                                           */
/*      hpesa_AVERAGE_REPEAT - After reaching the average count, the         */
/*      averaging is reset and a new average is started.                     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CSPSetAveraging
                       (ViSession instrumentHandle,
                        ViInt32 cdma1CSPAverageCount,
                        ViBoolean cdma1CSPAverageState,
                        ViInt16 cdma1CSPAverageMode)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr);

    // check the input parameters
    CHK_BOOLEAN(cdma1CSPAverageState, VI_ERROR_PARAMETER3)
    CHK_ENUM(cdma1CSPAverageMode, 0, hpesa_AVERAGE_MODE_LASTENUM,
             VI_ERROR_PARAMETER4)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = GenSetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_CSP,
                                cdma1CSPAverageCount,
                                cdma1CSPAverageState,
                                cdma1CSPAverageMode);
    
	if(errStatus < VI_SUCCESS) return errStatus;


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_CSPSetAveraging                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CSPGetAveraging                                              */
/*                                                                           */
/*      This method retrieves the averaging setup for CDMA One close spurs   */
/*      power (CSP) measurements.                                            */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt32 cdma1CSPAverageCountQuery                                     */
/*                                                                           */
/*      Current number of data acquisitions that will be averaged. After the */
/*      specified number of average counts, the averaging mode (terminal     */
/*      control) determines the averaging action.                            */
/*                                                                           */
/*    ViPBoolean cdma1CSPAverageStateQuery                                   */
/*                                                                           */
/*      Returns the current average state.                                   */
/*                                                                           */
/*      0 = VI_FALSE                                                         */
/*      1 = VI_TRUE                                                          */
/*                                                                           */
/*    ViPInt16 cdma1CSPAverageModeQ                                          */
/*                                                                           */
/*      Returns the current instrument type of terminal control for          */
/*      averaging.                                                           */
/*                                                                           */
/*      0 = hpesa_AVERAGE_EXPONENTIAL                                        */
/*      1 = hpesa_AVERAGE_REPEAT                                             */
/*                                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CSPGetAveraging
                       (ViSession instrumentHandle,
                        ViPInt32 cdma1CSPAverageCountQuery,
                        ViPBoolean cdma1CSPAverageStateQuery,
                        ViPInt16 cdma1CSPAverageModeQ)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr);

    // check the input parameters
    CHK_NULL_POINTER(cdma1CSPAverageCountQuery,VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(cdma1CSPAverageStateQuery,VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(cdma1CSPAverageModeQ,VI_ERROR_PARAMETER4)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = GenGetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_CSP,
                                cdma1CSPAverageCountQuery,
                                cdma1CSPAverageStateQuery,
                                cdma1CSPAverageModeQ);
    if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_CSPGetAveraging                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CSPSetMeasurementType                                        */
/*                                                                           */
/*      This method set the CDMA One close spurs power (CSP) measurement     */
/*      type.                                                                */
/*                                                                           */
/*      Note:  This method will cause the cdmaOne close spurs averaging mode */
/*      to reset to "Repeat" if the measurement type is set to "Full".       */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 cdma1CSPMeasType                                               */
/*                                                                           */
/*      Sets the new measurement type.                                       */
/*                                                                           */
/*      hpesa_CSP_MEAS_TYPE_EXAMINE - In single sweep mode - measures spurs  */
/*      in the upper, lower, and center segments and then displays the       */
/*      segment with the highest power spur.                                 */
/*      In the continuous mode - measures spurs in the upper, lower, and     */
/*      center segments. It then continuously measures the segment with the  */
/*      highest power spur. The initial spur values are held and the marker  */
/*      value is updated with the current spur value found on each sweep.    */
/*      Segment All is not active when the measurement type Examine is       */
/*      selected.                                                            */
/*                                                                           */
/*      hpesa_CSP_MEAS_TYPE_FULL  - In single sweep mode - measures the      */
/*      spurs in the upper, lower, and center segments and then displays the */
/*      segment with the highest power spur.                                 */
/*      In continuous mode - measures spurs in the upper, lower, and center  */
/*      segments. It then continuously cycles through segments. Unlike       */
/*      Examine, all results values are updated with the current spur values */
/*      found on each sweep.                                                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CSPSetMeasurementType
                       (ViSession instrumentHandle,
                        ViInt16 cdma1CSPMeasType)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr);

    //check the input parameter
    CHK_ENUM(cdma1CSPMeasType, 0, hpesa_CSP_MEAS_TYPE_LASTENUM,
                                           VI_ERROR_PARAMETER2);

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    switch(cdma1CSPMeasType)
    {
        case hpesa_CSP_MEAS_TYPE_EXAMINE:
            sprintf(buffer, "CSP:TYPE EXAM");
            break;
        case hpesa_CSP_MEAS_TYPE_FULL:
            sprintf(buffer, "CSP:TYPE FULL");
            break;
        default:
            fprintf(stderr, "Logic error in hpesa_cdma1_CSPSetMeasurementType");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, buffer);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                   end hpesa_cdma1_CSPSetMeasurementType                   */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_CSPGetMeasurementType                                        */
/*                                                                           */
/*      This method retrieves the CDMA One close spurs power (CSP)           */
/*      measurement type.                                                    */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 cdma1CSPMeasTypeQuery                                         */
/*                                                                           */
/*      Current measurement type.                                            */
/*                                                                           */
/*      0 = hpesa_CSP_MEAS_TYPE_EXAMINE                                      */
/*      1 = hpesa_CSP_MEAS_TYPE_FULL                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_CSPGetMeasurementType
                       (ViSession instrumentHandle,
                        ViPInt16 cdma1CSPMeasTypeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
    struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    //check for null pointer
	CHK_NULL_POINTER(cdma1CSPMeasTypeQuery,VI_ERROR_PARAMETER2)

    //check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    //Retrieve the Measurement Type
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  "CSP:TYPE?",
                                  64, 
                                  buffer);

    if(errStatus<VI_SUCCESS) return errStatus;

	//remove the trailing \n
	buffer[strlen(buffer) - 1] = '\0';

    if(!strcmp(buffer, "EXAM"))
           *cdma1CSPMeasTypeQuery = hpesa_CSP_MEAS_TYPE_EXAMINE;
    else if (!strcmp(buffer, "FULL"))
    	   *cdma1CSPMeasTypeQuery = hpesa_CSP_MEAS_TYPE_FULL;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                   end hpesa_cdma1_CSPGetMeasurementType                   */
/*****************************************************************************/


                       /*****************************/
                       /*  cdmaOne SHP Measurements */
                       /*****************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_SHPConfigure                                                 */
/*                                                                           */
/*      This method sets up the instrument for CDMA One spurs at harmonic    */
/*      power (SHP) measurements using the factory default instrument        */
/*      settings.  It stops the current measurement and sets up the          */
/*      instrument for the Spurs at Harmonics (SHP) measurement using the    */
/*      factory default instrument settings. It does not initiate the taking */
/*      of measurement data. This command also turns the averaging function  */
/*      on and sets the number of averages to 10 for all measurements.       */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_SHPConfigure
                       (ViSession instrumentHandle)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    ViInt16 temp = 0;
    
    GET_GLOBALS(instrumentHandle, thisPtr);

    //check the Application
	VERIFY_APP(hpesa_APPLICATION_CDMA);

    errStatus = hpesa_cmdInt16_Q(instrumentHandle, "CONF:HARM;*OPC?", &temp);

//    errStatus = hpesa_cmd(instrumentHandle, "CONF:HARM");


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_cdma1_SHPConfigure                        */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_SHPMeasureTrace                                              */
/*                                                                           */
/*      This method measures the power of the CDMA One spurious emissions at */
/*      the selected harmonic frequencies of the current channel frequency   */
/*      using the selected resolution bandwidth filter. The number of spurs  */
/*      to be measured can be set by the "cdma1SHPSetNumberHarmonics"        */
/*      function. For each harmonic, the reference level is set 40 dB above  */
/*      the largest amplitude limit with input attenuation held constant.    */
/*      The attenuation is set to limit the carrier (fundamental) power at   */
/*      the spectrum analyzer input mixer to the value determined by Max     */
/*      Mixer Lvl. You must be in the cdmaOne mode to use these commands.    */
/*                                                                           */
/*      User can select one of three types of measurement modes: Measure,    */
/*      Read, or Fetch.                                                      */
/*                                                                           */
/*      This method returns the SHP measurement results specified by the     */
/*      "cdma1SHPResultsType" parameter as a real array.                     */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1SHPMeasureTraceTimeout                                   */
/*                                                                           */
/*      This value temporarily changes the VISA timeout setting for the      */
/*      duration of the instrument measurement. The user needs to set this   */
/*      value to an appropriate time that will be longer then the expected   */
/*      measurement time. Units are in seconds.                              */
/*                                                                           */
/*    ViInt16 cdma1SHPMeasureTraceType                                       */
/*                                                                           */
/*      Selects measurement type. Note that for hpesa_FETCH type the         */
/*      instrument should already be in this measurement mode else the       */
/*      function will time out. User can select this measurement mode by     */
/*      first using the "MEASURE" or "READ" types or call the                */
/*      hpesa_cdma1_SHPConfigure function.                                   */
/*                                                                           */
/*      hpesa_MEASURE - Stops current measurement, changes to this selected  */
/*      measurement, sets up instrument using factory defaults, makes        */
/*      measurement, returns measurement results.                            */
/*                                                                           */
/*      hpesa_READ - Stops current measurement,  changes to this selected    */
/*      measurement, uses instrument settings from last measurement of this  */
/*      type, makes measurement, returns measurements results.               */
/*                                                                           */
/*      hpesa_FETCH - Returns measurements results only. No new measurement  */
/*      is initiated.                                                        */
/*                                                                           */
/*    ViInt16 cdma1SHPResultsType                                            */
/*                                                                           */
/*      Determines the format of the values returned in cdma1SHPDataResults. */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_0:                                                */
/*      Not supported.                                                       */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_1:                                                */
/*      Returns 61 values. The channel power value and a 10 row by 6 column  */
/*      array of values. Each row contains the following values:             */
/*      1. Harmonic number                                                   */
/*      2. Frequency (MHz)                                                   */
/*      3. Absolute amplitude (dBm)                                          */
/*      4. Delta from the absolute limit                                     */
/*      5. Relative amplitude from the carrier (dBc)                         */
/*      6. Delta from the relative limit                                     */
/*                                                                           */
/*    ViAReal64 cdma1SHPDataResults                                          */
/*                                                                           */
/*      Trace data returned by measurement, formatted according to           */
/*      cdma1SHPResultsType.                                                 */
/*                                                                           */
/*    ViInt32 cdma1SHPDataResultsMaxSz                                       */
/*                                                                           */
/*      Maximum size of cdma1SHPDataResults array.                           */
/*                                                                           */
/*    ViPInt32 cdma1SHPDataResultsSz                                         */
/*                                                                           */
/*      Maximum size of cdma1SHPDataResults array.                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_SHPMeasureTrace
                       (ViSession instrumentHandle,
                        ViReal64 cdma1SHPMeasureTraceTimeout,
                        ViInt16 cdma1SHPMeasureTraceType,
                        ViInt16 cdma1SHPResultsType,
                        ViAReal64 cdma1SHPDataResults,
                        ViInt32 cdma1SHPDataResultsMaxSz,
                        ViPInt32 cdma1SHPDataResultsSz)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	int SHPValidResults[7] = {0,1,0,0,0,0,0};
	
	GET_GLOBALS(instrumentHandle, thisPtr);

    // check the input parameters
    CHK_ENUM(cdma1SHPMeasureTraceType, 0, hpesa_MEASURE_METHOD_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)
    CHK_ENUM(cdma1SHPResultsType, 0, hpesa_RESULTS_TYPE_LASTENUM,
                                                        VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(cdma1SHPDataResults, VI_ERROR_PARAMETER5)

    CHK_NULL_POINTER(cdma1SHPDataResultsSz, VI_ERROR_PARAMETER7)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

	//check for invalid results type
	if((cdma1SHPResultsType > 6) || (SHPValidResults[cdma1SHPResultsType] == 0))
        return hpesa_INSTR_ERROR_INVALID_RESULTS_TYPE;

    errStatus = GenMeasureTrace(instrumentHandle,
                               hpesa_APPLICATION_MODE_SHP,
                               cdma1SHPMeasureTraceTimeout,
                               cdma1SHPMeasureTraceType,
                               cdma1SHPResultsType,
                               cdma1SHPDataResults,
                               cdma1SHPDataResultsMaxSz,
                               cdma1SHPDataResultsSz);

    if(errStatus < VI_SUCCESS) return errStatus;



    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_SHPMeasureTrace                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_SHPSetAveraging                                              */
/*                                                                           */
/*      This method sets up averaging for CDMA One spurs at harmonics (SHP)  */
/*      measurements. User can control the number of averages, turn on and   */
/*      off averaging, and set the terminal control mode for averaging.      */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 cdma1SHPAverageCount                                           */
/*                                                                           */
/*      Sets the number of data acquisitions that will be averaged. After    */
/*      the specified number of average counts, the averaging mode (terminal */
/*      control) determines the averaging action.                            */
/*                                                                           */
/*    ViBoolean cdma1SHPAverageState                                         */
/*                                                                           */
/*      Turns averaging on or off.                                           */
/*                                                                           */
/*      VI_TRUE - Turn averaging on.                                         */
/*      VI_FALSE - Turn averaging off.                                       */
/*                                                                           */
/*    ViInt16 cdma1SHPAverageMode                                            */
/*                                                                           */
/*      Selects the type of terminal control for averaging.                  */
/*                                                                           */
/*      hpesa_AVERAGE_EXPONENTIAL  - Each successive data acquisition after  */
/*      the average count is reached, is exponentially weighted and combined */
/*      with the existing average.                                           */
/*                                                                           */
/*      hpesa_AVERAGE_REPEAT - After reaching the average count, the         */
/*      averaging is reset and a new average is started.                     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_SHPSetAveraging
                       (ViSession instrumentHandle,
                        ViInt32 cdma1SHPAverageCount,
                        ViBoolean cdma1SHPAverageState,
                        ViInt16 cdma1SHPAverageMode)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_BOOLEAN(cdma1SHPAverageState, VI_ERROR_PARAMETER3)
    CHK_ENUM(cdma1SHPAverageMode, 0, hpesa_AVERAGE_MODE_LASTENUM,
                                                        VI_ERROR_PARAMETER4)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = GenSetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_SHP,
                                cdma1SHPAverageCount,
                                cdma1SHPAverageState,
                                cdma1SHPAverageMode);
    return errStatus;
    
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_SHPSetAveraging                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_SHPGetAveraging                                              */
/*                                                                           */
/*      This method retrieves the averaging setup for CDMA One spurs at      */
/*      harmonics (SHP) measurements.                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt32 cdma1SHPAverageCountQuery                                     */
/*                                                                           */
/*      Returns the current number of data acquisitions being averaged.      */
/*                                                                           */
/*    ViPBoolean cdma1SHPAverageStateQuery                                   */
/*                                                                           */
/*      Returns the current instrument average state.                        */
/*                                                                           */
/*      0 = VI_FALSE                                                         */
/*      1 = VI_TRUE                                                          */
/*                                                                           */
/*    ViPInt16 cdma1SHPAverageModeQuery                                      */
/*                                                                           */
/*      Returns the current instrument type of terminal control for          */
/*      averaging.                                                           */
/*      0 = hpesa_AVERAGE_EXPONENTIAL                                        */
/*      1 = hpesa_AVERAGE_REPEAT                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_SHPGetAveraging
                       (ViSession instrumentHandle,
                        ViPInt32 cdma1SHPAverageCountQuery,
                        ViPBoolean cdma1SHPAverageStateQuery,
                        ViPInt16 cdma1SHPAverageModeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr);

    // check the input parameters
    CHK_NULL_POINTER(cdma1SHPAverageCountQuery,VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(cdma1SHPAverageStateQuery,VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(cdma1SHPAverageModeQuery,VI_ERROR_PARAMETER4)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = GenGetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_SHP,
                                cdma1SHPAverageCountQuery,
                                cdma1SHPAverageStateQuery,
                                cdma1SHPAverageModeQuery);
    if(errStatus < VI_SUCCESS) return errStatus;


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_SHPGetAveraging                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_SHPSetNumberHarmonics                                        */
/*                                                                           */
/*      This method sets the number of harmonics to be measured for CDMA One */
/*      spurs at harmonics (SHP) measurements.                               */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 cdma1SHPNumberHarmonics                                        */
/*                                                                           */
/*      Sets the new number of harmonics to be measured. The instrument      */
/*      range is 2 to 10, and the default is 3.                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_SHPSetNumberHarmonics
                       (ViSession instrumentHandle,
                        ViInt32 cdma1SHPNumberHarmonics)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = hpesa_cmdInt(instrumentHandle, 
                              "HARM:NUMB", 
                              cdma1SHPNumberHarmonics);


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                   end hpesa_cdma1_SHPSetNumberHarmonics                   */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_SHPGetNumberHarmonics                                        */
/*                                                                           */
/*      This method retrieves the current number of harmonics to be measured */
/*      for CDMA One spurs at harmonics (SHP) measurements.                  */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt32 cdma1SHPNumberHarmQuery                                       */
/*                                                                           */
/*      Returns the current number of harmonics being measured.              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_SHPGetNumberHarmonics
                       (ViSession instrumentHandle,
                        ViPInt32 cdma1SHPNumberHarmQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_NULL_POINTER(cdma1SHPNumberHarmQuery,VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    errStatus = hpesa_cmdInt32_Q(instrumentHandle, 
                                  "HARM:NUMB?", 
                                  cdma1SHPNumberHarmQuery);




    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                   end hpesa_cdma1_SHPGetNumberHarmonics                   */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_RadioSetConditions                                           */
/*                                                                           */
/*      This method sets the radio conditions for CDMA One measurements.     */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 cdma1RadioStandardBand                                         */
/*                                                                           */
/*      Selects the standard variant that applies to the radio to be tested. */
/*                                                                           */
/*      hpesa_CDMA1_RADIO_BAND_IS95A - IS-95A Cellular                       */
/*      hpesa_CDMA1_RADIO_BAND_JSTD8 - J-STD-008 PCS                         */
/*      hpesa_CDMA1_RADIO_BAND_C95B - EIA/TIA-95B Cellular                   */
/*      hpesa_CDMA1_RADIO_BAND_P95B - EIA/TIA-95B (PCS)                      */
/*      hpesa_CDMA1_RADIO_BAND_CKOR - TTA.KO-06.0003 (Korea Cell)            */
/*      hpesa_CDMA1_RADIO_BAND_PKOR - TTA.KO-06.0013 (Korea PCS)             */
/*      hpesa_CDMA1_RADIO_BAND_P95C - EIA/TIA-95C (PCS)                      */
/*      hpesa_CDMA1_RADIO_BAND_C95C - EIA/TIA-95C Cellular                   */
/*      hpesa_CDMA1_RADIO_BAND_ARIBT53 - ARIB STD-T53                        */
/*                                                                           */
/*    ViInt16 cdma1RadioDevice                                               */
/*                                                                           */
/*      Selects the type of radio device to be tested.                       */
/*                                                                           */
/*      hpesa_CDMA1_RADIO_DEVICE_BASE - Base transceiver station test.       */
/*      hpesa_CDMA1_RADIO_DEVICE_MOBILE - Mobile transceiver station test.   */
/*                                                                           */
/*    ViReal64 cdma1RadioChannelBW                                           */
/*                                                                           */
/*      Sets the cdmaOne channel bandwidth.                                  */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_RadioSetConditions
                       (ViSession instrumentHandle,
                        ViInt16 cdma1RadioStandardBand,
                        ViInt16 cdma1RadioDevice,
                        ViReal64 cdma1RadioChannelBW)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(cdma1RadioStandardBand, 0, hpesa_CDMA1_RADIO_BAND_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)
    CHK_ENUM(cdma1RadioDevice, 0 , hpesa_CDMA1_RADIO_DEVICE_LASTENUM,
														VI_ERROR_PARAMETER3)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    //Set Radio standard Band
	switch(cdma1RadioStandardBand)
    {
		case hpesa_CDMA1_RADIO_BAND_IS95A:
            sprintf(buffer, ":RAD:STAN:BAND IS95A");
            break;
		case hpesa_CDMA1_RADIO_BAND_JSTD8:
            sprintf(buffer, ":RAD:STAN:BAND JSTD8");
            break;
		case hpesa_CDMA1_RADIO_BAND_C95B:
            sprintf(buffer, ":RAD:STAN:BAND C95B");
            break;
		case hpesa_CDMA1_RADIO_BAND_P95B:
            sprintf(buffer, ":RAD:STAN:BAND P95B");
            break;
		case hpesa_CDMA1_RADIO_BAND_CKOR:
            sprintf(buffer, ":RAD:STAN:BAND CKOR");
            break;
		case hpesa_CDMA1_RADIO_BAND_PKOR:
            sprintf(buffer, ":RAD:STAN:BAND PKOR");
            break;
		case hpesa_CDMA1_RADIO_BAND_P95C:
            sprintf(buffer, ":RAD:STAN:BAND P95C");
            break;
		case hpesa_CDMA1_RADIO_BAND_C95C:
            sprintf(buffer, ":RAD:STAN:BAND C95C");
            break;
		case hpesa_CDMA1_RADIO_BAND_ARIBT53:
            sprintf(buffer, ":RAD:STAN:BAND ARIBT53");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_cdma1_RadioSetConditions");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, buffer);

	if(errStatus <VI_SUCCESS) return errStatus;
	
	//Set Radio standard device
	switch(cdma1RadioDevice)
    {
        case hpesa_CDMA1_RADIO_DEVICE_BASE:
            sprintf(buffer, ":RAD:DEV BS");
            break;
		case hpesa_CDMA1_RADIO_DEVICE_MOBILE:
            sprintf(buffer, ":RAD:DEV MS");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_cdma1_RadioSetConditions");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, buffer);

	if(errStatus <VI_SUCCESS) return errStatus;

	//Set Radio Channel Bandwidth
	errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":RAD:BAND", 
                               cdma1RadioChannelBW);

	if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_cdma1_RadioSetConditions                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_RadioGetConditions                                           */
/*                                                                           */
/*      This method retrieves the current CDMA One radio conditions.         */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 cdma1RadioStandardBandQuery                                   */
/*                                                                           */
/*      Returns the current standard band.                                   */
/*                                                                           */
/*      0 = hpesa_CDMA1_RADIO_BAND_IS95A                                     */
/*      1 = hpesa_CDMA1_RADIO_BAND_JSTD8                                     */
/*      2 = hpesa_CDMA1_RADIO_BAND_C95B                                      */
/*      3 = hpesa_CDMA1_RADIO_BAND_P95B                                      */
/*      4 = hpesa_CDMA1_RADIO_BAND_CKOR                                      */
/*      5 = hpesa_CDMA1_RADIO_BAND_PKOR                                      */
/*      6 = hpesa_CDMA1_RADIO_BAND_P95C                                      */
/*      7 = hpesa_CDMA1_RADIO_BAND_C95C                                      */
/*      8 = hpesa_CDMA1_RADIO_BAND_ARIBT53                                   */
/*                                                                           */
/*    ViPInt16 cdma1RadioDeviceQuery                                         */
/*                                                                           */
/*      Returns the current radio device under test.                         */
/*                                                                           */
/*      0 = hpesa_CDMA1_RADIO_DEVICE_BASE                                    */
/*      1 = hpesa_CDMA1_RADIO_DEVICE_MOBILE                                  */
/*                                                                           */
/*    ViPReal64 cdma1RadioChannelBWQuery                                     */
/*                                                                           */
/*      Returns the current radio channel bandwidth in Hertz.                */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_RadioGetConditions
                       (ViSession instrumentHandle,
                        ViPInt16 cdma1RadioStandardBandQuery,
                        ViPInt16 cdma1RadioDeviceQuery,
                        ViPReal64 cdma1RadioChannelBWQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
	
	GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_NULL_POINTER(cdma1RadioStandardBandQuery,VI_ERROR_PARAMETER2)
	CHK_NULL_POINTER(cdma1RadioDeviceQuery,VI_ERROR_PARAMETER3)
	CHK_NULL_POINTER(cdma1RadioChannelBWQuery,VI_ERROR_PARAMETER4)


    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

	//Retrieve radio standard band
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":RAD:STAN:BAND?",
                                  64, 
                                  buffer);

    if(errStatus<VI_SUCCESS) return errStatus;

	//remove the trailing \n
	buffer[strlen(buffer) - 1] = '\0';

    if(!strcmp(buffer, "IS95A"))
           *cdma1RadioStandardBandQuery = hpesa_CDMA1_RADIO_BAND_IS95A;
	else if(!strcmp(buffer, "JSTD8"))
           *cdma1RadioStandardBandQuery = hpesa_CDMA1_RADIO_BAND_JSTD8;
	else if(!strcmp(buffer, "C95B"))
           *cdma1RadioStandardBandQuery = hpesa_CDMA1_RADIO_BAND_C95B;
	else if(!strcmp(buffer, "P95B"))
           *cdma1RadioStandardBandQuery = hpesa_CDMA1_RADIO_BAND_P95B;
	else if(!strcmp(buffer, "CKOR"))
           *cdma1RadioStandardBandQuery = hpesa_CDMA1_RADIO_BAND_CKOR;
	else if(!strcmp(buffer, "PKOR"))
           *cdma1RadioStandardBandQuery = hpesa_CDMA1_RADIO_BAND_PKOR;
	else if(!strcmp(buffer, "P95C"))
           *cdma1RadioStandardBandQuery = hpesa_CDMA1_RADIO_BAND_P95C;
    else if(!strcmp(buffer, "C95C"))
           *cdma1RadioStandardBandQuery = hpesa_CDMA1_RADIO_BAND_C95C;
    else if(!strcmp(buffer, "ARIBT53"))
           *cdma1RadioStandardBandQuery = hpesa_CDMA1_RADIO_BAND_ARIBT53;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

	//Retrieve radio device
	errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":RAD:DEV?",
                                  64, 
                                  buffer);

    if(errStatus<VI_SUCCESS) return errStatus;

	//remove the trailing \n
	buffer[strlen(buffer) - 1] = '\0';

    if(!strcmp(buffer, "BS"))
           *cdma1RadioDeviceQuery = hpesa_CDMA1_RADIO_DEVICE_BASE;
    else if(!strcmp(buffer, "MS"))
           *cdma1RadioDeviceQuery = hpesa_CDMA1_RADIO_DEVICE_MOBILE;
  	else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }


	//Retrieve radio Channel Bandwidth
	errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":RAD:BAND?", 
                                  cdma1RadioChannelBWQuery);

	if (errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_cdma1_RadioGetConditions                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_InputSetConditions                                           */
/*                                                                           */
/*      This methods sets the input conditions for CDMA One measurements.    */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViBoolean cdma1InputRFRangeState                                       */
/*                                                                           */
/*      Selects the RF port power range to be set either automatically or    */
/*      manually.                                                            */
/*                                                                           */
/*      VI_TRUE - power range is automatically set as determined by the      */
/*      actual measured power level at the start of a measurement.           */
/*                                                                           */
/*      VI_FALSE - power range is manually set                               */
/*                                                                           */
/*    ViReal64 cdma1InputMaxTotalPwr                                         */
/*                                                                           */
/*      Sets the maximum RF total power.  This value is set at its auto      */
/*      value if cdma1InputRFRangeState is set VI_TRUE.                      */
/*                                                                           */
/*    ViReal64 cdma1InputRFAtten                                             */
/*                                                                           */
/*      Sets the RF input attenuator. This value is set at its auto value if */
/*      cdma1InputRFRangeState is set VI_TRUE.                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_InputSetConditions
                       (ViSession instrumentHandle,
                        ViBoolean cdma1InputRFRangeState,
                        ViReal64 cdma1InputMaxTotalPwr,
                        ViReal64 cdma1InputRFAtten)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
	ViChar cmdString[128] = "\0";
        
    GET_GLOBALS(instrumentHandle, thisPtr)

	CHK_BOOLEAN(cdma1InputRFRangeState, VI_ERROR_PARAMETER2)
   
    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

	// Set RF Input Range State
    switch(cdma1InputRFRangeState)
    {
        case VI_FALSE:
            sprintf(buffer, ":POW:RANGE:AUTO 0");
            break;
        case VI_TRUE:
            sprintf(buffer, ":POW:RANGE:AUTO 1");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_cdma1_InputSetConditions");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

	errStatus = hpesa_cmd(instrumentHandle, buffer);

	if(errStatus <VI_SUCCESS) return errStatus;
			
    if(cdma1InputRFRangeState == VI_FALSE)
	{
		//Set Max Total Power
		errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":POW:RANG",
							  cdma1InputMaxTotalPwr); 
                               
		if(errStatus < VI_SUCCESS) return errStatus;

		//Set RF Input Attenuation
		errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":POW:ATT",
							  cdma1InputRFAtten); 
                               
		if(errStatus < VI_SUCCESS) return errStatus;
	}

	return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_cdma1_InputSetConditions                    */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_InputGetConditions                                           */
/*                                                                           */
/*      This method retrieves the current input conditions for CDMA One      */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPBoolean cdma1InputRFRngeStateQuery                                  */
/*                                                                           */
/*      Returns whether the RF port power range is set automatically or      */
/*      manually.                                                            */
/*                                                                           */
/*      0 = VI_FALSE                                                         */
/*      1 = VI_TRUE                                                          */
/*                                                                           */
/*    ViPReal64 cdma1InputMaxTotalPwrQuery                                   */
/*                                                                           */
/*      Returns the current maximum RF total power.                          */
/*                                                                           */
/*    ViPReal64 cdma1InputRFAttenQuery                                       */
/*                                                                           */
/*      Returns the current RF input attenuation.                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_InputGetConditions
                       (ViSession instrumentHandle,
                        ViPBoolean cdma1InputRFRngeStateQuery,
                        ViPReal64 cdma1InputMaxTotalPwrQuery,
                        ViPReal64 cdma1InputRFAttenQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
	
	GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_NULL_POINTER(cdma1InputRFRngeStateQuery,VI_ERROR_PARAMETER2)
	CHK_NULL_POINTER(cdma1InputMaxTotalPwrQuery,VI_ERROR_PARAMETER3)
	CHK_NULL_POINTER(cdma1InputRFAttenQuery,VI_ERROR_PARAMETER4)
	
	// check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

	//Retrieve RF Input Range State
	errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":POW:RANG:AUTO?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0';  // strip the trailing \n

    if(!strcmp(buffer, "0"))
        *cdma1InputRFRngeStateQuery = VI_FALSE;
    else if (!strcmp(buffer, "1"))
        *cdma1InputRFRngeStateQuery = VI_TRUE;
	else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

   	//Retrieve Max Total Power
	errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":POW:RANG?", 
                                  cdma1InputMaxTotalPwrQuery);

	if (errStatus < VI_SUCCESS) return errStatus;

	//Retrieve RF Input Attenuation
	errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":POW:ATT?", 
                                  cdma1InputRFAttenQuery);

	if (errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_cdma1_InputGetConditions                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_InputSetGainAtten                                            */
/*                                                                           */
/*      This method sets the base station external attenuation and mobile    */
/*      station external gain for CDMA One measurements.                     */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 cdma1InputBSExtGain                                           */
/*                                                                           */
/*      Sets the correction equal to the external attenuation used when      */
/*      measuring base stations.                                             */
/*                                                                           */
/*    ViReal64 cdma1InputExtGain                                             */
/*                                                                           */
/*      Sets the gain of the external preamplifier for mobile station        */
/*      measurements.                                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_InputSetGainAtten
                       (ViSession instrumentHandle,
                        ViReal64 cdma1InputBSExtGain,
                        ViReal64 cdma1InputExtGain)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    VERIFY_APP(hpesa_APPLICATION_CDMA)

    // Set external attenuation
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":CORR:BS:LOSS", 
                              cdma1InputBSExtGain);
    if(errStatus < VI_SUCCESS) return errStatus;

    // Set external gain 
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":CORR:GAIN", 
                              cdma1InputExtGain);
    if(errStatus < VI_SUCCESS) return errStatus;


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_cdma1_InputSetGainAtten                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_InputGetGainAtten                                            */
/*                                                                           */
/*      This method retrieves the current the base station external          */
/*      attenuation and mobile station external gain for CDMA One            */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPReal64 cdma1InputBSExtGainQuery                                     */
/*                                                                           */
/*      Returns the current external attenuation used when measuring base    */
/*      stations.                                                            */
/*                                                                           */
/*    ViPReal64 cdma1InputExtGainQuery                                       */
/*                                                                           */
/*      Returns the current gain of the external preamplifier for mobile     */
/*      station measurements.                                                */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_InputGetGainAtten
                       (ViSession instrumentHandle,
                        ViPReal64 cdma1InputBSExtGainQuery,
                        ViPReal64 cdma1InputExtGainQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(cdma1InputBSExtGainQuery, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(cdma1InputExtGainQuery, VI_ERROR_PARAMETER3)
    
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    // Get the trigger delay
    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":CORR:BS:LOSS?", 
                                  cdma1InputBSExtGainQuery);
    if(errStatus < VI_SUCCESS) return errStatus;

    // Get the level
    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":CORR:GAIN?", 
                                  cdma1InputExtGainQuery);
    if(errStatus < VI_SUCCESS) return errStatus;


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_cdma1_InputGetGainAtten                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_DemodSetConfig                                               */
/*                                                                           */
/*      This method sets the demod setting for CDMA One measurements.        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 cdma1DemodTimeRefSync                                          */
/*                                                                           */
/*      Sets the time reference to the external frame synchronization        */
/*      source.                                                              */
/*                                                                           */
/*      hpesa_DEMOD_TIME_REF_ESEC - External frame synchronization source.   */
/*      hpesa_DEMOD_TIME_REF_OFF - Turns off the synchronization source.     */
/*                                                                           */
/*    ViInt16 cdma1DemodTrigSource                                           */
/*                                                                           */
/*      Selects the trigger source used to control data acquisitions.        */
/*                                                                           */
/*      hpesa_DEMOD_TRIG_SOURCE_EXTERNAL - rear panel external trigger input */
/*                                                                           */
/*      hpesa_DEMOD_TRIG_SOURCE_FRAME - internal frame trigger from front    */
/*      panel input                                                          */
/*                                                                           */
/*      hpesa_DEMOD_TRIG_SOURCE_IMMEDIATE - the next data acquisition is     */
/*      immediately taken, capturing the signal asynchronously (also called  */
/*      free run).                                                           */
/*                                                                           */
/*      hpesa_DEMOD_TRIG_SOURCE_RFBURST - internal wideband RF burst         */
/*      envelope trigger that has automatic level control for periodic burst */
/*      signals. (Also called BCT)                                           */
/*                                                                           */
/*    ViInt32 cdma1DemodPNOffset                                             */
/*                                                                           */
/*      Sets the PN Offset in chips.                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_DemodSetConfig
                       (ViSession instrumentHandle,
                        ViInt16 cdma1DemodTimeRefSync,
                        ViInt16 cdma1DemodTrigSource,
                        ViInt32 cdma1DemodPNOffset)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(cdma1DemodTimeRefSync, 0, hpesa_DEMOD_TIME_REF_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)
    CHK_ENUM(cdma1DemodTrigSource, 0 , hpesa_DEMOD_TRIG_SOURCE_LASTENUM,
														VI_ERROR_PARAMETER3)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

    //Set Time Ref Sync
	switch(cdma1DemodTimeRefSync)
    {
        case hpesa_DEMOD_TIME_REF_ESEC:
            sprintf(buffer, ":DEM:SYNC ESEC ");
            break;
		case hpesa_DEMOD_TIME_REF_OFF:
            sprintf(buffer, ":DEM:SYNC NONE");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_cdma1_DemodSetConfig");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, buffer);

	if(errStatus <VI_SUCCESS) return errStatus;

   	//Set Demod Trig Source if Time Reference Sync == NONE
	if(cdma1DemodTimeRefSync == hpesa_DEMOD_TIME_REF_OFF)
	{
		switch(cdma1DemodTrigSource)
		{
			case hpesa_DEMOD_TRIG_SOURCE_IMMEDIATE:
				sprintf(buffer, ":DEM:TRIG:SOUR IMM");
				break;
			case hpesa_DEMOD_TRIG_SOURCE_RFBURST:
				sprintf(buffer, ":DEM:TRIG:SOUR RFB");
				break;
			case hpesa_DEMOD_TRIG_SOURCE_EXTERNAL:
				sprintf(buffer, ":DEM:TRIG:SOUR EXT");
				break;
			case hpesa_DEMOD_TRIG_SOURCE_FRAME:
				sprintf(buffer, ":DEM:TRIG:SOUR FRAM");
				break;
			default:
				fprintf(stderr, "Logic error in hpesa_cdma1_DemodSetConfig");
				return hpesa_INSTR_ERROR_UNEXPECTED;
		}

		errStatus = hpesa_cmd(instrumentHandle, buffer);

		if(errStatus <VI_SUCCESS) return errStatus;

	}

    //Set PN Offset 
	errStatus = hpesa_cmdInt(instrumentHandle, 
                              ":CHAN:PNOF", 
                               cdma1DemodPNOffset);

	if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_DemodSetConfig                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_cdma1_DemodGetConfig                                               */
/*                                                                           */
/*      This method retrieves the current demod values for CDMA One          */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 cdma1DemodTimeRefSyncQuery                                    */
/*                                                                           */
/*      Returns the current external frame synchronization source.           */
/*                                                                           */
/*    ViPInt16 cdma1DemodTrigSourceQuery                                     */
/*                                                                           */
/*      Returns the current trigger source used to control data acquisition. */
/*                                                                           */
/*      0 = hpesa_DEMOD_TRIG_SOURCE_EXTERNAL                                 */
/*      1 = hpesa_DEMOD_TRIG_SOURCE_FRAME                                    */
/*      2 = hpesa_DEMOD_TRIG_SOURCE_IMMEDIATE                                */
/*      3 = hpesa_DEMOD_TRIG_SOURCE_RFBURST                                  */
/*                                                                           */
/*    ViPInt32 cdma1DemodPNOffsetQuery                                       */
/*                                                                           */
/*      Returns the current PN offset.                                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_cdma1_DemodGetConfig
                       (ViSession instrumentHandle,
                        ViPInt16 cdma1DemodTimeRefSyncQuery,
                        ViPInt16 cdma1DemodTrigSourceQuery,
                        ViPInt32 cdma1DemodPNOffsetQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
	
	GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_NULL_POINTER(cdma1DemodTimeRefSyncQuery,VI_ERROR_PARAMETER2)
	CHK_NULL_POINTER(cdma1DemodTrigSourceQuery,VI_ERROR_PARAMETER3)
	CHK_NULL_POINTER(cdma1DemodPNOffsetQuery,VI_ERROR_PARAMETER4)


    // check the application
    VERIFY_APP(hpesa_APPLICATION_CDMA)

	//Retrieve Time Reference Sync
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":DEM:SYNC?",
                                  64, 
                                  buffer);

    if(errStatus<VI_SUCCESS) return errStatus;

	//remove the trailing \n
	buffer[strlen(buffer) - 1] = '\0';

    if(!strcmp(buffer, "ESEC"))
           *cdma1DemodTimeRefSyncQuery = hpesa_DEMOD_TIME_REF_ESEC;
    else if(!strcmp(buffer, "NONE"))
           *cdma1DemodTimeRefSyncQuery = hpesa_DEMOD_TIME_REF_OFF;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

	//Retrieve Trigger Source
	errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":DEM:TRIG:SOUR?",
                                  64, 
                                  buffer);

    if(errStatus<VI_SUCCESS) return errStatus;

	//remove the trailing \n
	buffer[strlen(buffer) - 1] = '\0';

    if(!strcmp(buffer, "EXT"))
           *cdma1DemodTrigSourceQuery = hpesa_DEMOD_TRIG_SOURCE_EXTERNAL;
    else if(!strcmp(buffer, "FRAM"))
           *cdma1DemodTrigSourceQuery = hpesa_DEMOD_TRIG_SOURCE_FRAME;
  	else if(!strcmp(buffer, "IMM"))
           *cdma1DemodTrigSourceQuery = hpesa_DEMOD_TRIG_SOURCE_IMMEDIATE;
  	else if(!strcmp(buffer, "RFB"))
           *cdma1DemodTrigSourceQuery = hpesa_DEMOD_TRIG_SOURCE_RFBURST;
  	else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

	//Retrieve PN Offset
	errStatus = hpesa_cmdInt32_Q(instrumentHandle, 
                                  ":CHAN:PNOF?", 
                                  cdma1DemodPNOffsetQuery);

	if (errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_cdma1_DemodGetConfig                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_RadioSetConditions                                             */
/*                                                                           */
/*      This method sets the radio conditions for GSM measurements           */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSMRadioStandardBand                                           */
/*                                                                           */
/*      Selects the standard variant that applies to the radio to be tested. */
/*                                                                           */
/*      hpesa_GSM_RADIO_BAND_PGSM - P-GSM900                                 */
/*      hpesa_GSM_RADIO_BAND_EGSM - E-GSM900                                 */
/*      hpesa_GSM_RADIO_BAND_RGSM - R-GSM900                                 */
/*      hpesa_GSM_RADIO_BAND_DCS - DCS-1800                                  */
/*      hpesa_GSM_RADIO_BAND_PCS - PCS-1900                                  */
/*                                                                           */
/*    ViInt16 GSMRadioDevice                                                 */
/*                                                                           */
/*      Selects the type of radio device to be tested.                       */
/*                                                                           */
/*      hpesa_GSM_RADIO_DEVICE_MS - Mobile station transmitter test          */
/*      hpesa_GSM_RADIO_DEVICE_BTS - Base station transmitter test           */
/*      hpesa_GSM_RADIO_DEVICE_UBTS1 - Micro base station class M1           */
/*      transmitter test                                                     */
/*      hpesa_GSM_RADIO_DEVICE_UBTS2 - Micro base station class M2           */
/*      transmitter test                                                     */
/*      hpesa_GSM_RADIO_DEVICE_UBTS3 - Micro base station class M3           */
/*      transmitter test                                                     */
/*                                                                           */
/*    ViBoolean GSMFreqHopState                                              */
/*                                                                           */
/*      Sets the signals frequency hopping repetition factor on or off.     */
/*                                                                           */
/*      VI_TRUE - Turns on frequency hopping repetition factor.              */
/*      VI_FALSE - Turns off frequency hopping repetition factor.            */
/*                                                                           */
/*    ViInt32 GSMFreqHopFactor                                               */
/*                                                                           */
/*      Sets the frequency hopping repetition factor.  Range is between 1    */
/*      and 100.                                                             */
/*                                                                           */
/*    ViInt16 GSMOverlapPriority                                             */
/*                                                                           */
/*      Selects a priority band when entering an ARFCN that is common to     */
/*      more than one band.                                                  */
/*                                                                           */
/*      hpesa_GSM_PRIORITY_BAND_DCS - Selects the DCS priority band.         */
/*      hpesa_GSM_PRIORITY_BAND_PCS - Selects the PCS priority band.         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_RadioSetConditions
                       (ViSession instrumentHandle,
                        ViInt16 GSMRadioStandardBand,
                        ViInt16 GSMRadioDevice,
                        ViBoolean GSMFreqHopState,
                        ViInt32 GSMFreqHopFactor,
                        ViInt16 GSMOverlapPriority)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
	ViChar cmdString[128] = "\0";
	ViBoolean InstrReady = VI_FALSE;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(GSMRadioStandardBand, 0, hpesa_GSM_RADIO_BAND_LASTENUM, 
                                               VI_ERROR_PARAMETER2)

    CHK_ENUM(GSMRadioDevice, 0 , hpesa_GSM_RADIO_DEVICE_LASTENUM,
							  	            VI_ERROR_PARAMETER3)
	
	CHK_BOOLEAN(GSMFreqHopState, VI_ERROR_PARAMETER4)
	
	CHK_ENUM(GSMOverlapPriority, 0 , hpesa_GSM_PRIORITY_BAND_LASTENUM,
							  	            VI_ERROR_PARAMETER6)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    //Set Radio standard Band
	switch(GSMRadioStandardBand)
    {
		case hpesa_GSM_RADIO_BAND_PGSM:
            sprintf(buffer, ":RAD:STAN:BAND PGSM");
            break;
		case hpesa_GSM_RADIO_BAND_EGSM:
            sprintf(buffer, ":RAD:STAN:BAND EGSM");
            break;
		case hpesa_GSM_RADIO_BAND_RGSM:
            sprintf(buffer, ":RAD:STAN:BAND RGSM");
            break;
		case hpesa_GSM_RADIO_BAND_DCS:
            sprintf(buffer, ":RAD:STAN:BAND DCS");
            break;
		case hpesa_GSM_RADIO_BAND_PCS:
            sprintf(buffer, ":RAD:STAN:BAND PCS");
            break;
		
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_RadioSetConditions");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    	
	//Set Radio standard device
	switch(GSMRadioDevice)
    {
        case hpesa_GSM_RADIO_DEVICE_MS:
            sprintf(cmdString,"%s;:RAD:DEV MS",buffer);
            break;
		case hpesa_GSM_RADIO_DEVICE_BTS:
            sprintf(cmdString, "%s;:RAD:DEV BTS",buffer);
            break;
		case hpesa_GSM_RADIO_DEVICE_UBTS1:
            sprintf(cmdString, "%s;:RAD:DEV UBTS1",buffer);
            break;
		case hpesa_GSM_RADIO_DEVICE_UBTS2:
            sprintf(cmdString, "%s;:RAD:DEV UBTS2",buffer);
            break;
		case hpesa_GSM_RADIO_DEVICE_UBTS3:
            sprintf(cmdString, "%s;:RAD:DEV UBTS3",buffer);
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_RadioSetConditions");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, cmdString);
	if(errStatus < VI_SUCCESS)
		return errStatus;

	hpesa_opc_Q(instrumentHandle,&InstrReady);

	// Set Frequency hopping State
    errStatus = hpesa_cmdInt(instrumentHandle,":CHAN:SFH",GSMFreqHopState);

	if(errStatus < VI_SUCCESS) return errStatus;

	hpesa_opc_Q(instrumentHandle,&InstrReady);

	if(GSMFreqHopState == VI_TRUE)
	{
		//Set Frequency Hop factor
		errStatus = hpesa_cmdInt(instrumentHandle,":CHAN:SFHR",GSMFreqHopFactor); 
	
		if(errStatus < VI_SUCCESS) return errStatus;

	}
                               

	//Set GSM Overlap Priority
	switch(GSMOverlapPriority)
    {
        case hpesa_GSM_PRIORITY_BAND_DCS:
            sprintf(buffer, ":CHAN:PREF DCS");
            break;
		case hpesa_GSM_PRIORITY_BAND_PCS:
            sprintf(buffer, ":CHAN:PREF PCS");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_RadioSetConditions");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, buffer);

	return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_RadioSetConditions                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_RadioGetConditions                                             */
/*                                                                           */
/*      This method retrieves the current radio conditions for GSM           */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSMRadioStandardBandQuery                                     */
/*                                                                           */
/*      Returns the current standard variant that applies to the radio to be */
/*      tested.                                                              */
/*                                                                           */
/*      0 = hpesa_GSM_RADIO_BAND_PGSM                                        */
/*      1 = hpesa_GSM_RADIO_BAND_EGSM                                        */
/*      2 = hpesa_GSM_RADIO_BAND_RGSM                                        */
/*      3 = hpesa_GSM_RADIO_BAND_DCS                                         */
/*      4 = hpesa_GSM_RADIO_BAND_PCS                                         */
/*                                                                           */
/*    ViPInt16 GSMRadioDeviceQuery                                           */
/*                                                                           */
/*      Returns the current type of radio device to be tested.               */
/*                                                                           */
/*      0 = hpesa_GSM_RADIO_DEVICE_MS                                        */
/*      1 = hpesa_GSM_RADIO_DEVICE_BTS                                       */
/*      2 = hpesa_GSM_RADIO_DEVICE_UBTS1                                     */
/*      3 = hpesa_GSM_RADIO_DEVICE_UBTS2                                     */
/*      4 = hpesa_GSM_RADIO_DEVICE_UBTS3                                     */
/*                                                                           */
/*    ViPBoolean GSMFreqHopStateQuery                                        */
/*                                                                           */
/*      Returns the current frequency hopping repetition factor state.       */
/*                                                                           */
/*      0 = VI_FALSE                                                         */
/*      1 = VI_TRUE                                                          */
/*                                                                           */
/*    ViPInt32 GSMFreqHopFactorQuery                                         */
/*                                                                           */
/*      Returns the current frequency hopping repetition factor.             */
/*                                                                           */
/*    ViPInt16 GSMOverlapPriorityQuery                                       */
/*                                                                           */
/*      Returns the current priority overlap band.                           */
/*                                                                           */
/*      0 = hpesa_GSM_PRIORITY_BAND_DCS                                      */
/*      1 = hpesa_GSM_PRIORITY_BAND_PCS                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_RadioGetConditions
                       (ViSession instrumentHandle,
                        ViPInt16 GSMRadioStandardBandQuery,
                        ViPInt16 GSMRadioDeviceQuery,
                        ViPBoolean GSMFreqHopStateQuery,
                        ViPInt32 GSMFreqHopFactorQuery,
                        ViPInt16 GSMOverlapPriorityQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
	
	GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_NULL_POINTER(GSMRadioStandardBandQuery,VI_ERROR_PARAMETER2)
	CHK_NULL_POINTER(GSMRadioDeviceQuery,VI_ERROR_PARAMETER3)
	CHK_NULL_POINTER(GSMFreqHopStateQuery,VI_ERROR_PARAMETER4)
	CHK_NULL_POINTER(GSMFreqHopFactorQuery,VI_ERROR_PARAMETER5)
	CHK_NULL_POINTER(GSMOverlapPriorityQuery,VI_ERROR_PARAMETER6)
	
    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	//Retrieve radio standard band
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":RAD:STAN:BAND?",
                                  64, 
                                  buffer);

    if(errStatus<VI_SUCCESS) return errStatus;

	//remove the trailing \n
	buffer[strlen(buffer) - 1] = '\0';

    if(!strcmp(buffer, "PGSM"))
           *GSMRadioStandardBandQuery = hpesa_GSM_RADIO_BAND_PGSM;
	else if(!strcmp(buffer, "EGSM"))
           *GSMRadioStandardBandQuery = hpesa_GSM_RADIO_BAND_EGSM;
	else if(!strcmp(buffer, "RGSM"))
           *GSMRadioStandardBandQuery = hpesa_GSM_RADIO_BAND_RGSM;
	else if(!strcmp(buffer, "DCS"))
           *GSMRadioStandardBandQuery = hpesa_GSM_RADIO_BAND_DCS;
	else if(!strcmp(buffer, "PCS"))
           *GSMRadioStandardBandQuery = hpesa_GSM_RADIO_BAND_PCS;
	else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

	//Retrieve radio device
	errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":RAD:DEV?",
                                  64, 
                                  buffer);

    if(errStatus<VI_SUCCESS) return errStatus;

	//remove the trailing \n
	buffer[strlen(buffer) - 1] = '\0';

    if(!strcmp(buffer, "MS"))
           *GSMRadioDeviceQuery = hpesa_GSM_RADIO_DEVICE_MS;
    else if(!strcmp(buffer, "BTS"))
           *GSMRadioDeviceQuery = hpesa_GSM_RADIO_DEVICE_BTS;
    else if(!strcmp(buffer, "UBTS1"))
           *GSMRadioDeviceQuery = hpesa_GSM_RADIO_DEVICE_UBTS1;
    else if(!strcmp(buffer, "UBTS2"))
           *GSMRadioDeviceQuery = hpesa_GSM_RADIO_DEVICE_UBTS2;
    else if(!strcmp(buffer, "UBTS3"))
           *GSMRadioDeviceQuery = hpesa_GSM_RADIO_DEVICE_UBTS3;
    
	else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }


	//Retrieve Frequency Hop state 
	errStatus = hpesa_cmdInt16_Q(instrumentHandle,":CHAN:SFH?",GSMFreqHopStateQuery);
	if (errStatus < VI_SUCCESS) return errStatus;

	//Retrieve Frequency Hop factor
	errStatus = hpesa_cmdInt32_Q(instrumentHandle,":CHAN:SFHR?",GSMFreqHopFactorQuery);
	if (errStatus < VI_SUCCESS) return errStatus;

	//Retrieve Overlap Priority
	errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":CHAN:PREF?",
                                  64, 
                                  buffer);

    if(errStatus<VI_SUCCESS) return errStatus;

	//remove the trailing \n
	buffer[strlen(buffer) - 1] = '\0';

    if(!strcmp(buffer, "DCS"))
           *GSMOverlapPriorityQuery = hpesa_GSM_PRIORITY_BAND_DCS;
    else if(!strcmp(buffer, "PCS"))
           *GSMOverlapPriorityQuery = hpesa_GSM_PRIORITY_BAND_PCS;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_RadioGetConditions                      */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_InputSetConditions                                             */
/*                                                                           */
/*      This method sets the input conditions for GSM measurements.          */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_RFCarrier                                                  */
/*                                                                           */
/*      Switch between single and multiple carrier modes.                    */
/*      																	 */
/*		hpesa_INPUT_CARRIER_SINGLE - Selects single carrier mode.	         */
/*      hpesa_INPUT_CARRIER_MULTIPLE - Selects multiple carrier mode.      . */
/*                                                                           */
/*    ViBoolean GSM_RFInputRangeState                                        */
/*                                                                           */
/*      Selects the RF port power range to be set either automatically or	 */
/*		manually.		                                                     */
/*                                                                           */
/*    ViReal64 GSMMaxTotalPower                                              */
/*                                                                           */
/*      Sets the maximum total power (in dBm) to be applied at the RF input	 */
/*      The instrument range is -100 to +80 dBm. This value is ignored       */
/*      and instead set by the instrument to the measured value if the RF    */
/*      Input Range is Man (i.e. GSMRFInputRangeState = VI_TRUE).            */
/*                                                                           */
/*    ViReal64 GSM_RFInputAttenuation                                        */
/*                                                                           */
/*      Set the RF input attenuator in dB. The instrument range is 0 to      */
/*      75 dB in 5 dB steps. This value is ignored and instead set by the 	 */
/*      instrument to it's auto value if the RF Input Range is set to Auto.	 */
/*      (i.e. GSMRFInputRangeState = VI_TRUE).                               */
/*     																		 */
/*    ViBoolean GSMInternalPreAmpState                                       */
/*		                                                                     */
/*		  Turns the internal preamp on or off for the currently selected	 */
/*		  measurement.                                                       */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_InputSetConditions
                       (ViSession instrumentHandle,
                        ViInt16 GSM_RFCarrier,
                        ViBoolean GSM_RFInputRangeState,
                        ViReal64 GSMMaxTotalPower,
						ViReal64 GSM_RFInputAttenuation,
						ViBoolean GSMInternalPreAmpState)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    //Check Parameters
	CHK_ENUM(GSM_RFCarrier, 0, hpesa_INPUT_CARRIER_LASTENUM, 
                                       VI_ERROR_PARAMETER2)
	CHK_BOOLEAN(GSM_RFInputRangeState, VI_ERROR_PARAMETER3);
	CHK_BOOLEAN(GSMInternalPreAmpState,VI_ERROR_PARAMETER6);
	
    //Verify Application
	VERIFY_APP(hpesa_APPLICATION_GSM)

	// Set the RFCarrier 
    switch(GSM_RFCarrier)
    {
        case hpesa_INPUT_CARRIER_SINGLE:
            sprintf(buffer, ":POW:CARR SING");
            break;
        case hpesa_INPUT_CARRIER_MULTIPLE:
            sprintf(buffer, ":POW:CARR MULT");
            break;
        default:
            fprintf(stderr, "Logic error in hpesa_GSM_InputSetConditions");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    // Send it
    errStatus = hpesa_cmd(instrumentHandle, buffer);

	if(errStatus <VI_SUCCESS) return errStatus;

	// Set GSM_RF Input Range State
    errStatus = hpesa_cmdInt(instrumentHandle,":POW:RANG:AUTO",GSM_RFInputRangeState);

	if(errStatus < VI_SUCCESS) return errStatus;

    if(GSM_RFInputRangeState == VI_FALSE)
	{
		//Set Max Total Power
		errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":POW:RANG",
							  GSMMaxTotalPower); 
                               
		if(errStatus < VI_SUCCESS) return errStatus;

    	//Set RF Input Attenuation
		errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":POW:ATT",
							  GSM_RFInputAttenuation); 
                               
		if(errStatus < VI_SUCCESS) return errStatus;
	}

	// Set GSMInternalPreAmpState
    errStatus = hpesa_cmdInt(instrumentHandle,":POW:GAIN",GSMInternalPreAmpState);
	
	if(errStatus < VI_SUCCESS) return errStatus;

	return errStatus;
}	

/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_InputSetConditions                      */
/*****************************************************************************/

/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_InputGetConditions                                             */
/*                                                                           */
/*      This method retrieves the input conditions for GSM measurements.     */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_RFCarrierQuery                                             */
/*         																	 */
/*       Returns the current RF Carriers.                                    */
/*                                                                           */
/*		 0 = hpesa_INPUT_CARRIER_SINGLE                                      */
/*       1 = hpesa_INPUT_CARRIER_MULTIPLE     .                              */
/*                                                                           */
/*    ViBoolean GSM_RFInputRangeStateQuery                                   */
/*                                                                           */
/*      Returns the current RF input range state                        	 */
/*																			 */
/*		0 = VI_FALSE														 */
/*		1 = VI_TRUE															 */
/*			                                                                 */
/*          																 */                                                
/*    ViReal64 GSMMaxTotalPowerQuery                                         */
/*                                                                           */
/*      Returns the current maximum total power in dBm. 					 */
/*                                                                           */
/*    ViReal64 GSM_RFInputAttenuationQuery                                   */
/*                                                                           */
/*      Returns the RF input attenuator in dB.                               */
/*     																		 */
/*    ViBoolean GSMInternalPreAmpStateQuery                                  */
/*		 																	 */
/*		Returns the current state of the internal preamp                     */                                               
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_InputGetConditions
                       (ViSession instrumentHandle,
                        ViPInt16 GSM_RFCarrierQuery,
                        ViPBoolean GSM_RFInputRangeStateQuery,
                        ViPReal64 GSMMaxTotalPowerQuery,
						ViPReal64 GSM_RFInputAttenuationQuery,
						ViPBoolean GSMInternalPreAmpStateQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
	
	GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_NULL_POINTER(GSM_RFCarrierQuery,VI_ERROR_PARAMETER2)
	CHK_NULL_POINTER(GSM_RFInputRangeStateQuery,VI_ERROR_PARAMETER3)
	CHK_NULL_POINTER(GSMMaxTotalPowerQuery,VI_ERROR_PARAMETER4)
	CHK_NULL_POINTER(GSM_RFInputAttenuationQuery,VI_ERROR_PARAMETER5)
	CHK_NULL_POINTER(GSMInternalPreAmpStateQuery,VI_ERROR_PARAMETER6)
	
	// check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	//Retrieve GSM_RFCarrierQuery
	errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":POW:CARR?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    if(!strcmp(buffer, "SING\n"))
        *GSM_RFCarrierQuery = hpesa_INPUT_CARRIER_SINGLE;
    else if (!strcmp(buffer, "MULT\n"))
        *GSM_RFCarrierQuery = hpesa_INPUT_CARRIER_MULTIPLE;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    //Retrieve RF Input Range State
	errStatus = hpesa_cmdInt16_Q(instrumentHandle,":POW:RANG:AUTO?",GSM_RFInputRangeStateQuery);

	if (errStatus < VI_SUCCESS) return errStatus;

	//Retrieve Max Total Power
	errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":POW:RANG?", 
                                  GSMMaxTotalPowerQuery);

	if (errStatus < VI_SUCCESS) return errStatus;

	//Retrieve RF Input Attenuation
	errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":POW:ATT?", 
                                  GSM_RFInputAttenuationQuery);

	if (errStatus < VI_SUCCESS) return errStatus;

	//Retrieve GSM Internal Preamp State
	errStatus = hpesa_cmdInt16_Q(instrumentHandle,":POW:GAIN?",GSMInternalPreAmpStateQuery);

	if (errStatus < VI_SUCCESS) return errStatus;
	
	return errStatus;
}	

/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_InputGetConditions                      */
/*****************************************************************************/




/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_InputSetGainAtten                                              */
/*                                                                           */
/*      This method sets the gain and attenuation for base transmit and      */
/*      mobile testing stations.                                             */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 GSMMobileGain                                                 */
/*                                                                           */
/*      Sets equal to the external gain used when measuring mobile stations. */
/*                                                                           */
/*    ViReal64 GSMMobileAtten                                                */
/*                                                                           */
/*      Sets equal to the external attenuation used when measuring mobile    */
/*      stations.                                                            */
/*                                                                           */
/*    ViReal64 GSMBaseTransGain                                              */
/*                                                                           */
/*      Set equal to the external gain used when measuring base transmit     */
/*      stations.                                                            */
/*                                                                           */
/*    ViReal64 GSMBaseTransAtten                                             */
/*                                                                           */
/*      Sets equal to the external attenuation used when measuring base      */
/*      transmit stations.                                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_InputSetGainAtten
                       (ViSession instrumentHandle,
                        ViReal64 GSMMobileGain,
                        ViReal64 GSMMobileAtten,
                        ViReal64 GSMBaseTransGain,
                        ViReal64 GSMBaseTransAtten)
{

    ViStatus errStatus = VI_SUCCESS;
		struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Set Mobile Station Gain
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":CORR:MS:GAIN", 
                              GSMMobileGain);
    if(errStatus < VI_SUCCESS) return errStatus;

    // Set Mobile Station attenuation 
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":CORR:MS:LOSS", 
                              GSMMobileAtten);
    if(errStatus < VI_SUCCESS) return errStatus;

    // Set Base Transmit Station Gain
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":CORR:BTS:GAIN", 
                              GSMBaseTransGain);
    if(errStatus < VI_SUCCESS) return errStatus;

    // Set Base Transmit Station attenuation 
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":CORR:BTS:LOSS", 
                              GSMBaseTransAtten);
    if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_InputSetGainAtten                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_InputGetGainAtten                                              */
/*                                                                           */
/*      This method retrieves the current gain and attenuation settings for  */
/*      base transmit and mobile stations.                                   */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPReal64 GSMMobileGainQuery                                           */
/*                                                                           */
/*      Returns the current external gain for mobile stations.               */
/*                                                                           */
/*    ViPReal64 GSMMobileAttenQuery                                          */
/*                                                                           */
/*      Returns the current external attenuation for mobile stations.        */
/*                                                                           */
/*    ViPReal64 GSMBaseTransGainQuery                                        */
/*                                                                           */
/*      Returns the current gain for base transmit stations.                 */
/*                                                                           */
/*    ViPReal64 GSMBaseTransAttenQuery                                       */
/*                                                                           */
/*      Returns the current attenuation for base transmit stations.          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_InputGetGainAtten
                       (ViSession instrumentHandle,
                        ViPReal64 GSMMobileGainQuery,
                        ViPReal64 GSMMobileAttenQuery,
                        ViPReal64 GSMBaseTransGainQuery,
                        ViPReal64 GSMBaseTransAttenQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(GSMMobileGainQuery,    VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(GSMMobileAttenQuery,   VI_ERROR_PARAMETER3)
	CHK_NULL_POINTER(GSMBaseTransGainQuery, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(GSMBaseTransAttenQuery,VI_ERROR_PARAMETER5)
    
    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Get mobile station gain 
    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":CORR:MS:GAIN?", 
                                  GSMMobileGainQuery);
    if(errStatus < VI_SUCCESS) return errStatus;

    // Get Mobile station attenuation
    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":CORR:MS:LOSS?", 
                                  GSMMobileAttenQuery);
    if(errStatus < VI_SUCCESS) return errStatus;
	    
    // Get Base Station gain
	errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":CORR:BTS:GAIN?", 
                                  GSMBaseTransGainQuery);
    if(errStatus < VI_SUCCESS) return errStatus;
	
	// Get Base Station attenuation
	errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":CORR:BTS:LOSS?", 
                                  GSMBaseTransAttenQuery);
    if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_InputGetGainAtten                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TriggerSetExternal                                             */
/*                                                                           */
/*      This method sets the external trigger values for GSM measurements.   */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 GSMTrigExtDelay                                               */
/*                                                                           */
/*      Sets the trigger delay in seconds when using the rear panel external */
/*      trigger.                                                             */
/*                                                                           */
/*    ViInt16 GSMTrigExtSlope                                                */
/*                                                                           */
/*      Sets the trigger slope when using the rear panel external trigger    */
/*      input.                                                               */
/*                                                                           */
/*      hpesa_TRIG_SLOPE_POS - Sets the external trigger slope to positive.  */
/*      hpesa_TRIG_SLOPE_NEG - Sets the external trigger slope to negative.  */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TriggerSetExternal
                       (ViSession instrumentHandle,
                        ViReal64 GSMTrigExtDelay,
                        ViInt16 GSMTrigExtSlope)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(GSMTrigExtSlope, 0, hpesa_TRIG_SLOPE_LASTENUM, 
                                 VI_ERROR_PARAMETER3)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    // send the external delay trigger time
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":TRIG:EXT:DEL", 
                              GSMTrigExtDelay);
    if(errStatus < VI_SUCCESS) return errStatus;

    // Set the slope 
    switch(GSMTrigExtSlope)
    {
        case hpesa_TRIG_SLOPE_POS:
            sprintf(buffer, ":TRIG:EXT:SLOP POS");
            break;
        case hpesa_TRIG_SLOPE_NEG:
            sprintf(buffer, ":TRIG:EXT:SLOP NEG");
            break;
        default:
            fprintf(stderr, "Logic error in hpesa_GSM_TriggerSetExternal");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    // Send it
    errStatus = hpesa_cmd(instrumentHandle, buffer);

	if(errStatus <VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_TriggerSetExternal                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TriggerGetExternal                                             */
/*                                                                           */
/*      This method retrieves the current external trigger values for GSM    */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPReal64 GSMTrigExtDelayQuery                                         */
/*                                                                           */
/*      Retrieves the current delay in seconds for external triggering.      */
/*                                                                           */
/*    ViPInt16 GSMTrigExtSlopeQuery                                          */
/*                                                                           */
/*      Returns the current slope used with external triggering.             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TriggerGetExternal
                       (ViSession instrumentHandle,
                        ViPReal64 GSMTrigExtDelayQuery,
                        ViPInt16 GSMTrigExtSlopeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(GSMTrigExtDelayQuery, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(GSMTrigExtSlopeQuery, VI_ERROR_PARAMETER3)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Retrieve the external trigger delay
    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":TRIG:EXT:DEL?", 
                                  GSMTrigExtDelayQuery);
    if(errStatus<VI_SUCCESS) return errStatus;

    // Retrieve the external trigger slope
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":TRIG:EXT:SLOP?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    if(!strcmp(buffer, "POS\n"))
        *GSMTrigExtSlopeQuery = hpesa_TRIG_SLOPE_POS;
    else if (!strcmp(buffer, "NEG\n"))
        *GSMTrigExtSlopeQuery = hpesa_TRIG_SLOPE_NEG;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_TriggerGetExternal                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TriggerSetFrame                                                */
/*                                                                           */
/*      This method sets the frame trigger conditions for GSM measurements.  */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 GSMTrigFrameDelay                                             */
/*                                                                           */
/*      Sets trigger delay (in seconds) to be used in zero span measurements */
/*      to adjust the active burst within a mask. Use positive values to     */
/*      achieve trigger delay (that is, to measure later than the trigger    */
/*      source event) and use negative values to achieve pre-trigger (that   */
/*      is, to measure earlier than the trigger source event).               */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TriggerSetFrame
                       (ViSession instrumentHandle,
                        ViReal64 GSMTrigFrameDelay)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)
	    
    VERIFY_APP(hpesa_APPLICATION_GSM)

    // send the Trigger Frame delay
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":TRIG:FRAM:DEL", 
                              GSMTrigFrameDelay);
    if(errStatus < VI_SUCCESS) return errStatus;


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_TriggerSetFrame                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TriggerGetFrame                                                */
/*                                                                           */
/*      This method retrieves the current setting for GSM frame triggering.  */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPReal64 GSMTrigFrameDelayQuery                                       */
/*                                                                           */
/*      Returns the current frame delay in seconds.                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TriggerGetFrame
                       (ViSession instrumentHandle,
                        ViPReal64 GSMTrigFrameDelayQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(GSMTrigFrameDelayQuery, VI_ERROR_PARAMETER2)
    
    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Retrieve the external trigger delay
    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":TRIG:FRAM:DEL?", 
                                  GSMTrigFrameDelayQuery);
    if(errStatus<VI_SUCCESS) return errStatus;


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_TriggerGetFrame                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TriggerSetRFBurst                                              */
/*                                                                           */
/*      This method sets up RF burst triggering for GSM measurements.        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 GSMTrigRFBurstDelay                                           */
/*                                                                           */
/*      Sets the trigger delay when using the RF burst (wideband) trigger.   */
/*                                                                           */
/*    ViReal64 GSMTrigRFBurstLevel                                           */
/*                                                                           */
/*      Sets the trigger level when using the RF burst (wideband) trigger.   */
/*                                                                           */
/*    ViInt16 GSMTrigRFBurstSlope                                            */
/*                                                                           */
/*      Sets the trigger slope when using the RF Burst (wideband) Trigger.   */
/*                                                                           */
/*      hpesa_TRIG_SLOPE_POS - Sets the RF Burst trigger slope to positive.  */
/*      hpesa_TRIG_SLOPE_NEG - Sets the RF Burst trigger slope to negative.  */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TriggerSetRFBurst
                       (ViSession instrumentHandle,
                        ViReal64 GSMTrigRFBurstDelay,
                        ViReal64 GSMTrigRFBurstLevel,
                        ViInt16 GSMTrigRFBurstSlope)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(GSMTrigRFBurstSlope, 0, hpesa_TRIG_SLOPE_LASTENUM, 
                                           VI_ERROR_PARAMETER4)
	VERIFY_APP(hpesa_APPLICATION_GSM)

    // send the rfburst delay trigger time
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":TRIG:RFB:DEL", 
                              GSMTrigRFBurstDelay);
    if(errStatus < VI_SUCCESS) return errStatus;

    // send the rfburst trigger level 
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":TRIG:RFB:LEV", 
                              GSMTrigRFBurstLevel);
    if(errStatus < VI_SUCCESS) return errStatus;
	 

    switch(GSMTrigRFBurstSlope)
    {
        case hpesa_TRIG_SLOPE_POS:
            sprintf(buffer, ":TRIG:RFB:SLOP POS");
            break;
        case hpesa_TRIG_SLOPE_NEG:
            sprintf(buffer, ":TRIG:RFB:SLOP NEG");
            break;
        default:
            fprintf(stderr, "Logic error in hpesa_GSM_TriggerSetExternal");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    // Send it
    errStatus = hpesa_cmd(instrumentHandle, buffer);

	if(errStatus < VI_SUCCESS) return errStatus;
	
    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_TriggerSetRFBurst                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TriggerGetRFBurst                                              */
/*                                                                           */
/*      This method retrieves the current RF Burst trigger settings for GSM  */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPReal64 GSMTrigRFBurstDelayQuery                                     */
/*                                                                           */
/*      Returns the current RF Burst trigger delay.                          */
/*                                                                           */
/*    ViPReal64 GSMTrigRFBurstLevelQuery                                     */
/*                                                                           */
/*      Returns the current RB Burst trigger level.                          */
/*                                                                           */
/*    ViPInt16 GSMTrigRFBurstSlopeQuery                                      */
/*                                                                           */
/*      Returns the current RF Burst trigger slope.                          */
/*                                                                           */
/*      0 = hpesa_TRIG_SLOPE_POS                                             */
/*      1 = hpesa_TRIG_SLOPE_NEG                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TriggerGetRFBurst
                       (ViSession instrumentHandle,
                        ViPReal64 GSMTrigRFBurstDelayQuery,
                        ViPReal64 GSMTrigRFBurstLevelQuery,
                        ViPInt16 GSMTrigRFBurstSlopeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

	//Check Parameters
	CHK_NULL_POINTER(GSMTrigRFBurstDelayQuery, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(GSMTrigRFBurstLevelQuery, VI_ERROR_PARAMETER3)
	CHK_NULL_POINTER(GSMTrigRFBurstSlopeQuery, VI_ERROR_PARAMETER4)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Retrieve the trigger RF Burst delay
    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":TRIG:RFB:DEL?", 
                                  GSMTrigRFBurstDelayQuery);
    if(errStatus<VI_SUCCESS) return errStatus;

    // Retrieve the trigger RF Burst level
    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":TRIG:RFB:LEV?", 
                                  GSMTrigRFBurstLevelQuery);
    if(errStatus<VI_SUCCESS) return errStatus;


	
	// Retrieve the  trigger RF Burst slop
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":TRIG:RFB:SLOP?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    if(!strcmp(buffer, "POS\n"))
        *GSMTrigRFBurstSlopeQuery = hpesa_TRIG_SLOPE_POS;
    else if (!strcmp(buffer, "NEG\n"))
        *GSMTrigRFBurstSlopeQuery = hpesa_TRIG_SLOPE_NEG;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_TriggerGetRFBurst                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_DemodSetBurstAlign                                             */
/*                                                                           */
/*      This method sets the demod burst alignment options for GSM           */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSMDemodBurstAlign                                             */
/*                                                                           */
/*      Selects the sync alignment to be either to the GSM standard or the   */
/*      standard offset by 1/2 bit.                                          */
/*                                                                           */
/*      hpesa_GSM_BURST_ALIGN_GSM - burst alignment as defined in the GSM    */
/*      standard.                                                            */
/*      hpesa_GSM_BURST_ALIGN_HALF - burst alignment is advanced by1/2 bit,  */
/*      which corresponds to an earlier interpretation of the GSM standard.  */
/*                                                                           */
/*    ViReal64 GSMDemodRFSyncDelay                                           */
/*                                                                           */
/*      Sets the delay for the RF amplitude sync in seconds.                 */
/*                                                                           */
/*    ViReal64 GSMDemodSearchThresh                                          */
/*                                                                           */
/*      Sets the power threshold (in dB), relative to the peak power, that   */
/*      is used to determine the burst rising edge and falling edge.         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_DemodSetBurstAlign
                       (ViSession instrumentHandle,
                        ViInt16 GSMDemodBurstAlign,
                        ViReal64 GSMDemodRFSyncDelay,
                        ViReal64 GSMDemodSearchThresh)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(GSMDemodBurstAlign, 0, hpesa_GSM_BURST_ALIGN_LASTENUM, 
                                           VI_ERROR_PARAMETER2)
	VERIFY_APP(hpesa_APPLICATION_GSM)

    //Set Demod Burst Align
	switch(GSMDemodBurstAlign)
    {
        case hpesa_GSM_BURST_ALIGN_GSM:
            sprintf(buffer, ":SYNC:ALIG GSM");
            break;
        case hpesa_GSM_BURST_ALIGN_HALF:
            sprintf(buffer, ":SYNC:ALIG HALF");
            break;
        default:
            fprintf(stderr, "Logic error in hpesa_GSM_DemodSetBurstAlign");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    // Send it
    errStatus = hpesa_cmd(instrumentHandle, buffer);

	if(errStatus < VI_SUCCESS) return errStatus;

	// send the RF Sync Delay
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":SYNC:BURS:RFAM:DEL", 
                              GSMDemodRFSyncDelay);
    if(errStatus < VI_SUCCESS) return errStatus;

    // send the Demod Search Threshold 
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":SYNC:BURS:STHR", 
                              GSMDemodSearchThresh);
    if(errStatus < VI_SUCCESS) return errStatus;
	 
    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_DemodSetBurstAlign                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_DemodGetBurstAlign                                             */
/*                                                                           */
/*      This method retrieves the current burst alignment setting for GSM    */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSMDemodBurstAlignQuery                                       */
/*                                                                           */
/*      Returns the current sync alignment standard.                         */
/*                                                                           */
/*      0 = hpesa_GSM_BURST_ALIGN_GSM                                        */
/*      1 = hpesa_GSM_BURST_ALIGN_HALF                                       */
/*                                                                           */
/*    ViPReal64 GSMDemodRFSyncDelayQuery                                     */
/*                                                                           */
/*      Returns the current delay for the RF amplitude sync.                 */
/*                                                                           */
/*    ViPReal64 GSMDemodSearchThreshQuery                                    */
/*                                                                           */
/*      Returns the current power threshold, relative to the peak power,     */
/*      that is used to determine the burst rising edge and falling edge.    */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_DemodGetBurstAlign
                       (ViSession instrumentHandle,
                        ViPInt16 GSMDemodBurstAlignQuery,
                        ViPReal64 GSMDemodRFSyncDelayQuery,
                        ViPReal64 GSMDemodSearchThreshQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

	//Check Parameters
	CHK_NULL_POINTER(GSMDemodBurstAlignQuery,  VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(GSMDemodRFSyncDelayQuery, VI_ERROR_PARAMETER3)
	CHK_NULL_POINTER(GSMDemodSearchThreshQuery,VI_ERROR_PARAMETER4)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Retrieve the Demod Burst Align
	errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":SYNC:ALIG?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    if(!strcmp(buffer, "GSM\n"))
        *GSMDemodBurstAlignQuery = hpesa_GSM_BURST_ALIGN_GSM;
    else if (!strcmp(buffer, "HALF\n"))
        *GSMDemodBurstAlignQuery = hpesa_GSM_BURST_ALIGN_HALF;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }
	   
    // Retrieve the Demod RF Sync delay
    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":SYNC:BURS:RFAM:DEL?", 
                                  GSMDemodRFSyncDelayQuery);
    if(errStatus<VI_SUCCESS) return errStatus;
	
	// Retrieve the Demod Burst Search Threshold
	errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":SYNC:BURS:STHR?", 
                                  GSMDemodSearchThreshQuery);
    if(errStatus<VI_SUCCESS) return errStatus;
    
    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_DemodGetBurstAlign                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_DemodSetReferenceOsc                                           */
/*                                                                           */
/*      This method sets the demod optional reference setup for GSM          */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSMOptFreqRefSource                                            */
/*                                                                           */
/*      Selects the reference oscillator (time base) source.                 */
/*                                                                           */
/*      hpesa_GSM_DEMOD_FREQ_SOURCE_INTERNAL - uses internal 10 MHz          */
/*      reference signal.                                                    */
/*      hpesa_GSM_DEMOD_FREQ_SOURCE_EXTERNAL - uses the signal at the rear   */
/*      panel external reference input port.                                 */
/*                                                                           */
/*    ViReal64 GSMOptFreqReference                                           */
/*                                                                           */
/*      Set to the frequency of the external reference signal being supplied */
/*      to the instruments 10MHZ REF IN input BNC connector. If the         */
/*      external frequency reference signal is not 10MHz, the following      */
/*      procedure must be followed:                                          */
/*                                                                           */
/*      Connect the external reference signal to the DDRF board EXT REF      */
/*      IN input BNC connector.                                              */
/*                                                                           */
/*      Connect the DDRF board EXT 10MHZ OUT output BNC to the SA            */
/*      base box 10MHZ REF IN input BNC connector.                           */
/*                                                                           */
/*      Enter the external reference signal frequency value as the Opt Freq  */
/*      Ref parameter.                                                       */
/*                                                                           */
/*      Set Opt Freq Ref = External                                          */
/*                                                                           */
/*      The DDRF Option B7E reference PLL circuit will attempt to lock to    */
/*      the external reference signal and if successful will produce a phase */
/*      locked 10MHz reference on the DDRF board EXT 10MHZ OUT output BNC,   */
/*      which in turn will drive the base box 10MHZ REF IN.                  */
/*                                                                           */
/*    ViBoolean GSMOpt10MHZOut                                               */
/*                                                                           */
/*      Turn on and off the external reference signal going to the rear      */
/*      panel.                                                               */
/*                                                                           */
/*      VI_TRUE - Turns on external reference signal.                        */
/*      VI_FALSE - Turns off external reference signal.                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_DemodSetReferenceOsc
                       (ViSession instrumentHandle,
                        ViInt16 GSMOptFreqRefSource,
                        ViReal64 GSMOptFreqReference,
                        ViBoolean GSMOpt10MHZOut)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(GSMOptFreqRefSource, 0, hpesa_GSM_OSC_SOURCE_LASTENUM, 
                                           VI_ERROR_PARAMETER2)

	CHK_BOOLEAN(GSMOpt10MHZOut, VI_ERROR_PARAMETER4)

	VERIFY_APP(hpesa_APPLICATION_GSM)

    //Set Opt Freq Ref Source
	switch(GSMOptFreqRefSource)
    {
        case hpesa_GSM_OSC_SOURCE_INTERNAL:
            sprintf(buffer, ":ROSC:SOUR INT");
            break;
        case hpesa_GSM_OSC_SOURCE_EXTERNAL:
            sprintf(buffer, ":ROSC:SOUR EXT");
            break;
        default:
            fprintf(stderr, "Logic error in hpesa_GSM_DemodSetReferenceOsc");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    // Send it
    errStatus = hpesa_cmd(instrumentHandle, buffer);

	if(errStatus <VI_SUCCESS) return errStatus;

	// send Opt Freq Reference
    errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":ROSC:EXT:FREQ", 
                              GSMOptFreqReference);
    if(errStatus < VI_SUCCESS) return errStatus;

	//Set Opt 10MHz Out if Freq Ref Source = EXT
	if(GSMOptFreqRefSource == hpesa_GSM_OSC_SOURCE_EXTERNAL)
	{
		errStatus = hpesa_cmdInt(instrumentHandle,":ROSC:OUTP",GSMOpt10MHZOut);
	 	if(errStatus < VI_SUCCESS) return errStatus;
	}
    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_DemodSetReferenceOsc                    */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_DemodGetReferenceOsc                                           */
/*                                                                           */
/*      This method retrieves the current demod option reference setup for   */
/*      GSM measurements.                                                    */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSMOptFreqRefSourceQuery                                      */
/*                                                                           */
/*      Returns the current reference oscillator (time base) source.         */
/*                                                                           */
/*      0 = hpesa_GSM_DEMOD_FREQ_SOURCE_INTERNAL                             */
/*      1 = hpesa_GSM_DEMOD_FREQ_SOURCE_EXTERNAL                             */
/*                                                                           */
/*    ViPReal64 GSMOptFreqReferenceQuery                                     */
/*                                                                           */
/*      Returns the current frequency of the external reference signal being */
/*      supplied to the instruments 10MHZ REF IN input BNC connector.       */
/*                                                                           */
/*    ViPBoolean GSMOpt10MHZOutQuery                                         */
/*                                                                           */
/*      Returns the current state of the external reference signal going to  */
/*      the rear panel.                                                      */
/*                                                                           */
/*      0 = VI_FALSE                                                         */
/*      1 = VI_TRUE                                                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_DemodGetReferenceOsc
                       (ViSession instrumentHandle,
                        ViPInt16 GSMOptFreqRefSourceQuery,
                        ViPReal64 GSMOptFreqReferenceQuery,
                        ViPBoolean GSMOpt10MHZOutQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

	//Check Parameters
	CHK_NULL_POINTER(GSMOptFreqRefSourceQuery,  VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(GSMOptFreqReferenceQuery, VI_ERROR_PARAMETER3)
	CHK_NULL_POINTER(GSMOpt10MHZOutQuery,VI_ERROR_PARAMETER4)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Retrieve the Opt Freq Ref Source Query
	errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":ROSC:SOUR?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    if(!strcmp(buffer, "INT\n"))
        *GSMOptFreqRefSourceQuery = hpesa_GSM_OSC_SOURCE_INTERNAL;
    else if (!strcmp(buffer, "EXT\n"))
        *GSMOptFreqRefSourceQuery = hpesa_GSM_OSC_SOURCE_EXTERNAL;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }
	   
    // Retrieve Frequency Reference
    errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":ROSC:EXT:FREQ?", 
                                  GSMOptFreqReferenceQuery);
    if(errStatus<VI_SUCCESS) return errStatus;
	
	// Retrieve Opt 10MHz Out 
	errStatus = hpesa_cmdInt16_Q(instrumentHandle,":ROSC:OUTP?",GSMOpt10MHZOutQuery);
	if (errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_GSM_DemodGetReferenceOsc                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_SetARFCN                                                       */
/*                                                                           */
/*      This method sets the Absolute RF Channel Number for GSM measurements.*/
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_ARFCN                                                      */
/*                                                                           */
/*      Set the analyzer to a frequency that corresponds to the ARFCN        */
/*      (Absolute RF Channel Number).                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_SetARFCN
                       (ViSession instrumentHandle,
                        ViInt32 GSM_ARFCN)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = hpesa_cmdInt(instrumentHandle, 
                              ":CHAN:ARFC", 
                                GSM_ARFCN);
	if(errStatus <VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                           end hpesa_GSM_SetARFCN                          */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_GetARFCN                                                       */
/*                                                                           */
/*      This method retrieves the current ARFCN for GSM measurements.        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt32 GSM_ARFCNQuery                                                */
/*                                                                           */
/*      Returns the current absolute RF channel number.                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_GetARFCN
                       (ViSession instrumentHandle,
                        ViPInt32 GSM_ARFCNQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_NULL_POINTER(GSM_ARFCNQuery,VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = hpesa_cmdInt32_Q(instrumentHandle, 
                                  ":CHAN:ARFC?", 
                                  GSM_ARFCNQuery);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                           end hpesa_GSM_GetARFCN                          */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_SetTSC                                                         */
/*                                                                           */
/*      This method sets up the training sequence code for GSM measurements. */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_TSCAuto                                                    */
/*                                                                           */
/*      Select auto or manual control for slot searching. The feature is     */
/*      only supported in external and frame trigger source modes. In        */
/*      external trigger mode when timeslot is set on, the demodulation      */
/*      measurement is made on the nth timeslot specified by the external    */
/*      trigger point + n timeslots, where n is the selected timeslot value  */
/*      0 to 7. In frame trigger mode when timeslot is set on, then          */
/*      demodulation measurement is only made on the nth timeslot specified  */
/*      by bit 0 of frame reference burst + n timeslots, where n is the      */
/*      selected timeslot value 0 to 7 and where the frame reference burst   */
/*      is specified by Ref Burst and Ref TSC (Std) combination.             */
/*                                                                           */
/*      hpesa_TSC_AUTO - Automatically sets the training sequence code.      */
/*      hpesa_TSC_MANUAL - Manually sets the training sequence code.         */
/*                                                                           */
/*    ViInt32 GSM_TSC                                                        */
/*                                                                           */
/*      Set the training sequence code to search for, with normal burst      */
/*      selected and TSC auto set to off.                                    */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_SetTSC
                       (ViSession instrumentHandle,
                        ViInt16 GSM_TSCAuto,
                        ViInt32 GSM_TSC)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(GSM_TSCAuto, 0, hpesa_TSC_LASTENUM,VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    switch(GSM_TSCAuto)
    {
        case hpesa_TSC_AUTO:
            sprintf(buffer, ":CHAN:TSC:AUTO ON");
            break;
        case hpesa_TSC_MANUAL:
            sprintf(buffer, ":CHAN:TSC:AUTO OFF");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_SetTSC");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

	errStatus = hpesa_cmd(instrumentHandle, buffer);

	if(errStatus <VI_SUCCESS) return errStatus;

	//Set GSM_TSC if TSCAuto is Manual
	if(GSM_TSCAuto == hpesa_TSC_MANUAL)
	{
		errStatus = hpesa_cmdInt(instrumentHandle, 
                              ":CHAN:TSC", 
							   GSM_TSC);
	}
	if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                            end hpesa_GSM_SetTSC                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_GetTSC                                                         */
/*                                                                           */
/*      This method retrieves the current training sequence code settins for */
/*      GSM measurements.                                                    */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSM_TSCAutoQuery                                              */
/*                                                                           */
/*      Returns the current training sequence code state.                    */
/*                                                                           */
/*      0 = hpesa_TSC_AUTO                                                   */
/*      1 = hpesa_TSC_MANUAL                                                 */
/*                                                                           */
/*    ViPInt32 GSM_TSCQuery                                                  */
/*                                                                           */
/*      Returns the current training sequence code.                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_GetTSC
                       (ViSession instrumentHandle,
                        ViPInt16 GSM_TSCAutoQuery,
                        ViPInt32 GSM_TSCQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(GSM_TSCAutoQuery, VI_ERROR_PARAMETER2)
	CHK_NULL_POINTER(GSM_TSCQuery,VI_ERROR_PARAMETER3)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Retrieve TSCAuto
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":CHAN:TSC:AUTO?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0';  // strip the trailing \n

    if(!strcmp(buffer, "1"))
        *GSM_TSCAutoQuery = hpesa_TSC_AUTO;
    else if (!strcmp(buffer, "0"))
        *GSM_TSCAutoQuery = hpesa_TSC_MANUAL;
	else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

	//Retrieve TSC
	errStatus = hpesa_cmdInt32_Q(instrumentHandle, 
                                  ":CHAN:TSC?", 
                                  GSM_TSCQuery);

	if(errStatus < VI_SUCCESS) return errStatus;
    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                           end hpesa_GSM_GetTSC                            */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TXPConfigure                                                   */
/*                                                                           */
/*      This method sets up the instrument for transmit power (TXP)          */
/*      measurements using the factory default instrument settings and stops */
/*      the current measurement. It does not initiate the taking of          */
/*      measurement data.                                                    */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TXPConfigure
                       (ViSession instrumentHandle)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = hpesa_cmd(instrumentHandle, ":CONF:TXP");

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_GSM_TXPConfigure                         */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TXPMeasure                                                     */
/*                                                                           */
/*      This method measures the power in the channel. It compares the       */
/*      average power of the RF signal burst to a specified threshold value. */
/*                                                                           */
/*      The user can select one of three types of measurement modes:         */
/*      Measure, Read, or Fetch.                                             */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 GSM_TXPMeasureTimeout                                         */
/*                                                                           */
/*      This value temporarily changes the VISA timeout setting for the      */
/*      duration of the instrument measurement. The user needs to set this   */
/*      value to an appropriate time that will be longer then the expected   */
/*      measurement time. Units are in seconds.                              */
/*                                                                           */
/*    ViInt16 GSM_TXPMeasureType                                             */
/*                                                                           */
/*      Selects measurement type. Note that for hpesa_FETCH type the         */
/*      instrument should already be in this measurement mode else the       */
/*      function will time out. User can select this measurement mode by     */
/*      first using the "MEASURE" or "READ" types or call the                */
/*      hpesa_GSM_TXPConfigure function.                                     */
/*                                                                           */
/*      hpesa_MEASURE - Stops current measurement, changes to this selected  */
/*      measurement, sets up instrument using factory defaults, makes        */
/*      measurement, returns measurement results.                            */
/*                                                                           */
/*      hpesa_READ - Stops current measurement,  changes to this selected    */
/*      measurement, uses instrument settings from last measurement of this  */
/*      type, makes measurement, returns measurements results.               */
/*                                                                           */
/*      hpesa_FETCH - Returns measurements results only. No new measurement  */
/*      is initiated.                                                        */
/*                                                                           */
/*    ViPReal64 GSM_TXPSampleTimeQ                                           */
/*                                                                           */
/*      Returns a floating point number representing the time between        */
/*      samples when using the trace queries (n=0, 2, et cetera).            */
/*                                                                           */
/*    ViPReal64 GSM_TXPMeanPowerQ                                            */
/*                                                                           */
/*      Returns the mean power (in dBm) of the power above the threshold     */
/*      value. If averaging is on, the power is for the latest acquisition.  */
/*                                                                           */
/*    ViPReal64 GSM_TXPAvgThreshPowerQ                                       */
/*                                                                           */
/*      Returns the threshold power (in dBm) for N averages, if averaging is */
/*      on. An average consists of N acquisitions of data which represents   */
/*      the current trace. If averaging is off, the value of power averaged  */
/*      is the same as the power value.                                      */
/*                                                                           */
/*    ViPReal64 GSM_TXPSampleCountQ                                          */
/*                                                                           */
/*      Returns the number of data points in the captured signal.            */
/*      This number is useful when performing a query on the signal.         */
/*                                                                           */
/*    ViPReal64 GSM_TXPThreshValueQ                                          */
/*                                                                           */
/*      Returns the threshold (in dBm) above which the power is              */
/*      calculated.                                                          */
/*                                                                           */
/*    ViPReal64 GSM_TXPThreshPointsQ                                         */
/*                                                                           */
/*      Returns the number of points that were above the threshold and were  */
/*      used for the power calculation.                                      */
/*                                                                           */
/*    ViPReal64 GSM_TXPMaxDataValueQ                                         */
/*                                                                           */
/*      Returns the maximum of the most recently acquired data (in           */
/*      dBm).                                                                */
/*                                                                           */
/*    ViPReal64 GSM_TXPMinDataValue                                          */
/*                                                                           */
/*      Returns the minimum of the most recently acquired data (in           */
/*      dBm).                                                                */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TXPMeasure
                       (ViSession instrumentHandle,
                        ViReal64 GSM_TXPMeasureTimeout,
                        ViInt16 GSM_TXPMeasureType,
                        ViPReal64 GSM_TXPSampleTimeQ,
                        ViPReal64 GSM_TXPMeanPowerQ,
                        ViPReal64 GSM_TXPAvgThreshPowerQ,
                        ViPReal64 GSM_TXPSampleCountQ,
                        ViPReal64 GSM_TXPThreshValueQ,
                        ViPReal64 GSM_TXPThreshPointsQ,
                        ViPReal64 GSM_TXPMaxDataValueQ,
                        ViPReal64 GSM_TXPMinDataValueQ)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    ViReal64 MeasData[10];
    ViInt32 temp = 0;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_ENUM(GSM_TXPMeasureType, 0, hpesa_MEASURE_METHOD_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(GSM_TXPSampleTimeQ, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(GSM_TXPMeanPowerQ, VI_ERROR_PARAMETER5)
    CHK_NULL_POINTER(GSM_TXPAvgThreshPowerQ, VI_ERROR_PARAMETER6)
    CHK_NULL_POINTER(GSM_TXPSampleCountQ, VI_ERROR_PARAMETER7)
    CHK_NULL_POINTER(GSM_TXPThreshValueQ, VI_ERROR_PARAMETER8)
    CHK_NULL_POINTER(GSM_TXPThreshPointsQ, hpesa_INSTR_ERROR_PARAMETER9)
    CHK_NULL_POINTER(GSM_TXPMaxDataValueQ, hpesa_INSTR_ERROR_PARAMETER10)
	CHK_NULL_POINTER(GSM_TXPMinDataValueQ, hpesa_INSTR_ERROR_PARAMETER10)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = GenMeasureTrace(instrumentHandle,
                               hpesa_APPLICATION_MODE_TXP,
                               GSM_TXPMeasureTimeout,
                               GSM_TXPMeasureType,
                               hpesa_RESULTS_TYPE_1,
                               MeasData,
                               10,
                               &temp);
    if(errStatus < VI_SUCCESS) return errStatus;
	
	if(temp == 8)
    {
        *GSM_TXPSampleTimeQ     = MeasData[0];
        *GSM_TXPMeanPowerQ      = MeasData[1];
        *GSM_TXPAvgThreshPowerQ = MeasData[2];
        *GSM_TXPSampleCountQ     = MeasData[3];
        *GSM_TXPThreshValueQ    = MeasData[4];
        *GSM_TXPThreshPointsQ   = MeasData[5];
        *GSM_TXPMaxDataValueQ   = MeasData[6];
		*GSM_TXPMinDataValueQ   = MeasData[7];
	      
        errStatus = VI_SUCCESS;
    }
    else
	      errStatus = hpesa_INSTR_ERROR_UNEXPECTED;
		
    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                          end hpesa_GSM_TXPMeasure                         */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TXPMeasureTrace                                                */
/*                                                                           */
/*      This method measures the power in the channel. It compares the       */
/*      average power of the RF signal burst to a specified threshold value. */
/*                                                                           */
/*      User can select one of three types of measurement modes: Measure,    */
/*      Read, or Fetch.                                                      */
/*                                                                           */
/*                                                                           */
/*      This method returns the TXP measurement results specified by the     */
/*      "GSM_TXPResultsType" parameter as a real array.                      */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 GSM_TXPMeasureTraceTimeout                                    */
/*                                                                           */
/*      This value temporarily changes the VISA timeout setting for the      */
/*      duration of the instrument measurement. The user needs to set this   */
/*      value to an appropriate time that will be longer then the expected   */
/*      measurement time. Units are in seconds.                              */
/*                                                                           */
/*    ViInt16 GSM_TXPMeasureTraceType                                        */
/*                                                                           */
/*      Selects measurement type. Note that for hpesa_FETCH type the         */
/*      instrument should already be in this measurement mode else the       */
/*      function will time out. User can select this measurement mode by     */
/*      first using the "MEASURE" or "READ" types or call the                */
/*      hpesa_GSM_TXPConfigure function.                                     */
/*                                                                           */
/*      hpesa_MEASURE - Stops current measurement, changes to this selected  */
/*      measurement, sets up instrument using factory defaults, makes        */
/*      measurement, returns measurement results.                            */
/*                                                                           */
/*      hpesa_READ - Stops current measurement,  changes to this selected    */
/*      measurement, uses instrument settings from last measurement of this  */
/*      type, makes measurement, returns measurements results.               */
/*                                                                           */
/*      hpesa_FETCH - Returns measurements results only. No new measurement  */
/*      is initiated.                                                        */
/*                                                                           */
/*    ViInt16 GSM_TXPResultsType                                             */
/*                                                                           */
/*      Determines the format of the data returned in GSM_TXPDataResults.    */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_0: Not supported by instrument.                   */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_1: Returns the following scalar results:          */
/*      1. Sample time is a floating point number representing the time      */
/*      between samples when using the trace queries (n=0, 2, et cetera).    */
/*      2. Power is the mean power (in dBm) of the power above the threshold */
/*      value. If averaging is on, the power is for the latest acquisition.  */
/*      3. Power averaged is the threshold power (in dBm) for N averages, if */
/*      averaging is on. An average consists of N acquisitions of data which */
/*      represents the current trace. If averaging is off, the value of      */
/*      power averaged is the same as the power value.                       */
/*      4. Number of samples is the number of data points in the captured    */
/*      signal. This number is useful when performing a query on the signal  */
/*      (that is when n=0, 2, et cetera).                                    */
/*      5. Threshold value is the threshold (in dBm) above which the power   */
/*      is calculated.                                                       */
/*      6. Threshold points is the number of points that were above the      */
/*      threshold and were used for the power calculation.                   */
/*      7. Maximum value is the maximum of the most recently acquired data   */
/*      (in dBm).                                                            */
/*      8. Minimum value is the minimum of the most recently acquired data   */
/*      (in dBm).                                                            */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_2: Returns the RF Envelope Trace (data array).    */
/*      This array contains 401 points of data.                              */
/*                                                                           */
/*    ViAReal64 GSM_TXPDataResults                                           */
/*                                                                           */
/*      Trace data returned by measurement, formatted according to           */
/*      GSM_TXPResultsType.                                                  */
/*                                                                           */
/*    ViInt32 GSM_TXPDataResultsMaxSize                                      */
/*                                                                           */
/*      Specifies the maximum size of GSM_TXPDataResults array.              */
/*                                                                           */
/*    ViPInt32 GSM_TXPDataResultsSize                                        */
/*                                                                           */
/*      Returns the actual size of GSM_TXPDataResults array.                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TXPMeasureTrace
                       (ViSession instrumentHandle,
                        ViReal64 GSM_TXPMeasureTraceTimeout,
                        ViInt16 GSM_TXPMeasureTraceType,
                        ViInt16 GSM_TXPResultsType,
                        ViAReal64 GSM_TXPDataResults,
                        ViInt32 GSM_TXPDataResultsMaxSize,
                        ViPInt32 GSM_TXPDataResultsSize)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    int TXPValidResults[7] = {0,1,1,0,0,0,0};
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_ENUM(GSM_TXPMeasureTraceType, 0, hpesa_MEASURE_METHOD_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)
    CHK_ENUM(GSM_TXPResultsType, 0, hpesa_RESULTS_TYPE_LASTENUM,
                                                        VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(GSM_TXPDataResults, VI_ERROR_PARAMETER5)
    CHK_NULL_POINTER(GSM_TXPDataResultsSize, VI_ERROR_PARAMETER7)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    if((GSM_TXPResultsType > 6) || (TXPValidResults[GSM_TXPResultsType] == 0))
        return hpesa_INSTR_ERROR_INVALID_RESULTS_TYPE;

    errStatus = GenMeasureTrace(instrumentHandle,
                               hpesa_APPLICATION_MODE_TXP,
                               GSM_TXPMeasureTraceTimeout,
                               GSM_TXPMeasureTraceType,
                               GSM_TXPResultsType,
                               GSM_TXPDataResults,
                               GSM_TXPDataResultsMaxSize,
                               GSM_TXPDataResultsSize);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_TXPMeasureTrace                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TXPSetAveraging                                                */
/*                                                                           */
/*      This method sets the averaging for GSM transmit power (TXP)          */
/*      measurements.  User can control the number of averages, turn off or  */
/*      on averaging, set the terminal control mode for averaging, and set   */
/*      the average type.                                                    */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_TXPAverageCount                                            */
/*                                                                           */
/*      Set the number of bursts that will be averaged. After the specified  */
/*      number of bursts (average counts), the averaging mode (terminal      */
/*      control) setting determines the averaging action.                    */
/*                                                                           */
/*    ViBoolean GSM_TXPAverageState                                          */
/*                                                                           */
/*      Sets the state of averaging, either on or off.                       */
/*                                                                           */
/*      VI_TRUE = Averaging on.                                              */
/*      VI_FALSE = Averaging off.                                            */
/*                                                                           */
/*    ViInt16 GSM_TXPAverageMode                                             */
/*                                                                           */
/*      Select the type of termination control used for the averaging        */
/*      function.  This determines the averaging action after the specified  */
/*      number of frames (average count) is reached.                         */
/*                                                                           */
/*      hpesa_AVERAGE_EXPONENTIAL - Each successive data acquisition after   */
/*      the average count is reached, is exponentially weighted and combined */
/*      with the existing average.                                           */
/*                                                                           */
/*      hpesa_AVERAGE_REPEAT - After reaching the average count, the         */
/*      averaging is reset and a new average is started.                     */
/*                                                                           */
/*    ViInt16 GSM_TXPAverageType                                             */
/*                                                                           */
/*      Select the type of averaging to be performed.                        */
/*                                                                           */
/*      hpesa_AVERAGE_LPOWER - logarithmically averages the power of the     */
/*      video data.                                                          */
/*      hpesa_AVERAGE_POWER  - averages the linear power of successive       */
/*      measurements.                                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TXPSetAveraging
                       (ViSession instrumentHandle,
                        ViInt32 GSM_TXPAverageCount,
                        ViBoolean GSM_TXPAverageState,
                        ViInt16 GSM_TXPAverageMode,
                        ViInt16 GSM_TXPAverageType)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[100] = "\0";

	GET_GLOBALS(instrumentHandle, thisPtr)
	
    // check the input parameters
    CHK_BOOLEAN(GSM_TXPAverageState, VI_ERROR_PARAMETER3)
    CHK_ENUM(GSM_TXPAverageMode,0,hpesa_AVERAGE_MODE_LASTENUM,
												VI_ERROR_PARAMETER4)
	CHK_ENUM(GSM_TXPAverageType, 0, hpesa_AVERAGE_TYPE_LASTENUM,
												VI_ERROR_PARAMETER5)
	

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	//Call GenSetAveraging
	errStatus = GenSetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_TXP,
                                GSM_TXPAverageCount,
                                GSM_TXPAverageState,
                                GSM_TXPAverageMode);
 	//Set AverageType
	switch(GSM_TXPAverageType)
    {
        case hpesa_AVERAGE_LPOWER:
            sprintf(buffer, ":TXP:AVER:TYPE LPOW");
            break;
		case hpesa_AVERAGE_POWER:
            sprintf(buffer, ":TXP:AVER:TYPE POW");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_TXPSetAveraging");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, buffer);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_TXPSetAveraging                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TXPGetAveraging                                                */
/*                                                                           */
/*      This method retrieves the average settings for GSM tranmit power     */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt32 GSM_TXPAverageCountQuery                                      */
/*                                                                           */
/*      Returns the current average count.                                   */
/*                                                                           */
/*    ViPBoolean GSM_TXPAverageStateQuery                                    */
/*                                                                           */
/*      Returns the current average state.                                   */
/*                                                                           */
/*      0 = VI_FALSE                                                         */
/*      1 = VI_TRUE                                                          */
/*                                                                           */
/*    ViPInt16 GSM_TXPAverageModeQuery                                       */
/*                                                                           */
/*      Returns the current average mode.                                    */
/*                                                                           */
/*      0 = hpesa_AVERAGE_EXPONENTIAL                                        */
/*      1 = hpesa_AVERAGE_REPEAT                                             */
/*                                                                           */
/*    ViPInt16 GSM_TXPAverageTypeQuery                                       */
/*                                                                           */
/*      Returns the current average type.                                    */
/*                                                                           */
/*      0 = hpesa_AVERAGE_LPOWER                                             */
/*      1 = hpesa_AVERAGE_POWER                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TXPGetAveraging
                       (ViSession instrumentHandle,
                        ViPInt32 GSM_TXPAverageCountQuery,
                        ViPBoolean GSM_TXPAverageStateQuery,
                        ViPInt16 GSM_TXPAverageModeQuery,
                        ViPInt16 GSM_TXPAverageTypeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_NULL_POINTER(GSM_TXPAverageCountQuery,VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(GSM_TXPAverageStateQuery,VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(GSM_TXPAverageModeQuery, VI_ERROR_PARAMETER4)
	CHK_NULL_POINTER(GSM_TXPAverageTypeQuery, VI_ERROR_PARAMETER5)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = GenGetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_TXP,
                                GSM_TXPAverageCountQuery,
                                GSM_TXPAverageStateQuery,
                                GSM_TXPAverageModeQuery);

	errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":TXP:AVER:TYPE?",
                                  64, 
                                  buffer);

    if(errStatus<VI_SUCCESS) return errStatus;

	//remove the trailing \n
	buffer[strlen(buffer) - 1] = '\0';

    if(!strcmp(buffer, "LPOW"))
           *GSM_TXPAverageTypeQuery = hpesa_AVERAGE_LPOWER;
    else if (!strcmp(buffer, "POW"))
    	   *GSM_TXPAverageTypeQuery = hpesa_AVERAGE_POWER;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_TXPGetAveraging                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TXPSetTriggerSource                                            */
/*                                                                           */
/*      This method selects the trigger source for GSM transmit power        */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_TXPTriggerSource                                           */
/*                                                                           */
/*      Selects the trigger source used to control the data acquisitions.    */
/*                                                                           */
/*      hpesa_TXP_TRIG_IMMEDIATE - the next data acquisition is immediately  */
/*      taken (also called free run).                                        */
/*      hpesa_TXP_TRIG_EXTERNAL - rear panel external trigger input.         */
/*      hpesa_TXP_TRIG_RFBURST - wideband RF burst envelope trigger that has */
/*      automatic level control for periodic burst signals.                  */
/*      hpesa_TXP_TRIG_FRAME - uses the frame timer, which has been          */
/*      synchronized to the selected burst sync.                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TXPSetTriggerSource
                       (ViSession instrumentHandle,
                        ViInt16 GSM_TXPTriggerSource)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(GSM_TXPTriggerSource, 0, hpesa_TXP_TRIG_LASTENUM, 
                                                   VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    switch(GSM_TXPTriggerSource)
    {
        case hpesa_TXP_TRIG_IMMEDIATE:
            sprintf(buffer, ":TXP:TRIG:SOUR IMM");
            break;
        case hpesa_TXP_TRIG_EXTERNAL:
            sprintf(buffer, ":TXP:TRIG:SOUR EXT");
            break;
		case hpesa_TXP_TRIG_RFBURST:
            sprintf(buffer, ":TXP:TRIG:SOUR RFB");
            break;
		case hpesa_TXP_TRIG_FRAME:
            sprintf(buffer, ":TXP:TRIG:SOUR FRAM");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_TXPSetTriggerSource");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, buffer);

	return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_TXPSetTriggerSource                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TXPGetTriggerSource                                            */
/*                                                                           */
/*      This method retrieves the current trigger source for GSM tranmit     */
/*      power measurements.                                                  */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSM_TXPTriggerSourceQuery                                     */
/*                                                                           */
/*      Returns the current trigger source.                                  */
/*                                                                           */
/*      0 = hpesa_TXP_TRIG_IMMEDIATE                                         */
/*      1 = hpesa_TXP_TRIG_RFBURST                                           */
/*      2 = hpesa_TXP_TRIG_EXTERNAL                                          */
/*      3 = hpesa_TXP_TRIG_FRAME                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TXPGetTriggerSource
                       (ViSession instrumentHandle,
                        ViPInt16 GSM_TXPTriggerSourceQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(GSM_TXPTriggerSourceQuery, VI_ERROR_PARAMETER2)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Retrieve the external trigger slope
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":TXP:TRIG:SOUR?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0';  // strip the trailing \n

    if(!strcmp(buffer, "IMM"))
        *GSM_TXPTriggerSourceQuery = hpesa_TXP_TRIG_IMMEDIATE;
    else if (!strcmp(buffer, "EXT"))
        *GSM_TXPTriggerSourceQuery = hpesa_TXP_TRIG_EXTERNAL;
	else if (!strcmp(buffer, "RFB"))
		*GSM_TXPTriggerSourceQuery = hpesa_TXP_TRIG_RFBURST;
	else if (!strcmp(buffer, "FRAM"))
		*GSM_TXPTriggerSourceQuery = hpesa_TXP_TRIG_FRAME;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_TXPGetTriggerSource                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TXPSetThreshold                                                */
/*                                                                           */
/*      This method sets the threshold type and level for GSM tranmit power  */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_TXPThresholdType                                           */
/*                                                                           */
/*      Selects auto or manual control of the threshold level.               */
/*                                                                           */
/*      hpesa_TXP_THRESHOLD_ABSOLUTE - threshold value is set to an          */
/*      absolute power level                                                 */
/*      hpesa_TXP_THRESHOLD_RELATIVE - threshold value is set relative       */
/*      to the reference                                                     */
/*                                                                           */
/*    ViReal64 GSM_TXPThresholdLevel                                         */
/*                                                                           */
/*      Set the amplitude threshold level. Only the data above the threshold */
/*      level is kept and used to compute the average transmit carrier       */
/*      power.                                                               */
/*                                                                           */
/*      Units are in dBm for absolute mode and dB for relative mode.         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TXPSetThreshold
                       (ViSession instrumentHandle,
                        ViInt16 GSM_TXPThresholdType,
                        ViReal64 GSM_TXPThresholdLevel)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[256] = "\0";
	
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	CHK_ENUM(GSM_TXPThresholdType, 0, hpesa_TXP_THRESHOLD_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)

	switch(GSM_TXPThresholdType)
    {
        case hpesa_TXP_THRESHOLD_ABSOLUTE:
            sprintf(buffer, "TXP:THR:TYPE ABS");
            break;
        case hpesa_TXP_THRESHOLD_RELATIVE:
            sprintf(buffer, ":TXP:THR:TYPE REL");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_TXPSetThreshold");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }
	errStatus = hpesa_cmd(instrumentHandle, buffer);

	if(errStatus <VI_SUCCESS) return errStatus;
	
	errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":TXP:THR", 
                               GSM_TXPThresholdLevel);

	if(errStatus < VI_SUCCESS) 	return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_TXPSetThreshold                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TXPGetThreshold                                                */
/*                                                                           */
/*      This method retrieves the current threshold settings for GSM         */
/*      transmit power measurements.                                         */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSM_TXPThresholdTypeQuery                                     */
/*                                                                           */
/*      Returns the current threshold type.                                  */
/*                                                                           */
/*      0 = hpesa_TXP_THRESHOLD_ABSOLUTE                                     */
/*      1 = hpesa_TXP_THRESHOLD_RELATIVE                                     */
/*                                                                           */
/*    ViPReal64 GSM_TXPThresholdLevelQuery                                   */
/*                                                                           */
/*      Returns the current threshold level.  Units are determined by        */
/*      threshold type:  Relative - dB; Absolute - dBm.                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TXPGetThreshold
                       (ViSession instrumentHandle,
                        ViPInt16 GSM_TXPThresholdTypeQuery,
                        ViPReal64 GSM_TXPThresholdLevelQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(GSM_TXPThresholdTypeQuery, VI_ERROR_PARAMETER2)
	CHK_NULL_POINTER(GSM_TXPThresholdLevelQuery, VI_ERROR_PARAMETER3)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Retrieve the Threshold Type
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":TXP:THR:TYPE?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0';  // strip the trailing \n

    if(!strcmp(buffer, "ABS"))
        *GSM_TXPThresholdTypeQuery = hpesa_TXP_THRESHOLD_ABSOLUTE;
    else if (!strcmp(buffer, "REL"))
        *GSM_TXPThresholdTypeQuery = hpesa_TXP_THRESHOLD_RELATIVE;
	else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

	//Retrieve the Threshold Level
	errStatus = hpesa_cmdReal64_Q(instrumentHandle,
                                  ":TXP:THR?",
                                  GSM_TXPThresholdLevelQuery);


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_TXPGetThreshold                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TXPSetTimeSlots                                                */
/*                                                                           */
/*      This method sets the number of timeslots to show on the screen for a */
/*      GSM transmit power measurement.                                      */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_TXPTimeSlots                                               */
/*                                                                           */
/*      Sets the number of timeslots to show on screen.  Range is from 1 to  */
/*      8.                                                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TXPSetTimeSlots
                       (ViSession instrumentHandle,
                        ViInt32 GSM_TXPTimeSlots)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = hpesa_cmdInt(instrumentHandle, 
                              ":TXP:MTIM", 
                                GSM_TXPTimeSlots);

	if (errStatus <VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_TXPSetTimeSlots                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TXPGetTimeSlots                                                */
/*                                                                           */
/*      This method retrieves the current number of timeslots being used for */
/*      GSM transmit power measurements.                                     */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt32 GSM_TXPTimeSlotsQuery                                         */
/*                                                                           */
/*      Returns the current number of timeslots.                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TXPGetTimeSlots
                       (ViSession instrumentHandle,
                        ViPInt32 GSM_TXPTimeSlotsQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_NULL_POINTER(GSM_TXPTimeSlotsQuery,VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = hpesa_cmdInt32_Q(instrumentHandle, 
                                  ":TXP:MTIM?", 
                                 GSM_TXPTimeSlotsQuery);

	if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_TXPGetTimeSlots                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TXPSetBurstSync                                                */
/*                                                                           */
/*      This method sets the method of synchronizing the measurement to the  */
/*      GSM bursts.                                                          */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_TXPBurstSyncSource                                         */
/*                                                                           */
/*      Select the method of synchronizing the measurement to the GSM        */
/*      bursts.                                                              */
/*                                                                           */
/*      hpesa_BURST_SYNC_TSEQ - the training sequence burst sync performs a  */
/*      demodulation of the burst and determines the start and stop of the   */
/*      useful part of the burst based on the midamble training sequence.    */
/*                                                                           */
/*      hpesa_BURST_SYNC_RFAMP - the RF amplitude burst synch approximates   */
/*      the start and stop of the useful part of the burst without digital   */
/*      demodulation of the burst.                                           */
/*                                                                           */
/*      hpesa_BURST_SYNC_NONE - performs no burst synchronization.           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TXPSetBurstSync
                       (ViSession instrumentHandle,
                        ViInt16 GSM_TXPBurstSyncSource)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[256] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	CHK_ENUM(GSM_TXPBurstSyncSource, 0, hpesa_BURST_SYNC_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)
	switch(GSM_TXPBurstSyncSource)
    {
        case hpesa_BURST_SYNC_TSEQ:
            sprintf(buffer, ":TXP:BSYNC:SOUR TSEQ");
            break;
        case hpesa_BURST_SYNC_RFAMP:
            sprintf(buffer, ":TXP:BSYNC:SOUR RFAM");
            break;
		case hpesa_BURST_SYNC_NONE:
            sprintf(buffer, ":TXP:BSYNC:SOUR NONE");
            break;
	    default:
            fprintf(stderr, "Logic error in hpesa_GSM_TXPSetBurstSync");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }
	errStatus = hpesa_cmd(instrumentHandle, buffer);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_TXPSetBurstSync                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TXPGetBurstSync                                                */
/*                                                                           */
/*      This method retrieves the current burst sync source for GSM transmit */
/*      power measurements.                                                  */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSM_TXPBurstSyncSourceQuery                                   */
/*                                                                           */
/*      Returns the current burst sync source.                               */
/*                                                                           */
/*      0 = hpesa_BURST_SYNC_TSEQ                                            */
/*      1 = hpesa_BURST_SYNC_RFAMP                                           */
/*      2 = hpesa_BURST_SYNC_NONE                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TXPGetBurstSync
                       (ViSession instrumentHandle,
                        ViPInt16 GSM_TXPBurstSyncSourceQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(GSM_TXPBurstSyncSourceQuery, VI_ERROR_PARAMETER2)
	
    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Retrieve the Threshold Type
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":TXP:BSYNC:SOUR?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0';  // strip the trailing \n

    if(!strcmp(buffer, "TSEQ"))
        *GSM_TXPBurstSyncSourceQuery = hpesa_BURST_SYNC_TSEQ;
    else if (!strcmp(buffer, "RFAM"))
        *GSM_TXPBurstSyncSourceQuery = hpesa_BURST_SYNC_RFAMP;
	else if (!strcmp(buffer, "NONE"))
        *GSM_TXPBurstSyncSourceQuery = hpesa_BURST_SYNC_NONE;
	else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}


/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_TXPGetBurstSync                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTConfigure                                                   */
/*                                                                           */
/*      This method sets up the instrument for power vs. time (PVT)          */
/*      measurements using the factory default instrument settings and stops */
/*      the current measurement. It does not initiate the taking of          */
/*      measurement data.                                                    */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTConfigure
                       (ViSession instrumentHandle)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    ViInt32 oldTimeout = 0;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Temporarily set the timeout value to 10 seconds for the swtich
    errStatus = TempTimeoutChange(instrumentHandle, 10000, &oldTimeout);
    if (errStatus < VI_SUCCESS) return errStatus;

    errStatus = hpesa_cmd(instrumentHandle, ":CONF:PVT");
    if (errStatus < VI_SUCCESS) return errStatus;

    errStatus = hpesa_timeOut(instrumentHandle, oldTimeout);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_GSM_PVTConfigure                         */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTMeasureTrace                                                */
/*                                                                           */
/*      This method measures the average power during the useful part of   */
/*      the burst comparing the power ramp to required timing mask.          */
/*                                                                           */
/*      User can select one of three types of measurement modes: Measure,    */
/*      Read, or Fetch.                                                      */
/*                                                                           */
/*                                                                           */
/*      This method returns the TXP measurement results specified by the     */
/*      "GSM_PVTResultsType" parameter as a real array.                      */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 GSM_PVTMeasureTraceTimeout                                    */
/*                                                                           */
/*      This value temporarily changes the VISA timeout setting for the      */
/*      duration of the instrument measurement. The user needs to set this   */
/*      value to an appropriate time that will be longer then the expected   */
/*      measurement time. Units are in seconds.                              */
/*                                                                           */
/*    ViInt16 GSM_PVTMeasureTraceType                                        */
/*                                                                           */
/*      Selects measurement type. Note that for hpesa_FETCH type the         */
/*      instrument should already be in this measurement mode else the       */
/*      function will time out. User can select this measurement mode by     */
/*      first using the "MEASURE" or "READ" types or call the                */
/*      hpesa_GSM_PVTConfigure function.                                     */
/*                                                                           */
/*      hpesa_MEASURE - Stops current measurement, changes to this selected  */
/*      measurement, sets up instrument using factory defaults, makes        */
/*      measurement, returns measurement results.                            */
/*                                                                           */
/*      hpesa_READ - Stops current measurement,  changes to this selected    */
/*      measurement, uses instrument settings from last measurement of this  */
/*      type, makes measurement, returns measurements results.               */
/*                                                                           */
/*      hpesa_FETCH - Returns measurements results only. No new measurement  */
/*      is initiated.                                                        */
/*                                                                           */
/*    ViInt16 GSM_PVTResultsType                                             */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_0: Not supported by instrument.                   */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_1: Returns the following comma-separated scalar   */
/*      results:                                                             */
/*      1. Sample time is a floating point number that represents the time   */
/*      between samples when using the trace queries (n=0, 2, et cetera).    */
/*      2. Power of single burst is the mean power (in dBm) across the       */
/*      useful part of the selected burst in the most recently acquired      */
/*      data, or in the last data acquired at the end of a set of averages.  */
/*      If averaging is on, the power is for the last burst.                 */
/*      3. Power averaged is the power (in dBm) of N averaged bursts, if     */
/*      averaging is on. The power is averaged across the useful part of the */
/*      burst. Average m is a single burst from the acquired trace. If there */
/*      are multiple bursts in the acquired trace, only one burst is used    */
/*      for average m. This means that N traces are acquired to make the     */
/*      complete average. If averaging is off, the value of power averaged   */
/*      is the same as the power single burst value.                         */
/*      4. Number of samples is the number of data points in the captured    */
/*      signal. This number is useful when performing a query on the signal  */
/*      (that is when n=0, 2, et cetera).                                    */
/*      5. Start point of the useful part of the burst is the index of the   */
/*      data point at the start of the useful part of the burst.             */
/*      6. Stop point of the useful part of the burst is the index of the    */
/*      data point at the end of the useful part of the burst.               */
/*      7. Index of the data point where T 0 occurred.                       */
/*      8. Burst width of the useful part of the burst is the width of the   */
/*      burst measured at -3dB below the mean power in the useful part of    */
/*      the burst.                                                           */
/*      9. Maximum value is the maximum value of the most recently acquired  */
/*      data (in dBm).                                                       */
/*      10.Minimum value is the minimum value of the most recently acquired  */
/*      data (in dBm).                                                       */
/*      11.Burst search threshold is the value (in dBm) of the threshold     */
/*      where a valid burst is identified, after the data has been acquired. */
/*      12.IQ point delta is the number of data points offset that are       */
/*      internally applied to the useful data in traces n=2,3,4. You must    */
/*      apply this                                                           */
/*      correction value to find the actual location of the Start, Stop, or  */
/*      T 0 values.                                                          */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_2 - Returns the entire captured RF envelope (data */
/*      array). It is represented as log-magnitude versus time. This array   */
/*      contains 401 points of data.                                         */
/*                                                                           */
/*    ViAReal64 GSM_PVTDataResults                                           */
/*                                                                           */
/*      Trace data returned by measurement, formatted according to           */
/*      GSM_PVTResultsType.                                                  */
/*                                                                           */
/*    ViInt32 GSM_PVTDataResultsMaxSize                                      */
/*                                                                           */
/*      Specifies the maximum size of GSM_PVTDataResults array.              */
/*                                                                           */
/*    ViPInt32 GSM_PVTDataResultsSize                                        */
/*                                                                           */
/*      Returns the actual size of GSM_TXPDataResults array.                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTMeasureTrace
                       (ViSession instrumentHandle,
                        ViReal64 GSM_PVTMeasureTraceTimeout,
                        ViInt16 GSM_PVTMeasureTraceType,
                        ViInt16 GSM_PVTResultsType,
                        ViAReal64 GSM_PVTDataResults,
                        ViInt32 GSM_PVTDataResultsMaxSize,
                        ViPInt32 GSM_PVTDataResultsSize)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    int PVTValidResults[7] = {0,1,1,0,0,0,0};
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_ENUM(GSM_PVTMeasureTraceType, 0, hpesa_MEASURE_METHOD_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)
    CHK_ENUM(GSM_PVTResultsType, 0, hpesa_RESULTS_TYPE_LASTENUM,
                                                        VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(GSM_PVTDataResults, VI_ERROR_PARAMETER5)
    CHK_NULL_POINTER(GSM_PVTDataResultsSize, VI_ERROR_PARAMETER7)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    if((GSM_PVTResultsType > 6) || (PVTValidResults[GSM_PVTResultsType] == 0))
        return hpesa_INSTR_ERROR_INVALID_RESULTS_TYPE;

    errStatus = GenMeasureTrace(instrumentHandle,
                               hpesa_APPLICATION_MODE_PVT,
                               GSM_PVTMeasureTraceTimeout,
                               GSM_PVTMeasureTraceType,
                               GSM_PVTResultsType,
                               GSM_PVTDataResults,
                               GSM_PVTDataResultsMaxSize,
                               GSM_PVTDataResultsSize);



    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_PVTMeasureTrace                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTSetAveraging                                                */
/*                                                                           */
/*      This method sets the averaging for GSM power vs. time measurements.  */
/*      User can control the number of averages, turn off or on averaging,   */
/*      set the terminal control mode for averaging, and set the average     */
/*      type.                                                                */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_PVTAverageCount                                            */
/*                                                                           */
/*      Set the number of bursts that will be averaged. After the specified  */
/*      number of bursts (average counts), the averaging mode (terminal      */
/*      control) setting determines the averaging action.                    */
/*                                                                           */
/*    ViBoolean GSM_PVTAverageState                                          */
/*                                                                           */
/*      Sets the state of averaging, either on or off.                       */
/*                                                                           */
/*      VI_TRUE = Averaging on.                                              */
/*      VI_FALSE = Averaging off.                                            */
/*                                                                           */
/*    ViInt16 GSM_PVTAverageMode                                             */
/*                                                                           */
/*      Select the type of termination control used for the averaging        */
/*      function.  This determines the averaging action after the specified  */
/*      number of frames (average count) is reached.                         */
/*                                                                           */
/*      hpesa_AVERAGE_EXPONENTIAL - Each successive data acquisition after   */
/*      the average count is reached, is exponentially weighted and combined */
/*      with the existing average.                                           */
/*                                                                           */
/*      hpesa_AVERAGE_REPEAT - After reaching the average count, the         */
/*      averaging is reset and a new average is started.                     */
/*                                                                           */
/*    ViInt16 GSM_PVTAverageType                                             */
/*                                                                           */
/*      Select the type of averaging to be performed.                        */
/*                                                                           */
/*      hpesa_AVERAGE_LPOWER - logarithmically averages the power of the     */
/*      video data.                                                          */
/*      hpesa_AVERAGE_POWER  - averages the linear power of successive       */
/*      measurements.                                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTSetAveraging
                       (ViSession instrumentHandle,
                        ViInt32 GSM_PVTAverageCount,
                        ViBoolean GSM_PVTAverageState,
                        ViInt16 GSM_PVTAverageMode,
                        ViInt16 GSM_PVTAverageType)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[100] = "\0";

	GET_GLOBALS(instrumentHandle, thisPtr)
	
    // check the input parameters
    CHK_BOOLEAN(GSM_PVTAverageState, VI_ERROR_PARAMETER3)
    CHK_ENUM(GSM_PVTAverageMode,0,hpesa_AVERAGE_MODE_LASTENUM,
												VI_ERROR_PARAMETER4)
	CHK_ENUM(GSM_PVTAverageType, 0, hpesa_AVERAGE_TYPE_LASTENUM,
												VI_ERROR_PARAMETER5)
	

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	//Call GenSetAveraging
	errStatus = GenSetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_PVT,
                                GSM_PVTAverageCount,
                                GSM_PVTAverageState,
                                GSM_PVTAverageMode);
 	//Set AverageType
	switch(GSM_PVTAverageType)
    {
        case hpesa_AVERAGE_LPOWER:
            sprintf(buffer, ":PVT:AVER:TYPE LPOW");
            break;
		case hpesa_AVERAGE_POWER:
            sprintf(buffer, ":PVT:AVER:TYPE POW");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_PVTSetAveraging");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, buffer);


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_PVTSetAveraging                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTGetAveraging                                                */
/*                                                                           */
/*      This method retrieves the average settings for GSM power vs. time    */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt32 GSM_PVTAverageCountQuery                                      */
/*                                                                           */
/*      Returns the current average count.                                   */
/*                                                                           */
/*    ViPBoolean GSM_PVTAverageStateQuery                                    */
/*                                                                           */
/*      Returns the current average state.                                   */
/*                                                                           */
/*      0 = VI_FALSE                                                         */
/*      1 = VI_TRUE                                                          */
/*                                                                           */
/*    ViPInt16 GSM_PVTAverageModeQuery                                       */
/*                                                                           */
/*      Returns the current average mode.                                    */
/*                                                                           */
/*      0 = hpesa_AVERAGE_EXPONENTIAL                                        */
/*      1 = hpesa_AVERAGE_REPEAT                                             */
/*                                                                           */
/*    ViPInt16 GSM_PVTAverageTypeQuery                                       */
/*                                                                           */
/*      Returns the current average type.                                    */
/*                                                                           */
/*      0 = hpesa_AVERAGE_LPOWER                                             */
/*      1 = hpesa_AVERAGE_POWER                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTGetAveraging
                       (ViSession instrumentHandle,
                        ViPInt32 GSM_PVTAverageCountQuery,
                        ViPBoolean GSM_PVTAverageStateQuery,
                        ViPInt16 GSM_PVTAverageModeQuery,
                        ViPInt16 GSM_PVTAverageTypeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_NULL_POINTER(GSM_PVTAverageCountQuery,VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(GSM_PVTAverageStateQuery,VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(GSM_PVTAverageModeQuery, VI_ERROR_PARAMETER4)
	CHK_NULL_POINTER(GSM_PVTAverageTypeQuery, VI_ERROR_PARAMETER5)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = GenGetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_PVT,
                                GSM_PVTAverageCountQuery,
                                GSM_PVTAverageStateQuery,
                                GSM_PVTAverageModeQuery);

	 errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":PVT:AVER:TYPE?",
                                  64, 
                                  buffer);

    if(errStatus<VI_SUCCESS) return errStatus;

	//remove the trailing \n
	buffer[strlen(buffer) - 1] = '\0';

    if(!strcmp(buffer, "LPOW"))
           *GSM_PVTAverageTypeQuery = hpesa_AVERAGE_LPOWER;
    else if (!strcmp(buffer, "POW"))
    	   *GSM_PVTAverageTypeQuery = hpesa_AVERAGE_POWER;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }
    
    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_PVTGetAveraging                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTSetTriggerSource                                            */
/*                                                                           */
/*      This method sets the trigger source for GSM power vs. time           */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_PVTTrigSource                                              */
/*                                                                           */
/*      Select the trigger source used to control the data acquisitions.     */
/*                                                                           */
/*      hpesa_PVT_TRIG_EXTERNAL - rear panel external trigger input          */
/*                                                                           */
/*      hpesa_PVT_TRIG_RFBURST - wideband RF burst envelope trigger that has */
/*      automatic level control for periodic burst signals.                  */
/*                                                                           */
/*      hpesa_PVT_TRIG_FRAME - uses the frame timer, which has been          */
/*      synchronized to the selected burst sync.                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTSetTriggerSource
                       (ViSession instrumentHandle,
                        ViInt16 GSM_PVTTrigSource)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(GSM_PVTTrigSource, 0, hpesa_PVT_TRIG_LASTENUM, 
                                                   VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    switch(GSM_PVTTrigSource)
    {
        case hpesa_PVT_TRIG_EXTERNAL:
            sprintf(buffer, ":PVT:TRIG:SOUR EXT");
            break;
		case hpesa_PVT_TRIG_RFBURST:
            sprintf(buffer, ":PVT:TRIG:SOUR RFB");
            break;
		case hpesa_PVT_TRIG_FRAME:
            sprintf(buffer, ":PVT:TRIG:SOUR FRAM");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_PVTSetTriggerSource");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, buffer);


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_PVTSetTriggerSource                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTGetTriggerSource                                            */
/*                                                                           */
/*      This method returns the current trigger source for GSM power vs.     */
/*      time measurements.                                                   */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSM_PVTTrigSourceQuery                                        */
/*                                                                           */
/*      Returns the current trigger source.                                  */
/*                                                                           */
/*      0 = hpesa_PVT_TRIG_EXTERNAL                                          */
/*      1 = hpesa_PVT_TRIG_RFBURST                                           */
/*      2 = hpesa_PVT_TRIG_FRAME                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTGetTriggerSource
                       (ViSession instrumentHandle,
                        ViPInt16 GSM_PVTTrigSourceQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(GSM_PVTTrigSourceQuery, VI_ERROR_PARAMETER2)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Retrieve the external trigger slope
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":PVT:TRIG:SOUR?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0';  // strip the trailing \n

    if (!strcmp(buffer, "EXT"))
        *GSM_PVTTrigSourceQuery = hpesa_PVT_TRIG_EXTERNAL;
	else if (!strcmp(buffer, "RFB"))
		*GSM_PVTTrigSourceQuery = hpesa_PVT_TRIG_RFBURST;
	else if (!strcmp(buffer, "FRAM"))
		*GSM_PVTTrigSourceQuery = hpesa_PVT_TRIG_FRAME;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_PVTGetTriggerSource                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTSetBurstSync                                                */
/*                                                                           */
/*      This method sets the method of synchronizing the power vs. time      */
/*      measurement to the GSM bursts.                                       */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_PVTBurstSyncSource                                         */
/*                                                                           */
/*      Select the method of synchronizing the measurement to the GSM        */
/*      bursts.                                                              */
/*                                                                           */
/*      hpesa_BURST_SYNC_TSEQ - the training sequence burst sync performs a  */
/*      demodulation of the burst and determines the start and stop of the   */
/*      useful part of the burst based on the midamble training sequence.    */
/*                                                                           */
/*      hpesa_BURST_SYNC_RFAMP - performs burst synchronization based on the */
/*      rising and falling edges of the burst.                               */
/*                                                                           */
/*      hpesa_BURST_SYNC_NONE - performs no burst synchronization.           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTSetBurstSync
                       (ViSession instrumentHandle,
                        ViInt16 GSM_PVTBurstSyncSource)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[256] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	CHK_ENUM(GSM_PVTBurstSyncSource, 0, hpesa_BURST_SYNC_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)
	switch(GSM_PVTBurstSyncSource)
    {
        case hpesa_BURST_SYNC_TSEQ:
            sprintf(buffer, ":PVT:BSYNC:SOUR TSEQ");
            break;
        case hpesa_BURST_SYNC_RFAMP:
            sprintf(buffer, ":PVT:BSYNC:SOUR RFAM");
            break;
		case hpesa_BURST_SYNC_NONE:
            sprintf(buffer, ":PVT:BSYNC:SOUR NONE");
            break;
	    default:
            fprintf(stderr, "Logic error in hpesa_GSM_PVTSetBurstSync");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }
	errStatus = hpesa_cmd(instrumentHandle, buffer);


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_PVTSetBurstSync                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTGetBurstSync                                                */
/*                                                                           */
/*      This method retrieves the current burst sync source for GSM power    */
/*      vs. time measurements.                                               */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSM_PVTBurstSyncSourceQuery                                   */
/*                                                                           */
/*      Returns the current burst sync source.                               */
/*                                                                           */
/*      0 = hpesa_BURST_SYNC_TSEQ                                            */
/*      1 = hpesa_BURST_SYNC_RFAMP                                           */
/*      2 = hpesa_BURST_SYNC_NONE                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTGetBurstSync
                       (ViSession instrumentHandle,
                        ViPInt16 GSM_PVTBurstSyncSourceQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_NULL_POINTER(GSM_PVTBurstSyncSourceQuery, VI_ERROR_PARAMETER2)
	
    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Retrieve the Threshold Type
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":PVT:BSYNC:SOUR?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0';  // strip the trailing \n

    if(!strcmp(buffer, "TSEQ"))
        *GSM_PVTBurstSyncSourceQuery = hpesa_BURST_SYNC_TSEQ;
    else if (!strcmp(buffer, "RFAM"))
        *GSM_PVTBurstSyncSourceQuery = hpesa_BURST_SYNC_RFAMP;
	else if (!strcmp(buffer, "NONE"))
        *GSM_PVTBurstSyncSourceQuery = hpesa_BURST_SYNC_NONE;
	else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_PVTGetBurstSync                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTSetTimeSlots                                                */
/*                                                                           */
/*      This method sets the number of timeslots to show on the screen for   */
/*      GSM power vs. time measurements.                                     */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_PVTTimeSlots                                               */
/*                                                                           */
/*      Sets the number of timeslots.  Range is 1 to 8.                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTSetTimeSlots
                       (ViSession instrumentHandle,
                        ViInt32 GSM_PVTTimeSlots)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = hpesa_cmdInt(instrumentHandle, 
                              ":PVT:MTIM", 
                                GSM_PVTTimeSlots);

	if (errStatus <VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_PVTSetTimeSlots                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTGetTimeSlots                                                */
/*                                                                           */
/*      This method retrieves the current number of timeslots for GSM power  */
/*      vs. time measurements.                                               */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt32 GSM_PVTTimeSlotsQuery                                         */
/*                                                                           */
/*      Returns the current number of timeslots.                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTGetTimeSlots
                       (ViSession instrumentHandle,
                        ViPInt32 GSM_PVTTimeSlotsQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_NULL_POINTER(GSM_PVTTimeSlotsQuery,VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = hpesa_cmdInt32_Q(instrumentHandle, 
                                  ":PVT:MTIM?", 
                                 GSM_PVTTimeSlotsQuery);

	if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_PVTGetTimeSlots                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTLwrMskSetAbsLvl                                             */
/*                                                                           */
/*      This method allows sets the lower mask absolute amplitude levels for */
/*      GSM power vs. time measurements.  The user enters the absolute power */
/*      level for any of the mask line segments that require absolute limits */
/*      in addition to their relative limits. The defined relative mask      */
/*      values are normally used as the limits for testing. If the power of  */
/*      the reference level is decreased, all of these relative mask power   */
/*      levels will decrease by the same amount until they reach a defined   */
/*      minimum absolute power. Then that absolute power will be used as the */
/*      test limit.                                                          */
/*                                                                           */
/*      Any portion of the signal that has no limit line segment defined for */
/*      it, will default its to a very low limit (-200 dBm). Because of      */
/*      this, all data in that undefined area will pass the test.            */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_PVTLwrMskListSize                                          */
/*                                                                           */
/*      This size of the                                                     */
/*                                                                           */
/*    ViAReal64 GSM_PVTLwrMskAbsList                                         */
/*                                                                           */
/*      An array containing the  absolute power levels for the mask line     */
/*      segments.                                                            */
/*                                                                           */
/*      Note that only the amount of values equal to the number of mask      */
/*      points will be accepted.  Set the number of mask points via          */
/*      hpesa_GSM_PVTLwrMskSetTimePoints() and verify the number of mask     */
/*      points via hpesa_GSM_PVTLwrMskGetPoints.                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTLwrMskSetAbsLvl
                       (ViSession instrumentHandle,
                        ViInt32 GSM_PVTLwrMskListSize,
                        ViAReal64 GSM_PVTLwrMskAbsList)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    ViChar *cmdString;
    int x=0; // counter

    GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_LONG_RANGE(GSM_PVTLwrMskListSize, 
                  1,
                  hpesa_CMDINT32ARR_Q_MAX,
                  VI_ERROR_PARAMETER2)
                
    CHK_NULL_POINTER(GSM_PVTLwrMskAbsList,VI_ERROR_PARAMETER3)

    // allocate enough memory
    cmdString = (ViChar *)malloc((sizeof(ViChar) * GSM_PVTLwrMskListSize * 16) + 100);
    if(!cmdString) return VI_ERROR_ALLOC;

    sprintf(cmdString, "PVT:MASK:LIST:LOW:ABS %.15g", GSM_PVTLwrMskAbsList[0]);

    // assign the values to the command string
    for (x=1; x<GSM_PVTLwrMskListSize; x++)
    {
        sprintf(cmdString, "%s,%.15g", cmdString, GSM_PVTLwrMskAbsList[x]);
    }

    sprintf(cmdString, "%s\n", cmdString);
   
    errStatus = hpesa_cmd(instrumentHandle, cmdString);

    free(cmdString);

	return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_PVTLwrMskSetAbsLvl                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTLwrMskGetAbsLvl                                             */
/*                                                                           */
/*      This method retrieves the current absolute power levels for the mask */
/*      line segments.                                                       */
/*                                                                           */
/*      Note that that the number of values returned is equal to the number  */
/*      of mask points will be accepted.  Set the number of mask points via  */
/*      hpesa_GSM_PVTLwrMskSetTimePoints() and verify the number of mask     */
/*      points via hpesa_GSM_PVTLwrMskGetPoints.                             */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_PVTLwrMskAbsListSzQ                                        */
/*                                                                           */
/*      The size of the array PVTLwrMskAbsListQuery.                         */
/*                                                                           */
/*    ViAReal64 GSM_PVTLwrMskAbsListQuery                                    */
/*                                                                           */
/*      Returns the current absolute power levels for the mask line segments.*/
/*                                                                           */
/*    ViPInt32 GSM_PVTLwrMskAbsListActSz                                     */
/*                                                                           */
/*      Returns the actual number of elements returned in                    */
/*      GSM_PVTLwrMskAbsListQuery.                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTLwrMskGetAbsLvl
                       (ViSession instrumentHandle,
                        ViInt32 GSM_PVTLwrMskAbsListSzQ,
                        ViAReal64 GSM_PVTLwrMskAbsListQuery,
                        ViPInt32 GSM_PVTLwrMskAbsListActSz)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)


    // check parameters
    CHK_LONG_RANGE(GSM_PVTLwrMskAbsListSzQ, 
                  1,
                  hpesa_CMDINT32ARR_Q_MAX,
                  VI_ERROR_PARAMETER2)
                
    CHK_NULL_POINTER(GSM_PVTLwrMskAbsListQuery,VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(GSM_PVTLwrMskAbsListActSz,VI_ERROR_PARAMETER4)


    errStatus = hpesa_cmdRealCommaArray_Q(instrumentHandle,
                                          "PVT:MASK:LIST:LOW:ABS?",
                                          GSM_PVTLwrMskAbsListSzQ,
                                          GSM_PVTLwrMskAbsListQuery,
                                          GSM_PVTLwrMskAbsListActSz);
    if(errStatus < VI_SUCCESS) return errStatus;


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_PVTLwrMskGetAbsLvl                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTLwrMskGetPoints                                             */
/*                                                                           */
/*      This method retrieves the number of elements in the lower mask for   */
/*      GSM power vs. time measurements. This value is determined by the     */
/*      number of time points entered using hpesa_GSM_PVTLwrMskSetTimePoints.*/
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt32 GSM_PVTLwrMskListSzQuery                                      */
/*                                                                           */
/*      Returns the current number of elements in the lower mask.            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTLwrMskGetPoints
                       (ViSession instrumentHandle,
                        ViPInt32 GSM_PVTLwrMskListSzQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_NULL_POINTER(GSM_PVTLwrMskListSzQuery,VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = hpesa_cmdInt32_Q(instrumentHandle, 
                                  ":PVT:MASK:LIST:LOW:POIN?", 
                                 GSM_PVTLwrMskListSzQuery);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_PVTLwrMskGetPoints                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTLwrMskSetRelLvl                                             */
/*                                                                           */
/*      This method allows the user to enter the relative power level for    */
/*      each of the horizontal line segments in the lower limit mask for GSM */
/*      power vs. time measurements. There should be a power level for each  */
/*      time point entered using the hpesa_GSM_PVTLwrMskSetTimePoints        */
/*      method. These power levels are all relative to the defined Reference */
/*      Power Level (the average power in the useful part of the data). When */
/*      an upper and                                                         */
/*      lower limit mask have been defined, the Reference Power Level is the */
/*      mid-point between these two limits at time t0.                       */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_PVTLwrMskRelListSz                                         */
/*                                                                           */
/*      The size of the array GSM_PVTLwrMskRelList.                          */
/*                                                                           */
/*    ViAReal64 GSM_PVTLwrMskRelList                                         */
/*                                                                           */
/*      The array containing selects the relative power level for each of    */
/*      the horizontal line segments in the lower limit mask.                */
/*                                                                           */
/*      Note that only the amount of values equal to the number of mask      */
/*      points will be accepted.  Set the number of mask points via          */
/*      hpesa_GSM_PVTLwrMskSetTimePoints() and verify the number of mask     */
/*      points via hpesa_GSM_PVTLwrMskGetPoints.                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTLwrMskSetRelLvl
                       (ViSession instrumentHandle,
                        ViInt32 GSM_PVTLwrMskRelListSz,
                        ViAReal64 GSM_PVTLwrMskRelList)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    ViChar *cmdString;
    int x=0; // counter

    GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_LONG_RANGE(GSM_PVTLwrMskRelListSz, 
                  1,
                  hpesa_CMDINT32ARR_Q_MAX,
                  VI_ERROR_PARAMETER2)
                
    CHK_NULL_POINTER(GSM_PVTLwrMskRelList,VI_ERROR_PARAMETER3)

    // allocate enough memory
    cmdString = (ViChar *)malloc((sizeof(ViChar) * GSM_PVTLwrMskRelListSz * 16) + 100);
    if(!cmdString) return VI_ERROR_ALLOC;

    sprintf(cmdString, "PVT:MASK:LIST:LOW:REL %.15g", GSM_PVTLwrMskRelList[0]);

    // assign the values to the command string
    for (x=1; x<GSM_PVTLwrMskRelListSz; x++)
    {
        sprintf(cmdString, "%s,%.15g", cmdString, GSM_PVTLwrMskRelList[x]);
    }

    sprintf(cmdString, "%s\n", cmdString);
   
    errStatus = hpesa_cmd(instrumentHandle, cmdString);

    free(cmdString);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_PVTLwrMskSetRelLvl                      */
/*****************************************************************************/




/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTLwrMskGetRelLvl                                             */
/*                                                                           */
/*      This method retrieves the current set of relative power levels for   */
/*      the horizontal line segments in the lower limit mask for GSM power   */
/*      vs. time measurements.                                               */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_PVTLwrMskRelListSzQ                                        */
/*                                                                           */
/*      The size of the array GSM_PVTLwrMskRelListQuery.                     */
/*                                                                           */
/*    ViAReal64 GSM_PVTLwrMskRelListQuery                                    */
/*                                                                           */
/*      Returns an array containing relative power level for each of the     */
/*      horizontal line segments in the lower limit mask.                    */
/*                                                                           */
/*    ViPInt32 GSM_PVTLwrMskRelListActSz                                     */
/*                                                                           */
/*      Returns the actual number of elements returned in                    */
/*      GSM_PVTLwrMskRelListQuery.                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTLwrMskGetRelLvl
                       (ViSession instrumentHandle,
                        ViInt32 GSM_PVTLwrMskRelListSzQ,
                        ViAReal64 GSM_PVTLwrMskRelListQuery,
                        ViPInt32 GSM_PVTLwrMskRelListActSz)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)


    // check parameters
    CHK_LONG_RANGE(GSM_PVTLwrMskRelListSzQ, 
                  1,
                  hpesa_CMDINT32ARR_Q_MAX,
                  VI_ERROR_PARAMETER2)
                
    CHK_NULL_POINTER(GSM_PVTLwrMskRelListQuery,VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(GSM_PVTLwrMskRelListActSz,VI_ERROR_PARAMETER4)


    errStatus = hpesa_cmdRealCommaArray_Q(instrumentHandle,
                                          "PVT:MASK:LIST:LOW:REL?",
                                          GSM_PVTLwrMskRelListSzQ,
                                          GSM_PVTLwrMskRelListQuery,
                                          GSM_PVTLwrMskRelListActSz);

    return errStatus;

}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_PVTLwrMskGetRelLvl                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTLwrMskSetTimePoints                                         */
/*                                                                           */
/*      This method allows the user to enter the ending points for the       */
/*      horizontal line segments that define the lower limit mask for GSM    */
/*      power vs. time measurements.  All the line segments begin at the     */
/*      time = t 0 reference point at the center of the useful data (usually */
/*      the center of the burst).  For example, all the mask line segments   */
/*      to the right of t 0 will have positive time values that get          */
/*      successively larger, while those to the left get successively more   */
/*      negative.                                                            */
/*                                                                           */
/*      It is recommended that you select a large time value for your first  */
/*      and last mask points (e.g. -1 and +1 second). This guarantees that   */
/*      youve defined a limit for all the measured data.                    */
/*                                                                           */
/*      The range is -1 second to +1 second, referenced to t0 at the center  */
/*      of the useful data (burst center).  There are 1 to 25 time points in */
/*      a mask.                                                              */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_PVTLwrMskTimeListSz                                        */
/*                                                                           */
/*      The size of the GSM_PVTLwrMskTimeList array.                         */
/*                                                                           */
/*    ViAReal64 GSM_PVTLwrMskTimeList                                        */
/*                                                                           */
/*      The array used to set the ending points for the horizontal line      */
/*      segments.                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTLwrMskSetTimePoints
                       (ViSession instrumentHandle,
                        ViInt32 GSM_PVTLwrMskTimeListSz,
                        ViAReal64 GSM_PVTLwrMskTimeList)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    ViChar *cmdString;
    int x=0; // counter

    GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_LONG_RANGE(GSM_PVTLwrMskTimeListSz, 
                  1,
                  hpesa_CMDINT32ARR_Q_MAX,
                  VI_ERROR_PARAMETER2)
                
    CHK_NULL_POINTER(GSM_PVTLwrMskTimeList,VI_ERROR_PARAMETER3)

    // allocate enough memory
    cmdString = (ViChar *)malloc((sizeof(ViChar) * GSM_PVTLwrMskTimeListSz * 16) + 100);
    if(!cmdString) return VI_ERROR_ALLOC;

    sprintf(cmdString, "PVT:MASK:LIST:LOW:TIME %.15g", GSM_PVTLwrMskTimeList[0]);

    // assign the values to the command string
    for (x=1; x<GSM_PVTLwrMskTimeListSz; x++)
    {
        sprintf(cmdString, "%s,%.15g", cmdString, GSM_PVTLwrMskTimeList[x]);
    }

    sprintf(cmdString, "%s\n", cmdString);
   
    errStatus = hpesa_cmd(instrumentHandle, cmdString);

    free(cmdString);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                   end hpesa_GSM_PVTLwrMskSetTimePoints                    */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTLwrMskGetTimePoints                                         */
/*                                                                           */
/*      This method retrieves the current ending points for the horizontal   */
/*      line segments that define the lower limit mask for GSM power vs.     */
/*      time measurements.                                                   */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_PVTLwrMskTimeListSzQ                                       */
/*                                                                           */
/*      The size of the GSM_PVTLwrMskTimeListQuery array.                    */
/*                                                                           */
/*    ViAReal64 GSM_PVTLwrMskTimeListQuery                                   */
/*                                                                           */
/*      Returns the current ending points for the horizontal line segments.  */
/*                                                                           */
/*    ViPInt32 GSM_PVTLwrMskTimeLstActSz                                     */
/*                                                                           */
/*      Returns the actual number of elements returned in                    */
/*      GSM_PVTLwrMskRelListQuery.                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTLwrMskGetTimePoints
                       (ViSession instrumentHandle,
                        ViInt32 GSM_PVTLwrMskTimeListSzQ,
                        ViAReal64 GSM_PVTLwrMskTimeListQuery,
                        ViPInt32 GSM_PVTLwrMskTimeLstActSz)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_LONG_RANGE(GSM_PVTLwrMskTimeListSzQ, 
                  1,
                  hpesa_CMDINT32ARR_Q_MAX,
                  VI_ERROR_PARAMETER2)
                
    CHK_NULL_POINTER(GSM_PVTLwrMskTimeListQuery,VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(GSM_PVTLwrMskTimeLstActSz,VI_ERROR_PARAMETER4)


    errStatus = hpesa_cmdRealCommaArray_Q(instrumentHandle,
                                          "PVT:MASK:LIST:LOW:TIME?",
                                          GSM_PVTLwrMskTimeListSzQ,
                                          GSM_PVTLwrMskTimeListQuery,
                                          GSM_PVTLwrMskTimeLstActSz);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                   end hpesa_GSM_PVTLwrMskGetTimePoints                    */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTMaskSetCustom                                               */
/*                                                                           */
/*      This method selects standard masks or user-defined custom masks to   */
/*      compare measured data against.                                       */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_PVTMaskCustom                                              */
/*                                                                           */
/*      Selects which mask to compare measured data against.                 */
/*                                                                           */
/*      hpesa_PVT_MASK_STANDARD - Uses standard masks.                       */
/*                                                                           */
/*      hpesa_PVT_MASK_CUSTOM - Uses user-defines custom masks.              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTMaskSetCustom
                       (ViSession instrumentHandle,
                        ViInt16 GSM_PVTMaskCustom)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(GSM_PVTMaskCustom, 0, hpesa_PVT_MASK_LASTENUM, 
                                                   VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    switch(GSM_PVTMaskCustom)
    {
        case hpesa_PVT_MASK_STANDARD:
            sprintf(buffer, ":PVT:MASK:SEL STAN");
            break;
		case hpesa_PVT_MASK_CUSTOM:
            sprintf(buffer, ":PVT:MASK:SEL CUST");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_PVTMaskSetCustom");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, buffer);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_PVTMaskSetCustom                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTMaskGetCustom                                               */
/*                                                                           */
/*      This method retrieves the current mask type being used to compare    */
/*      measured data against.                                               */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSM_PVTMaskCustomQuery                                        */
/*                                                                           */
/*      Returns the current mask type.                                       */
/*                                                                           */
/*      0 = hpesa_PVT_MASK_STANDARD                                          */
/*      1 = hpesa_PVT_MASK_CUSTOM                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTMaskGetCustom
                       (ViSession instrumentHandle,
                        ViPInt16 GSM_PVTMaskCustomQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(GSM_PVTMaskCustomQuery, VI_ERROR_PARAMETER2)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Retrieve the external trigger slope
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":PVT:MASK:SEL?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0';  // strip the trailing \n

    if (!strcmp(buffer, "STAN"))
        *GSM_PVTMaskCustomQuery = hpesa_PVT_MASK_STANDARD;
	else if (!strcmp(buffer, "CUST"))
		*GSM_PVTMaskCustomQuery = hpesa_PVT_MASK_CUSTOM;
	else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }
	
    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_PVTMaskGetCustom                       */
/*****************************************************************************/





/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTUprMskSetAbsLvl                                             */
/*                                                                           */
/*      This method allows sets the upper mask absolute amplitude levels for */
/*      GSM power vs. time measurements.  The user enters the absolute power */
/*      level for any of the mask line segments that require absolute limits */
/*      in addition to their relative limits. The defined relative mask      */
/*      values are normally used as the limits for testing. If the power of  */
/*      the reference level is increased, all of these relative mask power   */
/*      levels will increase by the same amount until they reach a defined   */
/*      minimum absolute power. Then that absolute power will be used as the */
/*      test limit.                                                          */
/*                                                                           */
/*      Any portion of the signal that has no limit line segment defined for */
/*      it, will default its to a very low limit (-200 dBm). Because of      */
/*      this, all data in that undefined area will pass the test.            */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_PVTUprMskListSize                                          */
/*                                                                           */
/*      This size of the                                                     */
/*                                                                           */
/*    ViAReal64 GSM_PVTUprMskAbsList                                         */
/*                                                                           */
/*      An array containing the  absolute power levels for the mask line     */
/*      segments.                                                            */
/*                                                                           */
/*      Note that only the amount of values equal to the number of mask      */
/*      points will be accepted.  Set the number of mask points via          */
/*      hpesa_GSM_PVTUprMskSetTimePoints() and verify the number of mask     */
/*      points via hpesa_GSM_PVTUprMskGetPoints.                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTUprMskSetAbsLvl
                       (ViSession instrumentHandle,
                        ViInt32 GSM_PVTUprMskListSize,
                        ViAReal64 GSM_PVTUprMskAbsList)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    ViChar *cmdString;
    int x=0; // counter

    GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_LONG_RANGE(GSM_PVTUprMskListSize, 
                  1,
                  hpesa_CMDINT32ARR_Q_MAX,
                  VI_ERROR_PARAMETER2)
                
    CHK_NULL_POINTER(GSM_PVTUprMskAbsList,VI_ERROR_PARAMETER3)

    // allocate enough memory
    cmdString = (ViChar *)malloc((sizeof(ViChar) * GSM_PVTUprMskListSize * 16) + 100);
    if(!cmdString) return VI_ERROR_ALLOC;

    sprintf(cmdString, "PVT:MASK:LIST:UPP:ABS %.15g", GSM_PVTUprMskAbsList[0]);

    // assign the values to the command string
    for (x=1; x<GSM_PVTUprMskListSize; x++)
    {
        sprintf(cmdString, "%s,%.15g", cmdString, GSM_PVTUprMskAbsList[x]);
    }

    sprintf(cmdString, "%s\n", cmdString);
   
    errStatus = hpesa_cmd(instrumentHandle, cmdString);

    free (cmdString);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_PVTUprMskSetAbsLvl                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTUprMskGetAbsLvl                                             */
/*                                                                           */
/*      This method retrieves the current absolute power levels for the mask */
/*      line segments.                                                       */
/*                                                                           */
/*      Note that that the number of values returned is equal to the number  */
/*      of mask points will be accepted.  Set the number of mask points via  */
/*      hpesa_GSM_PVTUprMskSetTimePoints() and verify the number of mask     */
/*      points via hpesa_GSM_PVTUprMskGetPoints.                             */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_PVTUprMskAbsListSzQ                                        */
/*                                                                           */
/*      The size of the array PVTUprMskAbsListQuery.                         */
/*                                                                           */
/*    ViAReal64 GSM_PVTUprMskAbsListQuery                                    */
/*                                                                           */
/*      Returns the current absolute power levels for the mask line segments.*/
/*                                                                           */
/*    ViPInt32 GSM_PVTUprMskAbsListActSz                                     */
/*                                                                           */
/*      Returns the actual number of elements returned in                    */
/*      GSM_PVTUprMskAbsListQuery.                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTUprMskGetAbsLvl
                       (ViSession instrumentHandle,
                        ViInt32 GSM_PVTUprMskAbsListSzQ,
                        ViAReal64 GSM_PVTUprMskAbsListQuery,
                        ViPInt32 GSM_PVTUprMskAbsListActSz)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)


    // check parameters
    CHK_LONG_RANGE(GSM_PVTUprMskAbsListSzQ, 
                  1,
                  hpesa_CMDINT32ARR_Q_MAX,
                  VI_ERROR_PARAMETER2)
                
    CHK_NULL_POINTER(GSM_PVTUprMskAbsListQuery,VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(GSM_PVTUprMskAbsListActSz,VI_ERROR_PARAMETER4)


    errStatus = hpesa_cmdRealCommaArray_Q(instrumentHandle,
                                          "PVT:MASK:LIST:UPP:ABS?",
                                          GSM_PVTUprMskAbsListSzQ,
                                          GSM_PVTUprMskAbsListQuery,
                                          GSM_PVTUprMskAbsListActSz);
    if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_PVTUprMskGetAbsLvl                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTUprMskGetPoints                                             */
/*                                                                           */
/*      This method retrieves the number of elements in the upper mask for   */
/*      GSM power vs. time measurements. This value is determined by the     */
/*      number of time points entered using hpesa_GSM_PVTUprMskSetTimePoints.*/
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt32 GSM_PVTUprMskListSzQuery                                      */
/*                                                                           */
/*      Returns the current number of elements in the upper mask.            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTUprMskGetPoints
                       (ViSession instrumentHandle,
                        ViPInt32 GSM_PVTUprMskListSzQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_NULL_POINTER(GSM_PVTUprMskListSzQuery,VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = hpesa_cmdInt32_Q(instrumentHandle, 
                                  ":PVT:MASK:LIST:UPP:POIN?", 
                                 GSM_PVTUprMskListSzQuery);

	if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                     end hpesa_GSM_PVTUprMskGetPoints                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTUprMskSetRelLvl                                             */
/*                                                                           */
/*      This method allows the user to enter the relative power level for    */
/*      each of the horizontal line segments in the upper limit mask for GSM */
/*      power vs. time measurements. There should be a power level for each  */
/*      time point entered using the hpesa_GSM_PVTUprMskSetTimePoints        */
/*      method. These power levels are all relative to the defined Reference */
/*      Power Level (the average power in the useful part of the data). When */
/*      an upper and lower limit mask have been defined, the Reference Power */
/*      Level is the mid-point between these two limits at time t0.          */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_PVTUprMskRelListSz                                         */
/*                                                                           */
/*      The size of the array GSM_PVTUprMskRelList.                          */
/*                                                                           */
/*    ViAReal64 GSM_PVTUprMskRelList                                         */
/*                                                                           */
/*      The array containing selects the relative power level for each of    */
/*      the horizontal line segments in the upper limit mask.                */
/*                                                                           */
/*      Note that only the amount of values equal to the number of mask      */
/*      points will be accepted.  Set the number of mask points via          */
/*      hpesa_GSM_PVTUprMskSetTimePoints() and verify the number of mask     */
/*      points via hpesa_GSM_PVTUprMskGetPoints.                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTUprMskSetRelLvl
                       (ViSession instrumentHandle,
                        ViInt32 GSM_PVTUprMskRelListSz,
                        ViAReal64 GSM_PVTUprMskRelList)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    ViChar *cmdString;
    int x=0; // counter

    GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_LONG_RANGE(GSM_PVTUprMskRelListSz, 
                  1,
                  hpesa_CMDINT32ARR_Q_MAX,
                  VI_ERROR_PARAMETER2)
                
    CHK_NULL_POINTER(GSM_PVTUprMskRelList,VI_ERROR_PARAMETER3)

    // allocate enough memory
    cmdString = (ViChar *)malloc((sizeof(ViChar) * GSM_PVTUprMskRelListSz * 16) + 100);
    if(!cmdString) return VI_ERROR_ALLOC;

    sprintf(cmdString, "PVT:MASK:LIST:UPP:REL %.15g", GSM_PVTUprMskRelList[0]);

    // assign the values to the command string
    for (x=1; x<GSM_PVTUprMskRelListSz; x++)
    {
        sprintf(cmdString, "%s,%.15g", cmdString, GSM_PVTUprMskRelList[x]);
    }

    sprintf(cmdString, "%s\n", cmdString);
   
    errStatus = hpesa_cmd(instrumentHandle, cmdString);

    free(cmdString);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_PVTUprMskSetRelLvl                     */
/*****************************************************************************/




/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTUprMskGetRelLvl                                             */
/*                                                                           */
/*      This method retrieves the current set of relative power levels for   */
/*      the horizontal line segments in the upper limit mask for GSM power   */
/*      vs. time measurements.                                               */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_PVTUprMskRelListSzQ                                        */
/*                                                                           */
/*      The size of the array GSM_PVTUprMskRelListQuery.                     */
/*                                                                           */
/*    ViAReal64 GSM_PVTUprMskRelListQuery                                    */
/*                                                                           */
/*      Returns an array containing relative power level for each of the     */
/*      horizontal line segments in the upper limit mask.                    */
/*                                                                           */
/*    ViPInt32 GSM_PVTUprMskRelListActSz                                     */
/*                                                                           */
/*      Returns the actual number of elements returned in                    */
/*      GSM_PVTUprMskRelListQuery.                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTUprMskGetRelLvl
                       (ViSession instrumentHandle,
                        ViInt32 GSM_PVTUprMskRelListSzQ,
                        ViAReal64 GSM_PVTUprMskRelListQuery,
                        ViPInt32 GSM_PVTUprMskRelListActSz)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)


    // check parameters
    CHK_LONG_RANGE(GSM_PVTUprMskRelListSzQ, 
                  1,
                  hpesa_CMDINT32ARR_Q_MAX,
                  VI_ERROR_PARAMETER2)
                
    CHK_NULL_POINTER(GSM_PVTUprMskRelListQuery,VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(GSM_PVTUprMskRelListActSz,VI_ERROR_PARAMETER4)


    errStatus = hpesa_cmdRealCommaArray_Q(instrumentHandle,
                                          "PVT:MASK:LIST:UPP:REL?",
                                          GSM_PVTUprMskRelListSzQ,
                                          GSM_PVTUprMskRelListQuery,
                                          GSM_PVTUprMskRelListActSz);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_PVTUprMskGetRelLvl                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTUprMskSetTimePoints                                         */
/*                                                                           */
/*      This method allows the user to enter the ending points for the       */
/*      horizontal line segments that define the upper limit mask for GSM    */
/*      power vs. time measurements.  All the line segments begin at the     */
/*      time = t 0 reference point at the center of the useful data (usually */
/*      the center of the burst).  For example, all the mask line segments   */
/*      to the right of t 0 will have positive time values that get          */
/*      successively larger, while those to the left get successively more   */
/*      negative.                                                            */
/*                                                                           */
/*      It is recommended that you select a large time value for your first  */
/*      and last mask points (e.g. -1 and +1 second). This guarantees that   */
/*      youve defined a limit for all the measured data.                    */
/*                                                                           */
/*      The range is -1 second to +1 second, referenced to t0 at the center  */
/*      of the useful data (burst center).  There are 1 to 25 time points in */
/*      a mask.                                                              */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_PVTUprMskTimeListSz                                        */
/*                                                                           */
/*      The size of the GSM_PVTUprMskTimeList array.                         */
/*                                                                           */
/*    ViAReal64 GSM_PVTUprMskTimeList                                        */
/*                                                                           */
/*      The array used to set the ending points for the horizontal line      */
/*      segments.                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTUprMskSetTimePoints
                       (ViSession instrumentHandle,
                        ViInt32 GSM_PVTUprMskTimeListSz,
                        ViAReal64 GSM_PVTUprMskTimeList)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    ViChar *cmdString;
    int x=0; // counter

    GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_LONG_RANGE(GSM_PVTUprMskTimeListSz, 
                  1,
                  hpesa_CMDINT32ARR_Q_MAX,
                  VI_ERROR_PARAMETER2)
                
    CHK_NULL_POINTER(GSM_PVTUprMskTimeList,VI_ERROR_PARAMETER3)

    // allocate enough memory
    cmdString = (ViChar *)malloc((sizeof(ViChar) * GSM_PVTUprMskTimeListSz * 16) + 100);
    if(!cmdString) return VI_ERROR_ALLOC;

    sprintf(cmdString, "PVT:MASK:LIST:UPP:TIME %.15g", GSM_PVTUprMskTimeList[0]);

    // assign the values to the command string
    for (x=1; x<GSM_PVTUprMskTimeListSz; x++)
    {
        sprintf(cmdString, "%s,%.15g", cmdString, GSM_PVTUprMskTimeList[x]);
    }

    sprintf(cmdString, "%s\n", cmdString);
   
    errStatus = hpesa_cmd(instrumentHandle, cmdString);

    free(cmdString);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_GSM_PVTUprMskSetTimePoints                   */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PVTUprMskGetTimePoints                                         */
/*                                                                           */
/*      This method retrieves the current ending points for the horizontal   */
/*      line segments that define the upper limit mask for GSM power vs.     */
/*      time measurements.                                                   */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_PVTUprMskTimeListSzQ                                       */
/*                                                                           */
/*      The size of the GSM_PVTUprMskTimeListQuery array.                    */
/*                                                                           */
/*    ViAReal64 GSM_PVTUprMskTimeListQuery                                   */
/*                                                                           */
/*      Returns the current ending points for the horizontal line segments.  */
/*                                                                           */
/*    ViPInt32 GSM_PVTUprMskTimeLstActSz                                     */
/*                                                                           */
/*      Returns the actual number of elements returned in                    */
/*      GSM_PVTUprMskRelListQuery.                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PVTUprMskGetTimePoints
                       (ViSession instrumentHandle,
                        ViInt32 GSM_PVTUprMskTimeListSzQ,
                        ViAReal64 GSM_PVTUprMskTimeListQuery,
                        ViPInt32 GSM_PVTUprMskTimeLstActSz)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;

    GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_LONG_RANGE(GSM_PVTUprMskTimeListSzQ, 
                  1,
                  hpesa_CMDINT32ARR_Q_MAX,
                  VI_ERROR_PARAMETER2)
                
    CHK_NULL_POINTER(GSM_PVTUprMskTimeListQuery,VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(GSM_PVTUprMskTimeLstActSz,VI_ERROR_PARAMETER4)


    errStatus = hpesa_cmdRealCommaArray_Q(instrumentHandle,
                                          "PVT:MASK:LIST:UPP:TIME?",
                                          GSM_PVTUprMskTimeListSzQ,
                                          GSM_PVTUprMskTimeListQuery,
                                          GSM_PVTUprMskTimeLstActSz);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_GSM_PVTUprMskGetTimePoints                   */
/*****************************************************************************/


/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PFERConfigure                                                  */
/*                                                                           */
/*      This method sets up the instrument for GSM Phase and Frequency Error */
/*      (PFER) measurements using the factory default instrument settings    */
/*      and stops the current measurement. It does not initiate the taking   */
/*      of measurement data.                                                 */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PFERConfigure
                       (ViSession instrumentHandle)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = hpesa_cmd(instrumentHandle, ":CONF:PFER");

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_GSM_PFERConfigure                        */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PFERMeasureTrace                                               */
/*                                                                           */
/*      This method measures the modulation quality of the transmitter by    */
/*      checking phase and frequency accuracy.                               */
/*                                                                           */
/*      User can select one of three types of measurement modes: Measure,    */
/*      Read, or Fetch.                                                      */
/*                                                                           */
/*                                                                           */
/*      This method returns the TXP measurement results specified by the     */
/*      "GSM_PVTResultsType" parameter as a real array.                      */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 GSM_PFERMeasureTraceTimeout                                   */
/*                                                                           */
/*      This value temporarily changes the VISA timeout setting for the      */
/*      duration of the instrument measurement. The user needs to set this   */
/*      value to an appropriate time that will be longer then the expected   */
/*      measurement time. Units are in seconds.                              */
/*                                                                           */
/*    ViInt16 GSM_PFERMeasureTraceType                                       */
/*                                                                           */
/*      Selects measurement type. Note that for hpesa_FETCH type the         */
/*      instrument should already be in this measurement mode else the       */
/*      function will time out. User can select this measurement mode by     */
/*      first using the "MEASURE" or "READ" types or call the                */
/*      hpesa_GSM_PFERConfigure function.                                    */
/*                                                                           */
/*      hpesa_MEASURE - Stops current measurement, changes to this selected  */
/*      measurement, sets up instrument using factory defaults, makes        */
/*      measurement, returns measurement results.                            */
/*                                                                           */
/*      hpesa_READ - Stops current measurement,  changes to this selected    */
/*      measurement, uses instrument settings from last measurement of this  */
/*      type, makes measurement, returns measurements results.               */
/*                                                                           */
/*      hpesa_FETCH - Returns measurements results only. No new measurement  */
/*      is initiated.                                                        */
/*                                                                           */
/*    ViInt16 GSM_PFERResultsType                                            */
/*                                                                           */
/*      Determines the format of the data returned in GSM_PFERDataResults.   */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_0:  Returns a series of floating point numbers    */
/*      (in volts) that represent each sample of the complete current time   */
/*      record raw I/Q vector trace length scalar value (giving the total    */
/*      number of I/Q vector sample pairs = n/2).                            */
/*                                                                           */
/*      The II/Q vector sample pair data is organized as:                    */
/*      I(0), Q(0),                                                          */
/*      I(1), Q(1),                                                          */
/*      -------------                                                        */
/*      I([n/2]-1), Q([n/2]-1)                                               */
/*                                                                           */
/*      The start of bit 0 (zero) of the useful part of the measured GSM     */
/*      burst within the vector sample pairs is located at I(x/2), Q(x/2)    */
/*      where x = raw I/Q vector trace index to burst.                       */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_1:  Returns the following 15 scalar values:       */
/*      1. RMS phase error is a floating point number (in degrees) of the    */
/*      rms phase error between the measured phase and the ideal phase. The  */
/*      calculation is based on symbol decision points and points halfway    */
/*      between symbol decision points (that is 2 points/symbol). If         */
/*      averaging is on, this is the average of the individual rms phase     */
/*      error measurements.                                                  */
/*      2. Peak phase error is a floating point number (in degrees) of the   */
/*      peak phase error of all the individual symbol decision points (prior */
/*      to the rms averaging process). If averaging is on, this is the       */
/*      average of the individual peak phase error measurements.             */
/*      3. Peak phase symbol is a floating point number (in symbols)         */
/*      representing the symbol number at which the peak phase error         */
/*      occurred. Averaging does not affect this calculation.                */
/*      4. Frequency error is a floating point number (in Hz) of the         */
/*      frequency error in the measured signal. This is the difference       */
/*      between the measured phase trajectory and the reference phase        */
/*      trajectory. If averaging is on, this is the average of the           */
/*      individual frequency error measurements.                             */
/*      5. I/Q origin offset is a floating point number (in dB) of the I and */
/*      Q error (magnitude squared) offset from the origin. If averaging is  */
/*      on, this is the average of the individual IQ Offset measurements.    */
/*      6. Trace phase sample is a floating point number (in units of bits)  */
/*      representing the time between samples. It is used in querying phase  */
/*      error vector traces.                                                 */
/*      7. Trace bit 0 decision offset is an integer number in units of      */
/*      sample pairs for the sample points in an I/Q vector trace that       */
/*      represents the bit 0 (zero) decision point. The sample pairs in the  */
/*      trace are numbered 0 to N.                                           */
/*      8. Trace sync start is an integer number in units of bits for the    */
/*      bit number, within the data bits trace, that represents the start of */
/*      the sync word.                                                       */
/*      9. Trace time sample is a floating point number (in seconds) of the  */
/*      time between samples. It is used in querying time domain traces. For */
/*      the n=0 trace, of acquired I/Q pairs, this is the time between       */
/*      pairs.                                                               */
/*      10.Phase error trace length is an integer number (in units of        */
/*      samples) representing the number of samples returned by the current  */
/*      phase error trace and phase error with frequency trace.              */
/*      11.RF envelope trace length is an integer number (in units of        */
/*      samples) representing the number of samples returned by the current  */
/*      RF envelope trace.                                                   */
/*      12.RF envelope trace index to burst is an integer number (in units   */
/*      of samples) representing the trace sample which represents the start */
/*      of bit 0 (zero) decision point of the useful part of the measured    */
/*      GSM burst.n=1 (cont)                                                 */
/*      13. I/Q vector trace length is an integer number (in units of        */
/*      samples) representing the number of samples returned by the current  */
/*      RF envelope trace (ie this number divided by two represents the      */
/*      number of sample pairs in the trace.)                                */
/*      14. Raw I/Q vector trace length is an integer number (in units of    */
/*      samples) representing the number of samples returned by the current  */
/*      RF envelope trace (ie this number divided by two represents the      */
/*      number of sample pairs in the trace).                                */
/*      15. Raw I/Q vector trace index to burst is an integer number (in     */
/*      units of samples) representing the trace sample which represents the */
/*      start of bit 0 (zero) decision point of the useful part of the       */
/*      measured GSM burst.                                                  */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_1: Returns a series of floating point numbers (in */
/*      degrees) that represent each sample of the current phase error trace */
/*      data over the useful part of the measured GSM burst. It contains n   */
/*      samples, where n = phase error trace length scalar value. The first  */
/*      sample represents the start of bit 0 (zero) of the useful part of    */
/*      the demodulated burst.                                               */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_3:  Returns a series of floating point numbers    */
/*      (in degrees) that represent each sample of the current phase error   */
/*      with frequency trace data over the useful part of the measured GSM   */
/*      burst. Phase error with frequency is the error vector between the    */
/*      measured phase (that has not had frequency                           */
/*      compensation) and the ideal reference phase. It contains n samples,  */
/*      where n = phase error trace length scalar value. The first sample    */
/*      represents the start of bit 0 (zero) of the useful part of the       */
/*      demodulated burst.                                                   */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_4: Returns a series of floating point numbers (in */
/*      dB relative to peak of signal) that represent each sample of the     */
/*      complete current time record RF envelope trace data. It contains n   */
/*      samples where n =RF envelope trace length scalar value.              */
/*                                                                           */
/*      The start of bit 0 (zero) so the useful part of the measured GSM     */
/*      burst within the sample time record is located at:                   */
/*                                                                           */
/*           I(x), Q(x)                                                      */
/*                                                                           */
/*      where x = RF envelope trace index to burst.                          */
/*                                                                           */
/*    ViAReal64 GSM_PFERDataResults                                          */
/*                                                                           */
/*      Trace data returned by measurement, formatted according to           */
/*      GSM_PFERResultsType.                                                 */
/*                                                                           */
/*    ViInt32 GSM_PFERDataResultsMaxSize                                     */
/*                                                                           */
/*      Specifies the maximum size of GSM_PFERDataResults array.             */
/*                                                                           */
/*    ViPInt32 GSM_PFERDataResultsSize                                       */
/*                                                                           */
/*      Returns the actual size of GSM_PFERDataResults array.                */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PFERMeasureTrace
                       (ViSession instrumentHandle,
                        ViReal64 GSM_PFERMeasureTraceTimeout,
                        ViInt16 GSM_PFERMeasureTraceType,
                        ViInt16 GSM_PFERResultsType,
                        ViAReal64 GSM_PFERDataResults,
                        ViInt32 GSM_PFERDataResultsMaxSize,
                        ViPInt32 GSM_PFERDataResultsSize)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    int PFERValidResults[7] = {1,1,1,1,1,0,0};
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_ENUM(GSM_PFERMeasureTraceType, 0, hpesa_MEASURE_METHOD_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)
    CHK_ENUM(GSM_PFERResultsType, 0, hpesa_RESULTS_TYPE_LASTENUM,
                                                        VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(GSM_PFERDataResults, VI_ERROR_PARAMETER5)
    CHK_NULL_POINTER(GSM_PFERDataResultsSize, VI_ERROR_PARAMETER7)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    if((GSM_PFERResultsType > 6) || (PFERValidResults[GSM_PFERResultsType] == 0))
        return hpesa_INSTR_ERROR_INVALID_RESULTS_TYPE;

    errStatus = GenMeasureTrace(instrumentHandle,
                               hpesa_APPLICATION_MODE_PFER,
                               GSM_PFERMeasureTraceTimeout,
                               GSM_PFERMeasureTraceType,
                               GSM_PFERResultsType,
                               GSM_PFERDataResults,
                               GSM_PFERDataResultsMaxSize,
                               GSM_PFERDataResultsSize);


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_PFERMeasureTrace                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PFERSetAveraging                                               */
/*                                                                           */
/*      This method sets the averaging for GSM phase and frequence error     */
/*      measurements.  User can control the number of averages, turn off or  */
/*      on averaging, set the terminal control mode for averaging, and set   */
/*      the average type.                                                    */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_PFERAverageCount                                           */
/*                                                                           */
/*      Set the number of bursts that will be averaged. After the specified  */
/*      number of bursts (average counts), the averaging mode (terminal      */
/*      control) setting determines the averaging action.                    */
/*                                                                           */
/*    ViBoolean GSM_PFERAverageState                                         */
/*                                                                           */
/*      Sets the state of averaging, either on or off.                       */
/*                                                                           */
/*      VI_TRUE = Averaging on.                                              */
/*      VI_FALSE = Averaging off.                                            */
/*                                                                           */
/*    ViInt16 GSM_PFERAverageMode                                            */
/*                                                                           */
/*      Select the type of termination control used for the averaging        */
/*      function.  This determines the averaging action after the specified  */
/*      number of frames (average count) is reached.                         */
/*                                                                           */
/*      hpesa_AVERAGE_EXPONENTIAL - Each successive data acquisition after   */
/*      the average count is reached, is exponentially weighted and combined */
/*      with the existing average.                                           */
/*                                                                           */
/*      hpesa_AVERAGE_REPEAT - After reaching the average count, the         */
/*      averaging is reset and a new average is started.                     */
/*                                                                           */
/*    ViInt16 GSM_PFERAverageType                                            */
/*                                                                           */
/*      Selects the type of averaging.                                       */
/*                                                                           */
/*      hpesa_AVERAGE_MEAN - the scalar results are averaged.                */
/*      hpesa_AVERAGE_MAX - the maximum scalar results are retained.         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PFERSetAveraging
                       (ViSession instrumentHandle,
                        ViInt32 GSM_PFERAverageCount,
                        ViBoolean GSM_PFERAverageState,
                        ViInt16 GSM_PFERAverageMode,
                        ViInt16 GSM_PFERAverageType)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";

	GET_GLOBALS(instrumentHandle, thisPtr)
	
    // check the input parameters
    CHK_BOOLEAN(GSM_PFERAverageState, VI_ERROR_PARAMETER3)
    CHK_ENUM(GSM_PFERAverageMode,0,hpesa_AVERAGE_MODE_LASTENUM,
												VI_ERROR_PARAMETER4)
	CHK_ENUM(GSM_PFERAverageType, 0, hpesa_AVERAGE_LASTENUM,
												VI_ERROR_PARAMETER5)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	//Set AverageType
	 switch(GSM_PFERAverageType)
    {
        case hpesa_AVERAGE_MEAN:
            sprintf(buffer, ":PFER:AVER:TYPE MEAN");
            break;
        case hpesa_AVERAGE_MAX:
            sprintf(buffer, ":PFER:AVER:TYPE MAX");
            break;
        default:
            fprintf(stderr, "Logic error in hpesa_PFERSetAveraging ");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }
	
	errStatus = hpesa_cmd(instrumentHandle,buffer);
	if(errStatus <VI_SUCCESS) return errStatus;

    errStatus = GenSetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_PFER,
                                GSM_PFERAverageCount,
                                GSM_PFERAverageState,
                                GSM_PFERAverageMode);


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_PFERSetAveraging                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PFERGetAveraging                                               */
/*                                                                           */
/*      This method retrieves the average settings for GSM phase and         */
/*      frequency error measurements.                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt32 GSM_PFERAverageCountQuery                                     */
/*                                                                           */
/*      Returns the current average count.                                   */
/*                                                                           */
/*    ViPBoolean GSM_PFERAverageStateQuery                                   */
/*                                                                           */
/*      Returns the current average state.                                   */
/*                                                                           */
/*      0 = VI_FALSE                                                         */
/*      1 = VI_TRUE                                                          */
/*                                                                           */
/*    ViPInt16 GSM_PFERAverageModeQuery                                      */
/*                                                                           */
/*      Returns the current average mode.                                    */
/*                                                                           */
/*      0 = hpesa_AVERAGE_EXPONENTIAL                                        */
/*      1 = hpesa_AVERAGE_REPEAT                                             */
/*                                                                           */
/*    ViPInt16 GSM_PFERAverageTypeQuery                                      */
/*                                                                           */
/*      Selects the type of averaging.                                       */
/*                                                                           */
/*      0 = hpesa_AVERAGE_MEAN                                               */
/*      1 = hpesa_AVERAGE_MAX                                                */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PFERGetAveraging
                       (ViSession instrumentHandle,
                        ViPInt32 GSM_PFERAverageCountQuery,
                        ViPBoolean GSM_PFERAverageStateQuery,
                        ViPInt16 GSM_PFERAverageModeQuery,
                        ViPInt16 GSM_PFERAverageTypeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_NULL_POINTER(GSM_PFERAverageCountQuery,VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(GSM_PFERAverageStateQuery,VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(GSM_PFERAverageModeQuery, VI_ERROR_PARAMETER4)
	CHK_NULL_POINTER(GSM_PFERAverageTypeQuery, VI_ERROR_PARAMETER5)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = GenGetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_PFER,
                                GSM_PFERAverageCountQuery,
                                GSM_PFERAverageStateQuery,
                                GSM_PFERAverageModeQuery);

	 errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":PFER:AVER:TYPE?",
                                  64, 
                                  buffer);

    if(errStatus<VI_SUCCESS) return errStatus;

	//remove the trailing \n
	buffer[strlen(buffer) - 1] = '\0';

    if(!strcmp(buffer, "MEAN"))
           *GSM_PFERAverageTypeQuery = hpesa_AVERAGE_MEAN;
    else if (!strcmp(buffer, "MAX"))
    	   *GSM_PFERAverageTypeQuery = hpesa_AVERAGE_MAX;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_PFERGetAveraging                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PFERSetTriggerSource                                           */
/*                                                                           */
/*      This method selects the trigger source used to control the data      */
/*      acquisitions for GSM phase and frequence error measurements.         */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_PFERTrigSource                                             */
/*                                                                           */
/*      Sets the trigger source.                                             */
/*                                                                           */
/*      hpesa_PFER_TRIG_EXTERNAL - external trigger input. Uses rear panel.  */
/*                                                                           */
/*      hpesa_PFER_TRIG_FRAME - uses the internal frame timer, which has     */
/*      been synchronized to the selected burst sync.                        */
/*                                                                           */
/*      hpesa_PFER_TRIG_IMMEDIATE - the next data acquisition is immediately */
/*      taken, capturing the signal asynchronously (also called free run).   */
/*                                                                           */
/*      hpesa_PFER_TRIG_RFBURST - internal wideband RF burst envelope        */
/*      trigger that has automatic level control for periodic burst signals. */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PFERSetTriggerSource
                       (ViSession instrumentHandle,
                        ViInt16 GSM_PFERTrigSource)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(GSM_PFERTrigSource, 0, hpesa_TXP_TRIG_LASTENUM, 
                                                   VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    switch(GSM_PFERTrigSource)
    {
        case hpesa_PFER_TRIG_IMMEDIATE:
            sprintf(buffer, ":PFER:TRIG:SOUR IMM");
            break;
        case hpesa_PFER_TRIG_EXTERNAL:
            sprintf(buffer, ":PFER:TRIG:SOUR EXT");
            break;
		case hpesa_PFER_TRIG_RFBURST:
            sprintf(buffer, ":PFER:TRIG:SOUR RFB");
            break;
		case hpesa_PFER_TRIG_FRAME:
            sprintf(buffer, ":PFER:TRIG:SOUR FRAM");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_PFERSetTriggerSource");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, buffer);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_GSM_PFERSetTriggerSource                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PFERGetTriggerSource                                           */
/*                                                                           */
/*      This method retrieves the current trigger source for GSM phase and   */
/*      frequency error measurements.                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSM_PFERTrigSourceQuery                                       */
/*                                                                           */
/*      Returns the current trigger source.                                  */
/*                                                                           */
/*      0 = hpesa_PFER_TRIG_IMMEDIATE                                        */
/*      1 = hpesa_PFER_TRIG_EXTERNAL                                         */
/*      2 = hpesa_PFER_TRIG_RFBURST                                          */
/*      3 - hpesa_PFER_TRIG_FRAME                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PFERGetTriggerSource
                       (ViSession instrumentHandle,
                        ViPInt16 GSM_PFERTrigSourceQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(GSM_PFERTrigSourceQuery, VI_ERROR_PARAMETER2)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Retrieve the external trigger slope
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":PFER:TRIG:SOUR?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0';  // strip the trailing \n

    if(!strcmp(buffer, "IMM"))
        *GSM_PFERTrigSourceQuery = hpesa_PFER_TRIG_IMMEDIATE;
    else if (!strcmp(buffer, "EXT"))
        *GSM_PFERTrigSourceQuery = hpesa_PFER_TRIG_EXTERNAL;
	else if (!strcmp(buffer, "RFB"))
		*GSM_PFERTrigSourceQuery = hpesa_PFER_TRIG_RFBURST;
	else if (!strcmp(buffer, "FRAM"))
		*GSM_PFERTrigSourceQuery = hpesa_PFER_TRIG_FRAME;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_GSM_PFERGetTriggerSource                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PFERSetBurstSync                                               */
/*                                                                           */
/*      This method selects the method of synchronizing the phase and        */
/*      frequency error measurement to the GSM bursts.                       */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_PFERBurstSync                                              */
/*                                                                           */
/*      Sets the burst synchronization.                                      */
/*                                                                           */
/*      hpesa_BURST_SYNC_TSEQ - the training sequence burst sync performs a  */
/*      demodulation of the burst and determines the start and stop of the   */
/*      useful part of the burst based on the midamble training sequence.    */
/*                                                                           */
/*      hpesa_BURST_SYNC_RFAMP - the RF amplitude burst sync approximates    */
/*      the start and stop of the useful part of the burst without           */
/*      demodulation of the burst.                                           */
/*                                                                           */
/*																	         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PFERSetBurstSync
                       (ViSession instrumentHandle,
                        ViInt16 GSM_PFERBurstSync)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[256] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	CHK_ENUM(GSM_PFERBurstSync, 0, hpesa_BURST_SYNC_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)
	switch(GSM_PFERBurstSync)
    {
        case hpesa_BURST_SYNC_TSEQ:
            sprintf(buffer, ":PFER:BSYNC:SOUR TSEQ");
            break;
        case hpesa_BURST_SYNC_RFAMP:
            sprintf(buffer, ":PFER:BSYNC:SOUR RFAM");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_PFERSetBurstSync");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }
	errStatus = hpesa_cmd(instrumentHandle, buffer);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_PFERSetBurstSync                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_PFERGetBurstSync                                               */
/*                                                                           */
/*      This method retrieves the current method of synchronizing the phase  */
/*      and frequency error measurement to the GSM bursts.                   */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSM_PFERBurstSyncQuery                                        */
/*                                                                           */
/*      Returns the current burst sync source.                               */
/*                                                                           */
/*      0 = hpesa_BURST_SYNC_TSEQ                                            */
/*      1 = hpesa_BURST_SYNC_RFAMP                                           */
/*                                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_PFERGetBurstSync
                       (ViSession instrumentHandle,
                        ViPInt16 GSM_PFERBurstSyncQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    //Check parameters
	CHK_NULL_POINTER(GSM_PFERBurstSyncQuery, VI_ERROR_PARAMETER2)
	
    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Retrieve the Threshold Type
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":PFER:BSYNC:SOUR?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0';  // strip the trailing \n

    if(!strcmp(buffer, "TSEQ"))
        *GSM_PFERBurstSyncQuery = hpesa_BURST_SYNC_TSEQ;
    else if (!strcmp(buffer, "RFAM"))
        *GSM_PFERBurstSyncQuery = hpesa_BURST_SYNC_RFAMP;
	else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_PFERGetBurstSync                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSConfigure                                                  */
/*                                                                           */
/*      This method sets up the instrument for Output RF Spectrum (ORFS)     */
/*      measurements using the factory default instrument settings and stops */
/*      the current measurement. It does not initiate the taking of          */
/*      measurement data.                                                    */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSConfigure
                       (ViSession instrumentHandle)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = hpesa_cmd(instrumentHandle, ":CONF:ORFS");

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_GSM_ORFSConfigure                        */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSMeasureTrace                                               */
/*                                                                           */
/*      This measures adjacent channel power for GSM measurements. From 1 to */
/*      15 offsets can be measured at one time.                              */
/*                                                                           */
/*      User can select one of three types of measurement modes: Measure,    */
/*      Read, or Fetch.                                                      */
/*                                                                           */
/*                                                                           */
/*      This method returns the ORFS measurement results specified by the    */
/*      "GSM_ORFSResultsType" parameter as a real array.                     */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 GSM_ORFSMeasureTraceTimeout                                   */
/*                                                                           */
/*      This value temporarily changes the VISA timeout setting for the      */
/*      duration of the instrument measurement. The user needs to set this   */
/*      value to an appropriate time that will be longer then the expected   */
/*      measurement time. Units are in seconds.                              */
/*                                                                           */
/*    ViInt16 GSM_ORFSMeasureTraceType                                       */
/*                                                                           */
/*      Selects measurement type. Note that for hpesa_FETCH type the         */
/*      instrument should already be in this measurement mode else the       */
/*      function will time out. User can select this measurement mode by     */
/*      first using the "MEASURE" or "READ" types or call the                */
/*      hpesa_GSM_ORFSConfigure function.                                    */
/*                                                                           */
/*      hpesa_MEASURE - Stops current measurement, changes to this selected  */
/*      measurement, sets up instrument using factory defaults, makes        */
/*      measurement, returns measurement results.                            */
/*                                                                           */
/*      hpesa_READ - Stops current measurement,  changes to this selected    */
/*      measurement, uses instrument settings from last measurement of this  */
/*      type, makes measurement, returns measurements results.               */
/*                                                                           */
/*      hpesa_FETCH - Returns measurements results only. No new measurement  */
/*      is initiated.                                                        */
/*                                                                           */
/*    ViInt16 GSM_ORFSResultsType                                            */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_0 - Not supported by instrument.                  */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_1 (Multiple Offsets) - Returns a list of          */
/*      comma-separated values for the modulation spectrum at all the        */
/*      offsets (lower and upper.) This is followed by the switching         */
/*      transients results at all the offsets (lower and upper). Note that   */
/*      the carrier is considered offset zero (0) and is the first set of    */
/*      results sent. Four values are provided for each of the offsets       */
/*      (including the carrier), in this order:                              */
/*                                                                           */
/*      1. Negative offset(a) - power relative to carrier (dB)               */
/*      2. Negative offset(a) - absolute average power (dBm)                 */
/*      3. Positive offset(a) - power relative to carrier (dB)               */
/*      4. Positive offset(a) - absolute average power (dBm)                 */
/*                                                                           */
/*      Values for all possible offsets are sent. Zeros are sent for offsets */
/*      that have not been defined. The total number of values sent (120) =  */
/*      (4 results/offset)  (15 offsets)  (2 measurement types -           */
/*      modulation & switching)                                              */
/*                                                                           */
/*      Carrier - modulation measurement values                              */
/*      Offset 1 - modulation measurement values and so on                   */
/*      Offset 14 - modulation measurement values                            */
/*      Carrier - switching transients measurement values                    */
/*      Offset 16 - switching transients measurement values                  */
/*      Offset 29 - switching transients measurement values and              */
/*      so on                                                                */
/*                                                                           */
/*      This measurement defaults to modulation measurements and not         */
/*      switching measurements. If you want to return the switching          */
/*      measurement values, you must change that default condition and use   */
/*      FETCH or READ to return values, rather than MEASURE.                 */
/*                                                                           */
/*      NOTE: When using custom modulation and switching offsets the maximum */
/*      number of measured values returned is:                               */
/*      13 modulation offsets + 0 Hz carrier                                 */
/*      4 switching offsets + 0 Hz carrier                                   */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_1 (Single offset) - Returns 4 comma-separated     */
/*      results for the specified offset:                                    */
/*                                                                           */
/*      1. Modulation spectrum power, dBc                                    */
/*      2. Modulation spectrum power, dBm                                    */
/*      3. Switching transient power, dBc                                    */
/*      4. Switching transient power, dBm                                    */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_1 (Swept) - Returns l boolean value: 1 if limits  */
/*      passed, 0 if limits failed.                                          */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_2 (Single offset) -  Returns floating point       */
/*      numbers (in dBm) of the captured trace data. It contains 401 data    */
/*      points of the "spectrum due to modulation" signal. Single offset 3   */
/*      Returns floating point numbers (in dBm) of the captured trace data.  */
/*      It contains 401 points of the "spectrum due to switching transients" */
/*      signal.                                                              */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_2 (Swept) - Returns floating point numbers (in    */
/*      dBm) of the captured trace data. It contains 401 points of the       */
/*      "spectrum due to modulation" signal.                                 */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_3 (Single offset) - Returns floating point        */
/*      numbers (in dBm) of the captured trace data. It contains 401 points  */
/*      of the "spectrum due to switching transients" signal.                */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_3 (Swept) - Returns floating point numbers (in    */
/*      dBm) of the captured trace data. It contains 401 points of the       */
/*      "spectrum due to switching transients" signal.                       */
/*                                                                           */
/*    ViAReal64 GSM_ORFSDataResults                                          */
/*                                                                           */
/*      Trace data returned by measurement, formatted according to           */
/*      GSM_ORFSResultsType.                                                 */
/*                                                                           */
/*    ViInt32 GSM_ORFSDataResultsMaxSize                                     */
/*                                                                           */
/*      Specifies the maximum size of GSM_ORFSDataResults array.             */
/*                                                                           */
/*    ViPInt32 GSM_ORFSDataResultsSize                                       */
/*                                                                           */
/*      Returns the actual size of GSM_ORFSDataResults array.                */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSMeasureTrace
                       (ViSession instrumentHandle,
                        ViReal64 GSM_ORFSMeasureTraceTimeout,
                        ViInt16 GSM_ORFSMeasureTraceType,
                        ViInt16 GSM_ORFSResultsType,
                        ViAReal64 GSM_ORFSDataResults,
                        ViInt32 GSM_ORFSDataResultsMaxSize,
                        ViPInt32 GSM_ORFSDataResultsSize)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    int ORFSValidResults[7] = {0,1,1,1,0,0,0};
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_ENUM(GSM_ORFSMeasureTraceType, 0, hpesa_MEASURE_METHOD_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)
    CHK_ENUM(GSM_ORFSResultsType, 0, hpesa_RESULTS_TYPE_LASTENUM,
                                                        VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(GSM_ORFSDataResults, VI_ERROR_PARAMETER5)
    CHK_NULL_POINTER(GSM_ORFSDataResultsSize, VI_ERROR_PARAMETER7)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    if((GSM_ORFSResultsType > 6) || (ORFSValidResults[GSM_ORFSResultsType] == 0))
        return hpesa_INSTR_ERROR_INVALID_RESULTS_TYPE;

    errStatus = GenMeasureTrace(instrumentHandle,
                               hpesa_APPLICATION_MODE_ORFS,
                               GSM_ORFSMeasureTraceTimeout,
                               GSM_ORFSMeasureTraceType,
                               GSM_ORFSResultsType,
                               GSM_ORFSDataResults,
                               GSM_ORFSDataResultsMaxSize,
                               GSM_ORFSDataResultsSize);


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_ORFSMeasureTrace                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSSetAveraging                                               */
/*                                                                           */
/*      This method sets the averaging for GSM power vs. time measurements.  */
/*      User can control the number of averages, turn off or on averaging,   */
/*      and set the terminal control mode for averaging.                     */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_ORFSAverageCount                                           */
/*                                                                           */
/*      Set the number of bursts that will be averaged. For the output RF    */
/*      spectrum due to switching transients, it is more accurate to         */
/*      consider this the number of frames that are measured. After the      */
/*      specified number of bursts (average counts), the averaging mode      */
/*      (terminal control) setting determines the averaging action.          */
/*                                                                           */
/*    ViBoolean GSM_ORFSAverageState                                         */
/*                                                                           */
/*      Sets the state of averaging, either on or off.                       */
/*                                                                           */
/*      VI_TRUE = Averaging on.                                              */
/*      VI_FALSE = Averaging off.                                            */
/*                                                                           */
/*    ViInt16 GSM_ORFSAverageMode                                            */
/*                                                                           */
/*      Select the type of termination control used for the averaging        */
/*      function.  This determines the averaging action after the specified  */
/*      number of frames (average count) is reached.                         */
/*                                                                           */
/*      hpesa_AVERAGE_EXPONENTIAL - Each successive data acquisition after   */
/*      the average count is reached, is exponentially weighted and combined */
/*      with the existing average.                                           */
/*                                                                           */
/*      hpesa_AVERAGE_REPEAT - After reaching the average count, the         */
/*      averaging is reset and a new average is started.                     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSSetAveraging
                       (ViSession instrumentHandle,
                        ViInt32 GSM_ORFSAverageCount,
                        ViBoolean GSM_ORFSAverageState,
                        ViInt16 GSM_ORFSAverageMode)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";

	GET_GLOBALS(instrumentHandle, thisPtr)
	
    // check the input parameters
    CHK_BOOLEAN(GSM_ORFSAverageState, VI_ERROR_PARAMETER3)
    CHK_ENUM(GSM_ORFSAverageMode,0,hpesa_AVERAGE_MODE_LASTENUM,
												VI_ERROR_PARAMETER4)
	
    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	errStatus = GenSetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_ORFS,
                                GSM_ORFSAverageCount,
                                GSM_ORFSAverageState,
                                GSM_ORFSAverageMode);



    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_ORFSSetAveraging                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSGetAveraging                                               */
/*                                                                           */
/*      This method retrieves the average settings for GSM output RF         */
/*      spectrum measurements.                                               */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt32 GSM_ORFSAverageCountQuery                                     */
/*                                                                           */
/*      Returns the current average count.                                   */
/*                                                                           */
/*    ViPBoolean GSM_ORFSAverageStateQuery                                   */
/*                                                                           */
/*      Returns the current average state.                                   */
/*                                                                           */
/*      0 = VI_FALSE                                                         */
/*      1 = VI_TRUE                                                          */
/*                                                                           */
/*    ViPInt16 GSM_ORFSAverageModeQuery                                      */
/*                                                                           */
/*      Returns the current average mode.                                    */
/*                                                                           */
/*      0 = hpesa_AVERAGE_EXPONENTIAL                                        */
/*      1 = hpesa_AVERAGE_REPEAT                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSGetAveraging
                       (ViSession instrumentHandle,
                        ViPInt32 GSM_ORFSAverageCountQuery,
                        ViPBoolean GSM_ORFSAverageStateQuery,
                        ViPInt16 GSM_ORFSAverageModeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_NULL_POINTER(GSM_ORFSAverageCountQuery,VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(GSM_ORFSAverageStateQuery,VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(GSM_ORFSAverageModeQuery, VI_ERROR_PARAMETER4)
	
    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = GenGetAveraging(instrumentHandle,
                                hpesa_APPLICATION_MODE_ORFS,
                                GSM_ORFSAverageCountQuery,
                                GSM_ORFSAverageStateQuery,
                                GSM_ORFSAverageModeQuery);

	if(errStatus <VI_SUCCESS) return errStatus;
    
	return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_ORFSGetAveraging                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSSetMeasurementMode                                         */
/*                                                                           */
/*      This method selects the measurement method to be used with GSM       */
/*      output RF spectrum measurements.                                     */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_ORFSMeasMode                                               */
/*                                                                           */
/*      Selects the measurement method to be used.                           */
/*                                                                           */
/*      hpesa_ORFS_MEASURE_MULTIPLE - the measurement is done at all offsets */
/*      in the offset frequency list.                                        */
/*                                                                           */
/*      hpesa_ORFS_MEASURE_SINGLE - the measurement is done at only one      */
/*      offset as determined by the offset frequency setting. This allows    */
/*      detailed examination of the time-domain waveform at the specified    */
/*      offset frequency.                                                    */
/*                                                                           */
/*      hpesa_ORFS_MEASURE_SWEPT - the measurement is done in the frequency  */
/*      domain. For output RF spectrum due to modulation it is done using    */
/*      time-gated spectrum analysis to sweep the analyzer with the gate     */
/*      turned on for the desired portion of the burst only.                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSSetMeasurementMode
                       (ViSession instrumentHandle,
                        ViInt16 GSM_ORFSMeasMode)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[256] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	CHK_ENUM(GSM_ORFSMeasMode, 0, hpesa_ORFS_MEASURE_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)
	switch(GSM_ORFSMeasMode)
    {
        case hpesa_ORFS_MEASURE_MULTIPLE:
            sprintf(buffer, ":ORFS:MEAS MULT");
            break;
        case hpesa_ORFS_MEASURE_SINGLE:
            sprintf(buffer, ":ORFS:MEAS SING");
            break;
        case hpesa_ORFS_MEASURE_SWEPT:
            sprintf(buffer, ":ORFS:MEAS SWEP");
            break;
        default:
            fprintf(stderr, "Logic error in hpesa_GSM_ORFSSetMeasurementMode");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }
	
	errStatus = hpesa_cmd(instrumentHandle, buffer);

	if (errStatus < VI_SUCCESS) return errStatus;
	
    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_GSM_ORFSSetMeasurementMode                   */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSGetMeasurementMode                                         */
/*                                                                           */
/*      This method retrieves the current measurement method for GSM output  */
/*      RF spectrum measurements                                             */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSM_ORFSMeasModeQuery                                         */
/*                                                                           */
/*      Returns the current measurement method.                              */
/*                                                                           */
/*      0 = hpesa_ORFS_MEASURE_MULTIPLE                                      */
/*      1 = hpesa_ORFS_MEASURE_SINGLE                                        */
/*      2 = hpesa_ORFS_MEASURE_SWEPT                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSGetMeasurementMode
                       (ViSession instrumentHandle,
                        ViPInt16 GSM_ORFSMeasModeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(GSM_ORFSMeasModeQuery, VI_ERROR_PARAMETER2)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Retrieve the current measurement method
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":ORFS:MEAS?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0';  // strip the trailing \n

    if(!strcmp(buffer, "MULT"))
        *GSM_ORFSMeasModeQuery = hpesa_ORFS_MEASURE_MULTIPLE;
    else if (!strcmp(buffer, "SING"))
        *GSM_ORFSMeasModeQuery = hpesa_ORFS_MEASURE_SINGLE;
	else if (!strcmp(buffer, "SWEP"))
		*GSM_ORFSMeasModeQuery = hpesa_ORFS_MEASURE_SWEPT;
	else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_GSM_ORFSGetMeasurementMode                   */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSSetMeasurementType                                         */
/*                                                                           */
/*      This method selects the measurement type for GSM output RF spectrum  */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_ORFSMeasType                                               */
/*                                                                           */
/*      Selects the measurement type.                                        */
/*                                                                           */
/*      hpesa_ORFS_TYPE_MOD - only the modulation spectrum is measured.      */
/*      hpesa_ORFS_TYPE_SWITCH - only the switching transient spectrum is    */
/*      measured.                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSSetMeasurementType
                       (ViSession instrumentHandle,
                        ViInt16 GSM_ORFSMeasType)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[256] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	//Check input parameters	
	CHK_ENUM(GSM_ORFSMeasType, 0, hpesa_ORFS_TYPE_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)
	//Set measurement type
	switch(GSM_ORFSMeasType)
    {
        case hpesa_ORFS_TYPE_MOD:
            sprintf(buffer, ":ORFS:TYPE MOD");
            break;
        case hpesa_ORFS_TYPE_SWITCH:
            sprintf(buffer, ":ORFS:TYPE SWIT");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_ORFSSetMeasurementType");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }
	errStatus = hpesa_cmd(instrumentHandle, buffer);

	if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_GSM_ORFSSetMeasurementType                   */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSGetMeasurementType                                         */
/*                                                                           */
/*      This method retrieves the current measurement type for output RF     */
/*      spectrum measurements.                                               */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSM_ORFSMeasTypeQuery                                         */
/*                                                                           */
/*      Returns the current measurement type.                                */
/*                                                                           */
/*      0 = hpesa_ORFS_TYPE_MOD                                              */
/*      1 = hpesa_ORFS_TYPE_SWITCH                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSGetMeasurementType
                       (ViSession instrumentHandle,
                        ViPInt16 GSM_ORFSMeasTypeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    //check for null pointer
	CHK_NULL_POINTER(GSM_ORFSMeasTypeQuery,VI_ERROR_PARAMETER2)

    //check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    //Retrieve the Measurement Type
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":ORFS:TYPE?",
                                  64, 
                                  buffer);

    if(errStatus<VI_SUCCESS) return errStatus;

	//remove the trailing \n
	buffer[strlen(buffer) - 1] = '\0';

    if(!strcmp(buffer, "MOD"))
           *GSM_ORFSMeasTypeQuery = hpesa_ORFS_TYPE_MOD;
    else if (!strcmp(buffer, "SWIT"))
    	   *GSM_ORFSMeasTypeQuery = hpesa_ORFS_TYPE_SWITCH;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_ORFSGetMeasurementType                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSSetOffsetFreqList                                          */
/*                                                                           */
/*      This method select the list of frequency offsets and bandwidths to   */
/*      be used to make the ORFS measurement. Frequency offsets are used     */
/*      only in ORFS multiple measurement method for both ORFS due to        */
/*      modulation and switching transients.                                 */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_ORFSOffsetListType                                         */
/*                                                                           */
/*      Select the list of frequency offsets and bandwidths to be used to    */
/*      make the ORFS measurement. Frequency offsets are used only in ORFS   */
/*      multiple measurement method for both ORFS due to modulation and      */
/*      switching transients.                                                */
/*                                                                           */
/*      hpesa_ORFS_OFFSET_STANDARD - the complete list of the offset         */
/*      frequencies specified in the GSM Standards, except for those offsets */
/*      greater than 6 MHz. It uses two internal offset frequency lists, one */
/*      for modulation spectrum and the other for switching transient        */
/*      spectrum. These offset frequencies cannot be changed, but the        */
/*      resolution bandwidths can be changed by other commands in the        */
/*      SENSe:ORFSpectrum subsystem.                                         */
/*                                                                           */
/*      hpesa_ORFS_OFFSET_SHORT - a shortened list of the offset frequencies */
/*      specified in the GSM Standards. It uses two internal offset          */
/*      frequency lists, one for modulation spectrum and the other for       */
/*      switching transient spectrum. These offset frequencies cannot be     */
/*      changed, but the resolution bandwidths can be changed by other       */
/*      commands in the SENSe:ORFSpectrum subsystem.                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSSetOffsetFreqList
                       (ViSession instrumentHandle,
                        ViInt16 GSM_ORFSOffsetListType)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[256] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	//Check input parameters	
	CHK_ENUM(GSM_ORFSOffsetListType, 0, hpesa_ORFS_OFFSET_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)
	//Set measurement type
	switch(GSM_ORFSOffsetListType)
    {
        case hpesa_ORFS_OFFSET_STANDARD:
            sprintf(buffer, ":ORFS:LIST:SEL STAN ");
            break;
        case hpesa_ORFS_OFFSET_SHORT:
            sprintf(buffer, ":ORFS:LIST:SEL SHOR ");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_ORFSSetOffsetFreqList");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }
	errStatus = hpesa_cmd(instrumentHandle, buffer);

	if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_GSM_ORFSSetOffsetFreqList                    */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSGetOffsetFreqList                                          */
/*                                                                           */
/*      This method retrieves the current offset frequency list type for     */
/*      output RF spectrum measurements.                                     */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSM_ORFSOffsetListTypeQuery                                   */
/*                                                                           */
/*      Returns the current offset frequency list type.                      */
/*                                                                           */
/*      0 = hpesa_ORFS_OFFSET_STANDARD                                       */
/*      1 = hpesa_ORFS_OFFSET_SHORT                                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSGetOffsetFreqList
                       (ViSession instrumentHandle,
                        ViPInt16 GSM_ORFSOffsetListTypeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    //check for null pointer
	CHK_NULL_POINTER(GSM_ORFSOffsetListTypeQuery,VI_ERROR_PARAMETER2)

    //check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    //Retrieve the Measurement Type
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":ORFS:LIST:SEL?",
                                  64, 
                                  buffer);

    if(errStatus<VI_SUCCESS) return errStatus;

	//remove the trailing \n
	buffer[strlen(buffer) - 1] = '\0';

    if(!strcmp(buffer, "STAN"))
           *GSM_ORFSOffsetListTypeQuery = hpesa_ORFS_OFFSET_STANDARD;
    else if (!strcmp(buffer, "SHOR"))
    	   *GSM_ORFSOffsetListTypeQuery = hpesa_ORFS_OFFSET_SHORT;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_GSM_ORFSGetOffsetFreqList                    */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSSetOffsetFreq                                              */
/*                                                                           */
/*      This method sets the offset frequency that is used to measure a      */
/*      single offset.  This function is only valid if the measurement       */
/*      method is set to single offset via hpesa_GSM_ORFSSetMeasurementMode. */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 GSM_ORFSOffsetFreq                                            */
/*                                                                           */
/*      Sets the offset frequency.                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSSetOffsetFreq
                       (ViSession instrumentHandle,
                        ViReal64 GSM_ORFSOffsetFreq)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    //Set the offset Frequency
	errStatus = hpesa_cmdReal(instrumentHandle, 
                              ":ORFS:OFR", 
                                GSM_ORFSOffsetFreq);

	if (errStatus <VI_SUCCESS) return errStatus;


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_ORFSSetOffsetFreq                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSGetOffsetFreq                                              */
/*                                                                           */
/*      Returns the current offset frequency being used to measure a single  */
/*      offset for GSM output RF spectrum measurements.                      */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPReal64 GSM_ORFSOffsetFreqQuery                                      */
/*                                                                           */
/*      Returns the current offset frequency.                                */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSGetOffsetFreq
                       (ViSession instrumentHandle,
                        ViPReal64 GSM_ORFSOffsetFreqQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_NULL_POINTER(GSM_ORFSOffsetFreqQuery,VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    //Retrieve the current offsetfrequency
	errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  ":ORFS:OFR?", 
                                 GSM_ORFSOffsetFreqQuery);

	if(errStatus < VI_SUCCESS) return errStatus;


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_ORFSGetOffsetFreq                      */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSSetTriggerSource                                           */
/*                                                                           */
/*      This method sets the trigger source for GSM output RF spectrum       */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_ORFSTriggerSource                                          */
/*                                                                           */
/*      Select the trigger source used to control the data acquisitions.     */
/*                                                                           */
/*      hpesa_ORFS_TRIG_IMMEDIATE - the next data acquisition is immediately */
/*      taken, capturing the signal asynchronously (also called free run)    */
/*                                                                           */
/*      hpesa_ORFS_TRIG_EXTERNAL - front panel external trigger input        */
/*                                                                           */
/*      hpesa_ORFS_TRIG_RFBURST - internal wideband RF burst envelope        */
/*      trigger that has automatic level control for periodic burst signals  */
/*                                                                           */
/*      hpesa_ORFS_TRIG_FRAME - uses the internal frame timer, which has     */
/*      been synchronized to the selected burst sync                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSSetTriggerSource
                       (ViSession instrumentHandle,
                        ViInt16 GSM_ORFSTriggerSource)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    CHK_ENUM(GSM_ORFSTriggerSource, 0, hpesa_ORFS_TRIG_LASTENUM, 
                                                   VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    switch(GSM_ORFSTriggerSource)
    {
        case hpesa_ORFS_TRIG_IMMEDIATE:
            sprintf(buffer, ":ORFS:TRIG:SOUR IMM");
            break;
        case hpesa_ORFS_TRIG_EXTERNAL:
            sprintf(buffer, ":ORFS:TRIG:SOUR EXT");
            break;
		case hpesa_ORFS_TRIG_RFBURST:
            sprintf(buffer, ":ORFS:TRIG:SOUR RFB");
            break;
		case hpesa_ORFS_TRIG_FRAME:
            sprintf(buffer, ":ORFS:TRIG:SOUR FRAM");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_ORFSSetTriggerSource");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    errStatus = hpesa_cmd(instrumentHandle, buffer);

	if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_GSM_ORFSSetTriggerSource                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSGetTriggerSource                                           */
/*                                                                           */
/*      This method retrieves the current trigger source for output RF       */
/*      spectrum measurements.                                               */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSM_ORFSTriggerSourceQuery                                    */
/*                                                                           */
/*      Returns the current trigger source.                                  */
/*                                                                           */
/*      0 = hpesa_ORFS_TRIG_IMMEDIATE                                        */
/*      1 = hpesa_ORFS_TRIG_EXTERNAL                                         */
/*      2 = hpesa_ORFS_TRIG_RFBURST                                          */
/*      3 = hpesa_ORFS_TRIG_FRAME                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSGetTriggerSource
                       (ViSession instrumentHandle,
                        ViPInt16 GSM_ORFSTriggerSourceQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)
    CHK_NULL_POINTER(GSM_ORFSTriggerSourceQuery, VI_ERROR_PARAMETER2)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Retrieve the external trigger slope
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":ORFS:TRIG:SOUR?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0';  // strip the trailing \n

    if(!strcmp(buffer, "IMM"))
        *GSM_ORFSTriggerSourceQuery = hpesa_ORFS_TRIG_IMMEDIATE;
    else if (!strcmp(buffer, "EXT"))
        *GSM_ORFSTriggerSourceQuery = hpesa_ORFS_TRIG_EXTERNAL;
	else if (!strcmp(buffer, "RFB"))
		*GSM_ORFSTriggerSourceQuery = hpesa_ORFS_TRIG_RFBURST;
	else if (!strcmp(buffer, "FRAM"))
		*GSM_ORFSTriggerSourceQuery = hpesa_ORFS_TRIG_FRAME;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_GSM_ORFSGetTriggerSource                     */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSSetBurstSync                                               */
/*                                                                           */
/*      This method sets the method of synchronizing the output RF spectrum  */
/*      measurement to the GSM bursts.                                       */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_ORFSBurstSyncSource                                        */
/*                                                                           */
/*      Select the method of synchronizing the measurement to the GSM        */
/*      bursts.                                                              */
/*                                                                           */
/*      hpesa_BURST_SYNC_TSEQ - the training sequence burst sync performs a  */
/*      demodulation of the burst and determines the start and stop of the   */
/*      useful part of the burst based on the midamble training sequence.    */
/*                                                                           */
/*      hpesa_BURST_SYNC_RFAMP - the RF amplitude burst synch approximates   */
/*      the start and stop of the useful part of the burst without digital   */
/*      demodulation of the burst.                                           */
/*                                                                           */
/*      hpesa_BURST_SYNC_NONE - performs no burst synchronization.           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSSetBurstSync
                       (ViSession instrumentHandle,
                        ViInt16 GSM_ORFSBurstSyncSource)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[256] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	//check parameters
	CHK_ENUM(GSM_ORFSBurstSyncSource, 0, hpesa_BURST_SYNC_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)
	
	//Set Burst Sync
	switch(GSM_ORFSBurstSyncSource)
    {
        case hpesa_BURST_SYNC_TSEQ:
            sprintf(buffer, ":ORFS:BSYNC:SOUR TSEQ");
            break;
        case hpesa_BURST_SYNC_RFAMP:
            sprintf(buffer, ":ORFS:BSYNC:SOUR RFAM");
            break;
		case hpesa_BURST_SYNC_NONE:
            sprintf(buffer, ":ORFS:BSYNC:SOUR NONE");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_ORFSSetBurstSync");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }
	errStatus = hpesa_cmd(instrumentHandle, buffer);

	if(errStatus <VI_SUCCESS) return errStatus;

	return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_ORFSSetBurstSync                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSGetBurstSync                                               */
/*                                                                           */
/*      This method retrieves the current burst sync source for GSM output   */
/*      RF spectrum measurements.                                            */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSM_ORFSBurstSyncSourceQuer                                   */
/*                                                                           */
/*      Returns the current burst sync source.                               */
/*                                                                           */
/*      0 = hpesa_BURST_SYNC_TSEQ                                            */
/*      1 = hpesa_BURST_SYNC_RFAMP                                           */
/*      2 = hpesa_BURST_SYNC_NONE                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSGetBurstSync
                       (ViSession instrumentHandle,
                        ViPInt16 GSM_ORFSBurstSyncSourceQ)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    //Check parameters
	CHK_NULL_POINTER(GSM_ORFSBurstSyncSourceQ, VI_ERROR_PARAMETER2)
	
    VERIFY_APP(hpesa_APPLICATION_GSM)

    // Retrieve the Burst Sync Type
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":ORFS:BSYNC:SOUR?",
                                  64, 
                                  buffer);
    if(errStatus<VI_SUCCESS) return errStatus;

    buffer[strlen(buffer) - 1] = '\0';  // strip the trailing \n

    if(!strcmp(buffer, "TSEQ"))
        *GSM_ORFSBurstSyncSourceQ = hpesa_BURST_SYNC_TSEQ;
    else if (!strcmp(buffer, "RFAM"))
        *GSM_ORFSBurstSyncSourceQ = hpesa_BURST_SYNC_RFAMP;
	else if (!strcmp(buffer, "NONE"))
        *GSM_ORFSBurstSyncSourceQ = hpesa_BURST_SYNC_NONE;
	else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                      end hpesa_GSM_ORFSGetBurstSync                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSSetWidebandNoiseMode                                       */
/*                                                                           */
/*      This method sets wideband noise function to ON or OFF. When set to   */
/*      OFF, the analyzer is tuned to the carrier and -1800 kHz to +1800 kHz */
/*      either side of the center frequency is swept. When set to ON, the    */
/*      whole of the relevant band 2 MHz either side is swept.               */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViBoolean GSM_ORFS_WBNoise                                             */
/*                                                                           */
/*      Sets wideband noise state.                                           */
/*                                                                           */
/*      VI_TRUE - Sets wideband noise funciton on.                           */
/*      VI_FALSE - Sets wideband noise function off.                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSSetWidebandNoiseMode
                       (ViSession instrumentHandle,
                        ViBoolean GSM_ORFS_WBNoise)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    ViInt16 MeasMode = 0;
	    
    GET_GLOBALS(instrumentHandle, thisPtr)

	//Check parameters
	CHK_BOOLEAN(GSM_ORFS_WBNoise, VI_ERROR_PARAMETER2)

	//Verify Application
	VERIFY_APP(hpesa_APPLICATION_GSM)

    //First, verify that were are in Swept measurement mode
    errStatus = hpesa_GSM_ORFSGetMeasurementMode(instrumentHandle,
                                                 &MeasMode);
	if(errStatus < VI_SUCCESS) return errStatus;

	//Set WBNoise
    if(MeasMode == hpesa_ORFS_MEASURE_SWEPT)
        errStatus = hpesa_cmdInt(instrumentHandle,":ORFS:WBN",GSM_ORFS_WBNoise);
	
	
	return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                  end hpesa_GSM_ORFSSetWidebandNoiseMode                   */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_ORFSGetWidebandNoiseMode                                       */
/*                                                                           */
/*      This method retrieves the current state of the wideband noise        */
/*      function for GSM output RF spectrum measurements.                    */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPBoolean GSM_ORFS_WBNoiseQuery                                       */
/*                                                                           */
/*      Returns the current state of the wideband noise function.            */
/*                                                                           */
/*      0 = VI_FALSE                                                         */
/*      1 = VI_TRUE                                                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_ORFSGetWidebandNoiseMode
                       (ViSession instrumentHandle,
                        ViPBoolean GSM_ORFS_WBNoiseQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_NULL_POINTER(GSM_ORFS_WBNoiseQuery,VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    //Retrieve the current WBNoise
	errStatus = hpesa_cmdInt16_Q(instrumentHandle, 
                                  ":ORFS:WBN?", 
                                 GSM_ORFS_WBNoiseQuery);

	if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                  end hpesa_GSM_ORFSGetWidebandNoiseMode                   */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TSPConfigure                                                   */
/*                                                                           */
/*      This method sets up the instrument for GSM Transmit Band Spur (TSP)  */
/*      measurements using the factory default instrument settings and stops */
/*      the current measurement. It does not initiate the taking of          */
/*      measurement data.                                                    */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TSPConfigure
                       (ViSession instrumentHandle)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = hpesa_cmd(instrumentHandle, ":CONF:TSP");

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_GSM_TSPConfigure                         */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TSPMeasure                                                     */
/*                                                                           */
/*      This method measures the GSM spurious emissions in the transmit band */
/*      relative to the channel power in the selected channel.  Three values */
/*      are returned that correspond to the frequency and amplitude of the   */
/*      worst spur and the Float32NAN.                                       */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 GSM_TSPMeasureTimeout                                         */
/*                                                                           */
/*      This value temporarily changes the VISA timeout setting for the      */
/*      duration of the instrument measurement. The user needs to set this   */
/*      value to an appropriate time that will be longer then the expected   */
/*      measurement time. Units are in seconds.                              */
/*                                                                           */
/*    ViInt16 GSM_TSPMeasureType                                             */
/*                                                                           */
/*      Selects measurement type. Note that for hpesa_FETCH type the         */
/*      instrument should already be in this measurement mode else the       */
/*      function will time out. User can select this measurement mode by     */
/*      first using the "MEASURE" or "READ" types or call the                */
/*      hpesa_GSM_TSPConfigure function.                                     */
/*                                                                           */
/*      hpesa_MEASURE - Stops current measurement, changes to this selected  */
/*      measurement, sets up instrument using factory defaults, makes        */
/*      measurement, returns measurement results.                            */
/*                                                                           */
/*      hpesa_READ - Stops current measurement,  changes to this selected    */
/*      measurement, uses instrument settings from last measurement of this  */
/*      type, makes measurement, returns measurements results.               */
/*                                                                           */
/*      hpesa_FETCH - Returns measurements results only. No new measurement  */
/*      is initiated.                                                        */
/*                                                                           */
/*    ViPReal64 GSM_TSPWorstSpurFreqQuery                                    */
/*                                                                           */
/*      The frequency of the worst spur (in Hz).                             */
/*                                                                           */
/*    ViPReal64 GSM_TSPWorstSpurAmpQuery                                     */
/*                                                                           */
/*      The amplitude of the worst spur relative to limit (in dB).           */
/*                                                                           */
/*    ViPReal64 GSM_TSMFloat32NANQuery                                       */
/*                                                                           */
/*      Float32NAN is returned at all times for GSM.                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TSPMeasure
                       (ViSession instrumentHandle,
                        ViReal64 GSM_TSPMeasureTimeout,
                        ViInt16 GSM_TSPMeasureType,
                        ViPReal64 GSM_TSPWorstSpurFreqQuery,
                        ViPReal64 GSM_TSPWorstSpurAmpQuery,
                        ViPReal64 GSM_TSMFloat32NANQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    ViReal64 MeasData[3];
    ViInt32 temp = 0;
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_ENUM(GSM_TSPMeasureType, 0, hpesa_MEASURE_METHOD_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)
    CHK_NULL_POINTER(GSM_TSPWorstSpurFreqQuery, VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(GSM_TSPWorstSpurAmpQuery, VI_ERROR_PARAMETER5)
    CHK_NULL_POINTER(GSM_TSMFloat32NANQuery, VI_ERROR_PARAMETER6)
    
	// check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    errStatus = GenMeasureTrace(instrumentHandle,
                               hpesa_APPLICATION_MODE_TSP,
                               GSM_TSPMeasureTimeout,
                               GSM_TSPMeasureType,
                               hpesa_RESULTS_TYPE_1,
                               MeasData,
                               3,
                               &temp);
    if(errStatus < VI_SUCCESS) return errStatus;
	
	if(temp == 3)
    {
        * GSM_TSPWorstSpurFreqQuery     = MeasData[0];
        * GSM_TSPWorstSpurAmpQuery      = MeasData[1];
        * GSM_TSMFloat32NANQuery        = MeasData[2];
          
        errStatus = VI_SUCCESS;
    }
    else
	      errStatus = hpesa_INSTR_ERROR_UNEXPECTED;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                          end hpesa_GSM_TSPMeasure                         */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TSPMeasureTrace                                                */
/*                                                                           */
/*      This method measures the GSM spurious emissions in the transmit band */
/*      relative to the channel power in the selected channel.               */
/*                                                                           */
/*      User can select one of three types of measurement modes: Measure,    */
/*      Read, or Fetch.                                                      */
/*                                                                           */
/*                                                                           */
/*      This method returns the TSP measurement results specified by the     */
/*      "GSM_TSPResultsType" parameter as a real array.                      */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViReal64 GSM_TSPMeasureTraceTimeout                                    */
/*                                                                           */
/*      This value temporarily changes the VISA timeout setting for the      */
/*      duration of the instrument measurement. The user needs to set this   */
/*      value to an appropriate time that will be longer then the expected   */
/*      measurement time. Units are in seconds.                              */
/*                                                                           */
/*    ViInt16 GSM_TSPMeasureTraceType                                        */
/*                                                                           */
/*      Selects measurement type. Note that for hpesa_FETCH type the         */
/*      instrument should already be in this measurement mode else the       */
/*      function will time out. User can select this measurement mode by     */
/*      first using the "MEASURE" or "READ" types or call the                */
/*      hpesa_GSM_TSPConfigure function.                                     */
/*                                                                           */
/*      hpesa_MEASURE - Stops current measurement, changes to this selected  */
/*      measurement, sets up instrument using factory defaults, makes        */
/*      measurement, returns measurement results.                            */
/*                                                                           */
/*      hpesa_READ - Stops current measurement,  changes to this selected    */
/*      measurement, uses instrument settings from last measurement of this  */
/*      type, makes measurement, returns measurements results.               */
/*                                                                           */
/*      hpesa_FETCH - Returns measurements results only. No new measurement  */
/*      is initiated.                                                        */
/*                                                                           */
/*    ViInt16 GSM_TSPResultsType                                             */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_0:  Not supported by instrument.                  */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_1:  Returns 3 scalar results:                     */
/*      1. The frequency of the worst spur (in Hz)                           */
/*      2. The amplitude of the worst spur relative to limit (in dB)         */
/*      3. Float32NAN is returned at all times for GSM                       */
/*                                                                           */
/*      hpesa_RESULTS_TYPE_2:  Returns the current trace data (401 point     */
/*      real number comma separated list).                                   */
/*                                                                           */
/*    ViAReal64 GSM_TSPDataResults                                           */
/*                                                                           */
/*      Trace data returned by measurement, formatted according to           */
/*      GSM_TSPResultsType.                                                  */
/*                                                                           */
/*    ViInt32 GSM_TSPDataResultsMaxSize                                      */
/*                                                                           */
/*      Specifies the maximum size of GSM_TSPDataResults array.              */
/*                                                                           */
/*    ViPInt32 GSM_TSPDataResultsSize                                        */
/*                                                                           */
/*      Returns the actual size of GSM_TSPDataResults array.                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TSPMeasureTrace
                       (ViSession instrumentHandle,
                        ViReal64 GSM_TSPMeasureTraceTimeout,
                        ViInt16 GSM_TSPMeasureTraceType,
                        ViInt16 GSM_TSPResultsType,
                        ViAReal64 GSM_TSPDataResults,
                        ViInt32 GSM_TSPDataResultsMaxSize,
                        ViPInt32 GSM_TSPDataResultsSize)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
    int TSPValidResults[7] = {0,1,1,0,0,0,0};
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the input parameters
    CHK_ENUM(GSM_TSPMeasureTraceType, 0, hpesa_MEASURE_METHOD_LASTENUM, 
                                                        VI_ERROR_PARAMETER3)
    CHK_ENUM(GSM_TSPResultsType, 0, hpesa_RESULTS_TYPE_LASTENUM,
                                                        VI_ERROR_PARAMETER4)
    CHK_NULL_POINTER(GSM_TSPDataResults, VI_ERROR_PARAMETER5)
    CHK_NULL_POINTER(GSM_TSPDataResultsSize, VI_ERROR_PARAMETER7)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    if((GSM_TSPResultsType > 6) || (TSPValidResults[GSM_TSPResultsType] == 0))
        return hpesa_INSTR_ERROR_INVALID_RESULTS_TYPE;

    errStatus = GenMeasureTrace(instrumentHandle,
                               hpesa_APPLICATION_MODE_TSP,
                               GSM_TSPMeasureTraceTimeout,
                               GSM_TSPMeasureTraceType,
                               GSM_TSPResultsType,
                               GSM_TSPDataResults,
                               GSM_TSPDataResultsMaxSize,
                               GSM_TSPDataResultsSize);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_TSPMeasureTrace                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TSPSetAveraging                                                */
/*                                                                           */
/*      This method sets the averaging for GSM transmit band spur (TSP)      */
/*      measurements.  User can control the number of averages, turn off or  */
/*      on averaging, set the terminal control mode for averaging, and set   */
/*      the average type.                                                    */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt32 GSM_TSPAverageCount                                            */
/*                                                                           */
/*      Set the number of data acquisitions that will be averaged. After the */
/*      specified number of average counts, the averaging mode (terminal     */
/*      control) setting determines the averaging action.                    */
/*                                                                           */
/*    ViBoolean GSM_TSPAverageState                                          */
/*                                                                           */
/*      Sets the state of averaging, either on or off.                       */
/*                                                                           */
/*      VI_TRUE = Averaging on.                                              */
/*      VI_FALSE = Averaging off.                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TSPSetAveraging
                       (ViSession instrumentHandle,
                        ViInt32 GSM_TSPAverageCount,
                        ViBoolean GSM_TSPAverageState)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";

	GET_GLOBALS(instrumentHandle, thisPtr)
	
    // check the input parameters
    CHK_BOOLEAN(GSM_TSPAverageState, VI_ERROR_PARAMETER3)
    
	
    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	//Set GSM_TSPAverageCount
	errStatus = hpesa_cmdInt(instrumentHandle, 
                              ":TSP:AVER:COUN", 
                                GSM_TSPAverageCount);

	if(errStatus <VI_SUCCESS) return errStatus;

	//Set GSM_TSPAverageState
	errStatus = hpesa_cmdInt(instrumentHandle,":TSP:AVER",GSM_TSPAverageState);
 	
	if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_TSPSetAveraging                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TSPGetAveraging                                                */
/*                                                                           */
/*      This method retrieves the average settings for GSM transmit band     */
/*      spur measurements.                                                   */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt32 GSM_TSPAverageCountQuery                                      */
/*                                                                           */
/*      Returns the current average count.                                   */
/*                                                                           */
/*    ViPBoolean GSM_TSPAverageStateQuery                                    */
/*                                                                           */
/*      Returns the current average atate.                                   */
/*                                                                           */
/*      0 = VI_FALSE                                                         */
/*      1 = VI_TRUE                                                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TSPGetAveraging
                       (ViSession instrumentHandle,
                        ViPInt32 GSM_TSPAverageCountQuery,
                        ViPBoolean GSM_TSPAverageStateQuery)
                        
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
        
    GET_GLOBALS(instrumentHandle, thisPtr)

	//Check parameters
	CHK_NULL_POINTER(GSM_TSPAverageCountQuery, VI_ERROR_PARAMETER2)
    CHK_NULL_POINTER(GSM_TSPAverageStateQuery, VI_ERROR_PARAMETER3)
	
	// Retrieve the averaging count
    errStatus = hpesa_cmdInt32_Q(instrumentHandle,":TSP:AVER:COUN?",GSM_TSPAverageCountQuery);
	if (errStatus < VI_SUCCESS) return errStatus;

	// Retrieve the averaging state
    errStatus = hpesa_cmdInt16_Q(instrumentHandle,":TSP:AVER?",GSM_TSPAverageStateQuery);
	if (errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                       end hpesa_GSM_TSPGetAveraging                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TSPSetMeasurementType                                          */
/*                                                                           */
/*      This method sets the measurement type for GSM tranmit band spur      */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_TSPMeasType                                                */
/*                                                                           */
/*      Selects the measurement type.                                        */
/*                                                                           */
/*      hpesa_TSP_MEAS_TYPE_EXAMINE - measures spurs in all the valid        */
/*      segments and then displays the segment that has the worst spur.      */
/*                                                                           */
/*      hpesa_TSP_MEAS_TYPE_FULL - continuously measures the spurs in all    */
/*      the valid segments.                                                  */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TSPSetMeasurementType
                       (ViSession instrumentHandle,
                        ViInt16 GSM_TSPMeasType)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[256] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	CHK_ENUM(GSM_TSPMeasType, 0, hpesa_TSP_MEAS_TYPE_LASTENUM, 
                                                        VI_ERROR_PARAMETER2)
	switch(GSM_TSPMeasType)
    {
        case hpesa_TSP_MEAS_TYPE_EXAMINE:
            sprintf(buffer, ":TSP:TYPE EXAM");
            break;
        case hpesa_TSP_MEAS_TYPE_FULL:
            sprintf(buffer, ":TSP:TYPE FULL");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_TSPSetMeasurementType");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }
	errStatus = hpesa_cmd(instrumentHandle, buffer);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_GSM_TSPSetMeasurementType                    */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TSPGetMeasurementType                                          */
/*                                                                           */
/*      This method retrieves the current measurement type for GSM transmit  */
/*      band spur measurements.                                              */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPInt16 GSM_TSPMeasTypeQuery                                          */
/*                                                                           */
/*      Returns the current measurement type.                                */
/*                                                                           */
/*      0 = hpesa_TSP_MEAS_TYPE_EXAMINE                                      */
/*      1 = hpesa_TSP_MEAS_TYPE_FULL                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TSPGetMeasurementType
                       (ViSession instrumentHandle,
                        ViPInt16 GSM_TSPMeasTypeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char buffer[64] = "\0";
    
    GET_GLOBALS(instrumentHandle, thisPtr)

    //check for null pointer
	CHK_NULL_POINTER(GSM_TSPMeasTypeQuery,VI_ERROR_PARAMETER2)

    //check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    //Retrieve the Measurement Type
    errStatus = hpesa_cmdString_Q(instrumentHandle,
                                  ":TSP:TYPE?",
                                  64, 
                                  buffer);

    if(errStatus<VI_SUCCESS) return errStatus;

	//remove the trailing \n
	buffer[strlen(buffer) - 1] = '\0';

    if(!strcmp(buffer, "EXAM"))
           *GSM_TSPMeasTypeQuery = hpesa_TSP_MEAS_TYPE_EXAMINE;
    else if (!strcmp(buffer, "FULL"))
    	   *GSM_TSPMeasTypeQuery = hpesa_TSP_MEAS_TYPE_FULL;
    else
    {
        thisPtr->errNumber = hpesa_INSTR_ERROR_LOOKUP;
        sprintf(thisPtr->errMessage, hpesa_MSG_NO_MATCH, buffer);
        errStatus = hpesa_INSTR_ERROR_LOOKUP;
    }

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                    end hpesa_GSM_TSPGetMeasurementType                    */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TSPSetLimit                                                    */
/*                                                                           */
/*      This method sets the maximum limit value for the GSM transmit band   */
/*      spur measurements.                                                   */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*																			 */
/*    ViInt16 GSM_TSPStandardBand                                            */
/*                                                                           */
/*      Determines the standard band that the limit will be applied to.      */
/*                                                                           */
/*      hpesa_GSM_RADIO_BAND_PGSM - P-GSM 900                                */
/*      hpesa_GSM_RADIO_BAND_EGSM - E-GSM 900                                */
/*      hpesa_GSM_RADIO_BAND_RGSM - R-GSM 900                                */
/*      hpesa_GSM_RADIO_BAND_DCS  - DCS 1800                                 */
/*      hpesa_GSM_RADIO_BAND_PCS  - PCS 1900                                 */
/*                                                                           */
/*                                                                           */
/*    ViInt16 GSM_TSPLimitDevice                                             */
/*                                                                           */
/*      Determines the radio device to set the limit for.                    */
/*                                                                           */
/*      hpesa_GSM_RADIO_DEVICE_MS - Mobile station transmitter               */
/*      hpesa_GSM_RADIO_DEVICE_BTS - Base station ransmitter                 */
/*      hpesa_GSM_RADIO_DEVICE_UBTS1 - Micro base station class M1           */
/*      transmitter                                                          */
/*      hpesa_GSM_RADIO_DEVICE_UBTS2 - Micro base station class M2           */
/*      transmitter                                                          */
/*      hpesa_GSM_RADIO_DEVICE_UBTS3 - Micro base station class M3           */
/*      transmitter                                                          */
/*                                                                           */
/*    ViReal64 GSM_TSPMaxLimit                                               */
/*                                                                           */
/*      Set the maximum limit value in dBm.                                  */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TSPSetLimit
                       (ViSession instrumentHandle,
                        ViInt16 GSM_TSPStandardBand,
					    ViInt16 GSM_TSPLimitDevice,
						ViReal64 GSM_TSPMaxLimit)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char Band[64] = "\0";
    char Device[64] = "\0";
	ViChar cmdString[256] = "\0";
	
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	CHK_ENUM(GSM_TSPStandardBand, 0, hpesa_GSM_RADIO_BAND_LASTENUM, 
                                                      VI_ERROR_PARAMETER2)
	CHK_ENUM(GSM_TSPLimitDevice, 0, hpesa_GSM_RADIO_DEVICE_LASTENUM, 
                                                      VI_ERROR_PARAMETER3)
	
	//Set TSPStandardBand
	switch(GSM_TSPStandardBand)
    {
        case hpesa_GSM_RADIO_BAND_PGSM:
            sprintf(Band, "PGSM");
            break;
        case hpesa_GSM_RADIO_BAND_EGSM:
            sprintf(Band, "EGSM");
            break;
        case hpesa_GSM_RADIO_BAND_RGSM:
            sprintf(Band, "RGSM");
            break;
        case hpesa_GSM_RADIO_BAND_DCS:
            sprintf(Band, "DCS");
            break;
        case hpesa_GSM_RADIO_BAND_PCS:
            sprintf(Band, "PCS");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_TSPSetLimit");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }
											   										  
	//Set TSPLimitDevice
	switch(GSM_TSPLimitDevice)
    {
        case hpesa_GSM_RADIO_DEVICE_MS:
            sprintf(Device, "MS");
            break;
        case hpesa_GSM_RADIO_DEVICE_BTS:
            sprintf(Device, "BTS");
            break;
        case hpesa_GSM_RADIO_DEVICE_UBTS1:
            sprintf(Device, "UBTS1");
            break;
        case hpesa_GSM_RADIO_DEVICE_UBTS2:
            sprintf(Device, "UBTS2");
            break;
        case hpesa_GSM_RADIO_DEVICE_UBTS3:
            sprintf(Device, "UBTS3");
            break;
        default:
            fprintf(stderr, "Logic error in hpesa_GSM_TSPSetLimit");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    sprintf(cmdString, "CALC:TSP:LIM:%s:%s", Band, Device);

    //Set TSPMaxLimit
	errStatus = hpesa_cmdReal(instrumentHandle, 
                              cmdString,GSM_TSPMaxLimit);

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                         end hpesa_GSM_TSPSetLimit                         */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TSPGetLimit                                                    */
/*                                                                           */
/*      This method retrieves the current maximum limit value for GSM        */
/*      transmit band spur measurements.                                     */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViInt16 GSM_TSPStandardBandQ                                           */
/*                                                                           */
/*      Determines the standard band to query the limit for.                 */
/*                                                                           */
/*      hpesa_GSM_RADIO_BAND_PGSM - P-GSM 900                                */
/*      hpesa_GSM_RADIO_BAND_EGSM - E-GSM 900                                */
/*      hpesa_GSM_RADIO_BAND_RGSM - R-GSM 900                                */
/*      hpesa_GSM_RADIO_BAND_DCS  - DCS 1800                                 */
/*      hpesa_GSM_RADIO_BAND_PCS  - PCS 1900                                 */
/*                                                                           */
/*    ViInt16 GSM_TSPLimitDeviceQ                                            */
/*                                                                           */
/*      Determines the radio device to query the limit for.                  */
/*                                                                           */
/*      hpesa_GSM_RADIO_DEVICE_MS - Mobile station transmitter               */
/*      hpesa_GSM_RADIO_DEVICE_BTS - Base station transmitter                */
/*      hpesa_GSM_RADIO_DEVICE_UBTS1 - Micro base station class M1           */
/*      transmitter                                                          */
/*      hpesa_GSM_RADIO_DEVICE_UBTS2 - Micro base station class M2           */
/*      transmitter                                                          */
/*      hpesa_GSM_RADIO_DEVICE_UBTS3 - Micro base station class M3           */
/*      transmitter                                                          */
/*                                                                           */
/*    ViPReal64 GSM_TSPMaxLimitQuery                                         */
/*                                                                           */
/*      Returns the current limit value.                                     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TSPGetLimit
                       (ViSession instrumentHandle,
                        ViInt16 GSM_TSPStandardBandQ,
                        ViInt16 GSM_TSPLimitDeviceQ,
                        ViPReal64 GSM_TSPMaxLimitQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	char Band[64] = "\0";
    char Device[64] = "\0";
	ViChar cmdString[256] = "\0";
	
    GET_GLOBALS(instrumentHandle, thisPtr)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

	CHK_ENUM(GSM_TSPStandardBandQ, 0, hpesa_GSM_RADIO_BAND_LASTENUM, 
                                                      VI_ERROR_PARAMETER2)
	CHK_ENUM(GSM_TSPLimitDeviceQ, 0, hpesa_GSM_RADIO_DEVICE_LASTENUM, 
                                                      VI_ERROR_PARAMETER3)

    CHK_NULL_POINTER(GSM_TSPMaxLimitQuery, VI_ERROR_PARAMETER4)
	
	//Set TSPStandardBand
	switch(GSM_TSPStandardBandQ)
    {
        case hpesa_GSM_RADIO_BAND_PGSM:
            sprintf(Band, "PGSM");
            break;
        case hpesa_GSM_RADIO_BAND_EGSM:
            sprintf(Band, "EGSM");
            break;
        case hpesa_GSM_RADIO_BAND_RGSM:
            sprintf(Band, "RGSM");
            break;
        case hpesa_GSM_RADIO_BAND_DCS:
            sprintf(Band, "DCS");
            break;
        case hpesa_GSM_RADIO_BAND_PCS:
            sprintf(Band, "PCS");
            break;
		default:
            fprintf(stderr, "Logic error in hpesa_GSM_TSPSetLimit");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }
											   										  
	//Set TSPLimitDevice
	switch(GSM_TSPLimitDeviceQ)
    {
        case hpesa_GSM_RADIO_DEVICE_MS:
            sprintf(Device, "MS");
            break;
        case hpesa_GSM_RADIO_DEVICE_BTS:
            sprintf(Device, "BTS");
            break;
        case hpesa_GSM_RADIO_DEVICE_UBTS1:
            sprintf(Device, "UBTS1");
            break;
        case hpesa_GSM_RADIO_DEVICE_UBTS2:
            sprintf(Device, "UBTS2");
            break;
        case hpesa_GSM_RADIO_DEVICE_UBTS3:
            sprintf(Device, "UBTS3");
            break;
        default:
            fprintf(stderr, "Logic error in hpesa_GSM_TSPSetLimit");
            return hpesa_INSTR_ERROR_UNEXPECTED;
    }

    sprintf(cmdString, "CALC:TSP:LIM:%s:%s?", Band, Device);

    //Set TSPMaxLimit
	errStatus = hpesa_cmdReal64_Q(instrumentHandle, 
                                  cmdString,
                                  GSM_TSPMaxLimitQuery);


    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                         end hpesa_GSM_TSPGetLimit                         */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TSPSetIdleMode                                                 */
/*                                                                           */
/*      This method sets the idle mode for GSM transmit band spur            */
/*      measurements.                                                        */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViBoolean GSM_TSPIdleMode                                              */
/*                                                                           */
/*      Set idle mode to VI_TRUE if the transmitter is set to idle, or       */
/*      VI_FALSE if the transmitter has an active channel.                   */
/*                                                                           */
/*      VI_TRUE - sets idle mode to On                                       */
/*      VI_FALSE - sets idle mode to Off                                     */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TSPSetIdleMode
                       (ViSession instrumentHandle,
                        ViBoolean GSM_TSPIdleMode)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	    
    GET_GLOBALS(instrumentHandle, thisPtr)

	//Check parameters
	CHK_BOOLEAN(GSM_TSPIdleMode, VI_ERROR_PARAMETER2)

	//Verify Application
	VERIFY_APP(hpesa_APPLICATION_GSM)

	//Set Idle Mode
	errStatus = hpesa_cmdInt(instrumentHandle,":TSP:IDLE",GSM_TSPIdleMode);
	
	if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_GSM_TSPSetIdleMode                       */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/*  hpesa_GSM_TSPGetIdleMode                                                 */
/*                                                                           */
/*      This method retrieves the current idle mode for GSM transmit band    */
/*      spur measurements.                                                   */
/*                                                                           */
/*    ViSession instrumentHandle                                             */
/*                                                                           */
/*      Instrument handle returned from hpesa_init().                        */
/*                                                                           */
/*    ViPBoolean GSM_TSPIdleModeQuery                                        */
/*                                                                           */
/*      Returns the current idle mode state.                                 */
/*                                                                           */
/*      0 = VI_TRUE                                                          */
/*      1 = VI_FALSE                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
ViStatus _VI_FUNC hpesa_GSM_TSPGetIdleMode
                       (ViSession instrumentHandle,
                        ViPBoolean GSM_TSPIdleModeQuery)
{

    ViStatus errStatus = VI_SUCCESS;
	struct hpesa_globals *thisPtr;
	GET_GLOBALS(instrumentHandle, thisPtr)

    // check parameters
    CHK_NULL_POINTER(GSM_TSPIdleModeQuery,VI_ERROR_PARAMETER2)

    // check the application
    VERIFY_APP(hpesa_APPLICATION_GSM)

    //Retrieve IdleMode
	errStatus = hpesa_cmdInt16_Q(instrumentHandle, 
                                  ":TSP:IDLE?", 
                                 GSM_TSPIdleModeQuery);

	if(errStatus < VI_SUCCESS) return errStatus;

    return errStatus;
}
/*---------------------------------------------------------------------------*/
/*                        end hpesa_GSM_TSPGetIdleMode                       */
/*****************************************************************************/

